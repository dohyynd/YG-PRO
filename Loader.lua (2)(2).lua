-- New example script written by wally
-- You can suggest changes with a pull request or something

local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Options = Library.Options
local Toggles = Library.Toggles

Library.ShowToggleFrameInKeybinds = true -- Make toggle keybinds work inside the keybinds UI (aka adds a toggle to the UI). Good for mobile users (Default value = true)
Library.ShowCustomCursor = true -- Toggles the Linoria cursor globaly (Default value = true)
Library.NotifySide = "Left" -- Changes the side of the notifications globaly (Left, Right) (Default value = Left)

local Window = Library:CreateWindow({
	-- Set Center to true if you want the menu to appear in the center
	-- Set AutoShow to true if you want the menu to appear when it is created
	-- Set Resizable to true if you want to have in-game resizable Window
	-- Set ShowCustomCursor to false if you don't want to use the Linoria cursor
	-- Set UnlockMouseWhileOpen to false if you don't want to unlock the mouse when the UI is toggled
	-- NotifySide = Changes the side of the notifications (Left, Right) (Default value = Left)
	-- Position and Size are also valid options here
	-- but you do not need to define them unless you are changing them :)

	Title = 'YG SCRIPT付费',----脚本名
	Center = true,
	AutoShow = true,
	Resizable = true,
	ShowCustomCursor = true,
	UnlockMouseWhileOpen = true,
	NotifySide = "Left",---通知位置
	TabPadding = 8,
	MenuFadeTime = 0.2
})

-- CALLBACK NOTE:
-- Passing in callback functions via the initial element parameters (i.e. Callback = function(Value)...) works
-- HOWEVER, using Toggles/Options.INDEX:OnChanged(function(Value) ... ) is the RECOMMENDED way to do this.
-- I strongly recommend decoupling UI code from logic code. i.e. Create your UI elements FIRST, and THEN setup :OnChanged functions later.

-- You do not have to set your tabs & groups up this way, just a prefrence.
local Tabs = {
	-- Creates a new tab titled Main
	Main = Window:AddTab('Server'),
	['UI Settings'] = Window:AddTab('UI Settings'),
}


local LeftGroupBox = Tabs.Main:AddLeftGroupbox('服务器列表')


local MyButton = LeftGroupBox:AddButton({
    Text = '通缉',---服务器名称
    Func = function()
    local originalUI = Library---这个不用动
-----↓↓↓↓↓源码放置↓↓↓↓↓↓
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/454244513/WindUIFix/refs/heads/main/main.lua"))()
local Window = WindUI:CreateWindow({
    Title = "YG/TNINE SCRIPT",
    Author = "付费 by YG/TNINE team",
    Folder = "CloudHub",
    Size = UDim2.fromOffset(200, 395),
    Transparent = true,
    Theme = "Dark",
    User = {
        Enabled = true,
        Callback = function() end,
        Anonymous = false
    },
    SideBarWidth = 200,
    ScrollBarEnabled = true,
    Background = "https://raw.githubusercontent.com/dohyynd/YG-THINE/refs/heads/main/IMG_20260216_112951_671.jpg",
    BackgroundImageTransparency = 0.65,
})

Window:EditOpenButton({
    Title = "Paid User",
    Icon = "crown",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2.35,
    Color = ColorSequence.new(
        Color3.fromHex("3C1361"),
        Color3.fromHex("6A0DAD")
    ),
    Draggable = true,
})

-- 获取必要服务
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- 初始化角色引用
local function InitRootPart()
    if LocalPlayer.Character then
        RootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    else
        RootPart = nil
    end
end
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    InitRootPart()
end)
InitRootPart()

-- ========== 功能全局变量 ==========
local AutoShoot = false
local ShooterModule, OriginalShoot
local getgenv = getgenv or function() return _G end
getgenv().TrailColors = {
    StartColor = Color3.fromRGB(0, 170, 255),
    EndColor = Color3.fromRGB(255, 0, 0),
    MiddleColor1 = Color3.fromRGB(255, 0, 255),
    MiddleColor2 = Color3.fromRGB(255, 255, 0)
}
getgenv().TrailTransparency = 0.3
getgenv().ShootInterval = 0.2

-- ========== 创建所有标签页 ==========
local MainTab = Window:Tab({Title = "主功能", Icon = "home"})
local WeaponTab = Window:Tab({Title = "武器修改", Icon = "target"})
local TeleportTab = Window:Tab({Title = "传送", Icon = "map-pin"})
local WeaponsTab = Window:Tab({Title = "武器获取", Icon = "swords"})
local MoneyTab = Window:Tab({Title = "金钱", Icon = "dollar-sign"})
local CombatTab = Window:Tab({Title = "战斗", Icon = "swords"})
local PlayerTab = Window:Tab({Title = "本地玩家", Icon = "user"})
local AboutTab = Window:Tab({Title = "关于", Icon = "info", IconColor = Color3.fromHex("#83889E"), IconShape = "Square", Border = true})

-- ========== MainTab 功能 (愤怒机器人 + 弹道颜色) ==========
MainTab:Section({
    Title = "Toggle",
    TextSize = 16,
    FontWeight = Enum.FontWeight.SemiBold,
})

local AutoShootInput = MainTab:Input({
    Flag = "AutoShootInput",
    Title = "愤怒机器人(open开启close关闭)",
    Desc = "输入open启用close关闭自动射击",
    Value = "close",
    Placeholder = "输入open使用close关闭",
    Callback = function(v)
        AutoShoot = v:lower() == "open"
        if AutoShoot then
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local clientTool = ReplicatedStorage:FindFirstChild("Client", true)
                    and ReplicatedStorage.Client:FindFirstChild("Wanted", true)
                    and ReplicatedStorage.Client.Wanted:FindFirstChild("Objects", true)
                    and ReplicatedStorage.Client.Wanted.Objects:FindFirstChild("ClientTool", true)
                    and ReplicatedStorage.Client.Wanted.Objects.ClientTool:FindFirstChild("Components", true)
                    and ReplicatedStorage.Client.Wanted.Objects.ClientTool.Components:FindFirstChild("Guns", true)
                    and ReplicatedStorage.Client.Wanted.Objects.ClientTool.Components.Guns:FindFirstChild("Shooter", true)
                
                if not clientTool then
                    WindUI:Notify({ Title = "错误", Content = "未找到枪械模块", Duration = 3, Color = "Red" })
                    AutoShoot = false
                    AutoShootInput:Set("close")
                    return
                end
                
                ShooterModule = require(clientTool)
                OriginalShoot = ShooterModule._shoot
                
                local function createBezierCurve(p0, p1, p2, t)
                    return (1 - t)^2 * p0 + 2 * (1 - t) * t * p1 + t^2 * p2
                end
                
                local function createBeautifulTrail(origin, targetPos)
                    local trailContainer = Instance.new("Folder")
                    trailContainer.Name = "MagicTrail"
                    trailContainer.Parent = Workspace
                    
                    local midPoint = (origin + targetPos) / 2
                    local direction = (targetPos - origin).Unit
                    local perpendicular = Vector3.new(-direction.Z, direction.Y, direction.X) * 3
                    local controlPoint = midPoint + perpendicular + Vector3.new(0, math.random(-3, 3), 0)
                    
                    local curvePoints = {}
                    local numSegments = 20
                    
                    for i = 0, numSegments do
                        local t = i / numSegments
                        local point = createBezierCurve(origin, controlPoint, targetPos, t)
                        table.insert(curvePoints, point)
                    end
                    
                    for i = 1, #curvePoints - 1 do
                        local startPoint = curvePoints[i]
                        local endPoint = curvePoints[i + 1]
                        local distance = (endPoint - startPoint).Magnitude
                        
                        local beamPart = Instance.new("Part")
                        beamPart.Size = Vector3.new(0.15, 0.15, distance)
                        beamPart.Anchored = true
                        beamPart.CanCollide = false
                        beamPart.Material = Enum.Material.Neon
                        beamPart.Transparency = 0.3
                        beamPart.CFrame = CFrame.new(startPoint, endPoint) * CFrame.new(0, 0, -distance / 2)
                        beamPart.Parent = trailContainer
                        
                        local tParam = i / (#curvePoints - 1)
                        local color
                        if tParam < 0.3 then
                            color = getgenv().TrailColors.StartColor or Color3.fromRGB(0, 170, 255)
                        elseif tParam < 0.6 then
                            color = getgenv().TrailColors.MiddleColor1 or Color3.fromRGB(255, 0, 255)
                        elseif tParam < 0.9 then
                            color = getgenv().TrailColors.MiddleColor2 or Color3.fromRGB(255, 255, 0)
                        else
                            color = getgenv().TrailColors.EndColor or Color3.fromRGB(255, 0, 0)
                        end
                        
                        beamPart.Color = color
                        
                        local pointLight = Instance.new("PointLight")
                        pointLight.Brightness = 5
                        pointLight.Range = 3
                        pointLight.Color = color
                        pointLight.Parent = beamPart
                        
                        local particles = Instance.new("ParticleEmitter")
                        particles.Size = NumberSequence.new(0.1, 0.3)
                        particles.Transparency = NumberSequence.new(0.3, 0.8)
                        particles.Lifetime = NumberRange.new(0.5, 1)
                        particles.Rate = 50
                        particles.Speed = NumberRange.new(1, 2)
                        particles.VelocitySpread = 180
                        particles.Color = ColorSequence.new(color)
                        particles.Parent = beamPart
                    end
                    
                    task.delay(1.5, function()
                        if trailContainer and trailContainer.Parent then
                            trailContainer:Destroy()
                        end
                    end)
                    
                    return trailContainer
                end
                
                local function hasLineOfSight(shooterPos, targetPos)
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
                    raycastParams.IgnoreWater = true
                    
                    local direction = (targetPos - shooterPos).Unit
                    local distance = (targetPos - shooterPos).Magnitude
                    local raycastResult = Workspace:Raycast(shooterPos, direction * distance, raycastParams)
                    
                    if raycastResult then
                        local hitPart = raycastResult.Instance
                        if hitPart then
                            local hitCharacter = hitPart:FindFirstAncestorOfClass("Model")
                            if hitCharacter and hitCharacter:FindFirstChild("Humanoid") then
                                return true
                            else
                                return false
                            end
                        end
                    end
                    return true
                end
                
                ShooterModule._shoot = function(self)
                    if not self or not self.tool then
                        return OriginalShoot(self)
                    end
                    
                    local LocalCharacter = LocalPlayer.Character
                    if not LocalCharacter then
                        return OriginalShoot(self)
                    end
                    
                    local shooterPos = LocalCharacter.HumanoidRootPart and LocalCharacter.HumanoidRootPart.Position 
                        or LocalCharacter.PrimaryPart.Position
                    local nearestPlayer = nil
                    local nearestDistance = math.huge
                    
                    for _, player in ipairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local targetPos = player.Character.HumanoidRootPart.Position
                            local distance = (shooterPos - targetPos).Magnitude
                            
                            if hasLineOfSight(shooterPos, targetPos) and distance < nearestDistance then
                                nearestDistance = distance
                                nearestPlayer = player
                            end
                        end
                    end
                    
                    if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local targetPos = nearestPlayer.Character.HumanoidRootPart.Position
                        self.aimpoint = targetPos
                        self.aimpoint2 = targetPos
                        
                        if self.tool.model and self.tool.model.PrimaryPart then
                            local muzzlePos = self.tool.model.PrimaryPart.Position
                            createBeautifulTrail(muzzlePos, targetPos)
                        else
                            createBeautifulTrail(shooterPos, targetPos)
                        end
                        
                        if self.tool then
                            self.tool.shooting = true
                            self.tool.fireDebounce = 0
                            self.tool.fireMode = "auto"
                        end
                    else
                        if self.tool then
                            self.tool.shooting = false
                        end
                    end
                    
                    return OriginalShoot(self)
                end
                
                while AutoShoot do
                    if ShooterModule and ShooterModule._shoot then
                        local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
                        if tool then
                            local shooter = tool:FindFirstChild("Shooter") or {tool = tool}
                            pcall(function()
                                ShooterModule._shoot(shooter)
                            end)
                        end
                    end
                    task.wait(getgenv().ShootInterval or 0.2)
                end
                
                if OriginalShoot then
                    ShooterModule._shoot = OriginalShoot
                end
            end)
            WindUI:Notify({ Title = "成功", Content = "愤怒机器人已启用", Duration = 3 })
        else
            if ShooterModule and OriginalShoot then
                ShooterModule._shoot = OriginalShoot
            end
            WindUI:Notify({ Title = "提示", Content = "愤怒机器人已关闭", Duration = 3 })
        end
    end
})

MainTab:Space()

MainTab:Section({
    Title = "弹道颜色调整",
    TextSize = 16,
    FontWeight = Enum.FontWeight.SemiBold,
})

local TrailColorStartPicker = MainTab:Colorpicker({
    Flag = "TrailColorStart",
    Title = "弹道起始颜色",
    Desc = "设置弹道开始部分的颜色",
    Default = getgenv().TrailColors.StartColor,
    Transparency = 0,
    Callback = function(color)
        getgenv().TrailColors.StartColor = color
        WindUI:Notify({ 
            Title = "颜色已更新", 
            Content = "弹道起始颜色已设置",
            Duration = 2 
        })
    end
})

MainTab:Space({ Columns = 1 })

local TrailColorMiddle1Picker = MainTab:Colorpicker({
    Flag = "TrailColorMiddle1",
    Title = "弹道中间颜色1",
    Desc = "设置弹道中间部分的颜色",
    Default = getgenv().TrailColors.MiddleColor1,
    Transparency = 0,
    Callback = function(color)
        getgenv().TrailColors.MiddleColor1 = color
        WindUI:Notify({ 
            Title = "颜色已更新", 
            Content = "弹道中间颜色1已设置",
            Duration = 2 
        })
    end
})

MainTab:Space({ Columns = 1 })

local TrailColorMiddle2Picker = MainTab:Colorpicker({
    Flag = "TrailColorMiddle2",
    Title = "弹道中间颜色2",
    Desc = "设置弹道中间部分的颜色",
    Default = getgenv().TrailColors.MiddleColor2,
    Transparency = 0,
    Callback = function(color)
        getgenv().TrailColors.MiddleColor2 = color
        WindUI:Notify({ 
            Title = "颜色已更新", 
            Content = "弹道中间颜色2已设置",
            Duration = 2 
        })
    end
})

MainTab:Space({ Columns = 1 })

local TrailColorEndPicker = MainTab:Colorpicker({
    Flag = "TrailColorEnd",
    Title = "弹道结束颜色",
    Desc = "设置弹道结束部分的颜色",
    Default = getgenv().TrailColors.EndColor,
    Transparency = 0,
    Callback = function(color)
        getgenv().TrailColors.EndColor = color
        WindUI:Notify({ 
            Title = "颜色已更新", 
            Content = "弹道结束颜色已设置",
            Duration = 2 
        })
    end
})

MainTab:Space()

MainTab:Section({
    Title = "弹道预览",
    TextSize = 16,
    FontWeight = Enum.FontWeight.SemiBold,
})

MainTab:Button({
    Title = "测试弹道效果",
    Desc = "在当前位置生成测试弹道（预览颜色效果）",
    Justify = "Center",
    Icon = "zap",
    Callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local startPos = LocalPlayer.Character.HumanoidRootPart.Position
            local endPos = startPos + Vector3.new(0, 0, -20)
            
            local trailContainer = Instance.new("Folder")
            trailContainer.Name = "TestTrail"
            trailContainer.Parent = Workspace
            
            local beam = Instance.new("Part")
            beam.Size = Vector3.new(0.2, 0.2, 20)
            beam.Anchored = true
            beam.CanCollide = false
            beam.Material = Enum.Material.Neon
            beam.Transparency = 0.3
            beam.CFrame = CFrame.new(startPos, endPos) * CFrame.new(0, 0, -10)
            beam.Color = getgenv().TrailColors.StartColor or Color3.fromRGB(0, 170, 255)
            beam.Parent = trailContainer
            
            local pointLight = Instance.new("PointLight")
            pointLight.Brightness = 5
            pointLight.Range = 5
            pointLight.Color = beam.Color
            pointLight.Parent = beam
            
            local particles = Instance.new("ParticleEmitter")
            particles.Size = NumberSequence.new(0.1, 0.3)
            particles.Transparency = NumberSequence.new(0.3, 0.8)
            particles.Lifetime = NumberRange.new(0.5, 1)
            particles.Rate = 50
            particles.Speed = NumberRange.new(1, 2)
            particles.VelocitySpread = 180
            particles.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, getgenv().TrailColors.StartColor or Color3.fromRGB(0, 170, 255)),
                ColorSequenceKeypoint.new(0.3, getgenv().TrailColors.MiddleColor1 or Color3.fromRGB(255, 0, 255)),
                ColorSequenceKeypoint.new(0.6, getgenv().TrailColors.MiddleColor2 or Color3.fromRGB(255, 255, 0)),
                ColorSequenceKeypoint.new(1, getgenv().TrailColors.EndColor or Color3.fromRGB(255, 0, 0))
            })
            particles.Parent = beam
            
            task.delay(3, function()
                if trailContainer and trailContainer.Parent then
                    trailContainer:Destroy()
                end
            end)
            
            WindUI:Notify({ 
                Title = "测试成功", 
                Content = "弹道颜色预览已生成",
                Duration = 3 
            })
        else
            WindUI:Notify({ 
                Title = "错误", 
                Content = "无法找到角色位置",
                Duration = 3,
                Color = "Red"
            })
        end
    end
})

MainTab:Space({ Columns = 1 })

MainTab:Button({
    Title = "重置颜色设置",
    Desc = "恢复所有颜色为默认值",
    Justify = "Center",
    Icon = "rotate-ccw",
    Color = Color3.fromHex("#ff4830"),
    Callback = function()
        getgenv().TrailColors = {
            StartColor = Color3.fromRGB(0, 170, 255),
            EndColor = Color3.fromRGB(255, 0, 0),
            MiddleColor1 = Color3.fromRGB(255, 0, 255),
            MiddleColor2 = Color3.fromRGB(255, 255, 0)
        }
        
        TrailColorStartPicker:Set(Color3.fromRGB(0, 170, 255))
        TrailColorMiddle1Picker:Set(Color3.fromRGB(255, 0, 255))
        TrailColorMiddle2Picker:Set(Color3.fromRGB(255, 255, 0))
        TrailColorEndPicker:Set(Color3.fromRGB(255, 0, 0))
        
        WindUI:Notify({ 
            Title = "重置完成", 
            Content = "所有颜色已恢复为默认值",
            Duration = 3 
        })
    end
})

MainTab:Space()

MainTab:Section({
    Title = "其他设置",
    TextSize = 16,
    FontWeight = Enum.FontWeight.SemiBold,
})

MainTab:Slider({
    Flag = "TrailTransparency",
    Title = "弹道透明度",
    Desc = "调整弹道的透明度",
    Icons = {
        From = "eye",
        To = "eye-off",
    },
    Step = 0.1,
    IsTooltip = true,
    Value = {
        Min = 0,
        Max = 1,
        Default = 0.3,
    },
    Callback = function(value)
        getgenv().TrailTransparency = value
        WindUI:Notify({ 
            Title = "透明度已调整", 
            Content = "弹道透明度设置为: " .. value,
            Duration = 2 
        })
    end
})

MainTab:Space({ Columns = 1 })

MainTab:Slider({
    Flag = "ShootInterval",
    Title = "射击间隔",
    Desc = "调整自动射击的时间间隔（秒）",
    Icons = {
        From = "clock",
        To = "zap",
    },
    Step = 0.1,
    IsTooltip = true,
    Value = {
        Min = 0.1,
        Max = 1.0,
        Default = 0.2,
    },
    Callback = function(value)
        getgenv().ShootInterval = value
        WindUI:Notify({ 
            Title = "间隔已调整", 
            Content = "射击间隔设置为: " .. value .. "秒",
            Duration = 2 
        })
    end
})

-- ========== WeaponTab 武器修改 ==========
WeaponTab:Button({
    Title = "无限子弹",
    Callback = function()
        local Shooter = require(game:GetService("ReplicatedStorage").Client.Wanted.Objects.ClientTool.Components.Guns.Shooter)
        local originalShoot = Shooter._shoot
        Shooter._shoot = function(self)
            self.ammo = 9999
            self.totalAmmo = 9999
            return originalShoot(self)
        end
        WindUI:Notify({ Title = "无限子弹", Content = "已启用", Duration = 2 })
    end
})

WeaponTab:Button({
    Title = "无后坐力",
    Callback = function()
        local Shooter = require(game:GetService("ReplicatedStorage").Client.Wanted.Objects.ClientTool.Components.Guns.Shooter)
        local originalShoot = Shooter._shoot
        Shooter._shoot = function(self)
            self.recoil = {firstShotKick = 0, climb = 0, spread = 0}
            return originalShoot(self)
        end
        WindUI:Notify({ Title = "无后坐力", Content = "已启用", Duration = 2 })
    end
})

WeaponTab:Button({
    Title = "无扩散",
    Callback = function()
        local Shooter = require(game:GetService("ReplicatedStorage").Client.Wanted.Objects.ClientTool.Components.Guns.Shooter)
        local originalShoot = Shooter._shoot
        Shooter._shoot = function(self)
            self.aim = {spreadAngle = 0, zeroing = 1000}
            return originalShoot(self)
        end
        WindUI:Notify({ Title = "无扩散", Content = "已启用", Duration = 2 })
    end
})

WeaponTab:Button({
    Title = "快速射击",
    Callback = function()
        local Shooter = require(game:GetService("ReplicatedStorage").Client.Wanted.Objects.ClientTool.Components.Guns.Shooter)
        local originalShoot = Shooter._shoot
        Shooter._shoot = function(self)
            self.tool.fireDebounce = 0
            self.tool.fireMode = "auto"
            return originalShoot(self)
        end
        WindUI:Notify({ Title = "快速射击", Content = "已启用", Duration = 2 })
    end
})

WeaponTab:Button({
    Title = "无装弹",
    Callback = function()
        local Shooter = require(game:GetService("ReplicatedStorage").Client.Wanted.Objects.ClientTool.Components.Guns.Shooter)
        local originalShoot = Shooter._shoot
        Shooter._shoot = function(self)
            self.ammoData = {reloadTime = 0, magSize = 9999}
            return originalShoot(self)
        end
        WindUI:Notify({ Title = "无装弹", Content = "已启用", Duration = 2 })
    end
})

-- ========== CombatTab 战斗功能 (Hitbox) ==========
local Section_Combat = CombatTab:Section({TextSize = 17,Title = "战斗功能",TextXAlignment = "Left"})
Section_Combat:Paragraph({
    Title = "注意",
    Desc = "范围固定 但是要记得演戏 小心被挂DC"
})

local HitboxHeadSize = 20
local HitboxDisabled = true
local HitboxTransparency = 0.7
local HitboxColor = Color3.fromRGB(255, 255, 255)
local HitboxRainbow = false
local HitboxTargetedUser = ""

local function GenerateRainbowColor()
    local HueValue = tick() % 5 / 5
    return Color3.fromHSV(HueValue, 1, 1)
end

local function IsTargetedUser(PlayerName)
    local TargetLower = HitboxTargetedUser:lower()
    return PlayerName:lower():find(TargetLower, 1, true) ~= nil
end

RunService.RenderStepped:Connect(function()
    pcall(function()
        if HitboxDisabled then
            for _, NextPlayer in pairs(Players:GetPlayers()) do
                if NextPlayer ~= LocalPlayer then
                    pcall(function()
                        local Character = NextPlayer.Character
                        local HRP = Character and Character:FindFirstChild("HumanoidRootPart")
                        if HRP then
                            HRP.Size = Vector3.new(2, 2, 1)
                            HRP.Transparency = 1
                            HRP.BrickColor = BrickColor.new("Medium stone grey")
                            HRP.Material = Enum.Material.Plastic
                            HRP.CanCollide = true
                        end
                    end)
                end
            end
        else
            for _, NextPlayer in pairs(Players:GetPlayers()) do
                if NextPlayer ~= LocalPlayer then
                    pcall(function()
                        local Character = NextPlayer.Character
                        local HRP = Character and Character:FindFirstChild("HumanoidRootPart")
                        if HRP then
                            if HitboxTargetedUser == "" or IsTargetedUser(NextPlayer.Name) then
                                HRP.Size = Vector3.new(HitboxHeadSize, HitboxHeadSize, HitboxHeadSize)
                                HRP.Transparency = HitboxTransparency
                                HRP.BrickColor = HitboxRainbow and BrickColor.new(GenerateRainbowColor()) or BrickColor.new(HitboxColor)
                                HRP.Material = Enum.Material.Neon
                                HRP.CanCollide = false
                            else
                                HRP.Size = Vector3.new(2, 2, 1)
                                HRP.Transparency = 1
                                HRP.BrickColor = BrickColor.new("Medium stone grey")
                                HRP.Material = Enum.Material.Plastic
                                HRP.CanCollide = true
                            end
                        end
                    end)
                end
            end
        end
    end)
end)

Section_Combat:Toggle({
    TextSize = 14,
    Title = "启用 Hitbox Extender",
    Callback = function(state)
        HitboxDisabled = not state
    end,
    Default = false
})

-- ========== PlayerTab 本地玩家 ==========
local Section_LocalPlayer = PlayerTab:Section({TextSize = 17, Title = "本地玩家", TextXAlignment = "Left"})

local InfiniteJumpEnabled = false
local DefaultJumpPower = 50

local function InfiniteJumpLogic()
    UserInputService.JumpRequest:Connect(function()
        if not InfiniteJumpEnabled then return end
        pcall(function()
            local char = LocalPlayer.Character
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                humanoid.JumpPower = DefaultJumpPower
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
    end)

    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(0.5)
        local char = LocalPlayer.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if humanoid and InfiniteJumpEnabled then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            humanoid.JumpPower = DefaultJumpPower
        end
    end)
end
task.spawn(InfiniteJumpLogic)

local speedMultiplier = 2
local isSpeedEnabled = false

local function updateSpeed()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    if isSpeedEnabled then
        humanoid.WalkSpeed = 16 * speedMultiplier
    else
        humanoid.WalkSpeed = 16
    end
end

LocalPlayer.CharacterAdded:Connect(function(char)
    char:WaitForChildOfClass("Humanoid")
    updateSpeed()
end)

Section_LocalPlayer:Toggle({
    TextSize = 14,
    Title = "启用无限跳",
    Callback = function(state)
        InfiniteJumpEnabled = state
        if state then
            pcall(function()
                local char = LocalPlayer.Character
                local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                if humanoid then 
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
                    humanoid.JumpPower = DefaultJumpPower
                end
            end)
        end
    end,
    Default = false
})

Section_LocalPlayer:Toggle({
    TextSize = 14,
    Title = "加速移动",
    Callback = function(state)
        isSpeedEnabled = state
        updateSpeed()
    end,
    Default = false
})

Section_LocalPlayer:Slider({
    TextSize = 14,
    Title = "速度倍数",
    Desc = "调整移动速度倍数",
    Icons = {
        From = "walk",
        To = "zap",
    },
    Step = 0.1,
    IsTooltip = true,
    Value = {
        Min = 1,
        Max = 5,
        Default = 2,
    },
    Callback = function(value)
        speedMultiplier = value
        if isSpeedEnabled then
            updateSpeed()
        end
    end
})

-- ========== MoneyTab 自动刷钱 ==========
local Section_AutoFarm = MoneyTab:Section({TextSize = 17,Title = "金钱",TextXAlignment = "Left"})

local GizmoFolder = workspace:FindFirstChild("Local") and workspace.Local:FindFirstChild("Gizmos") and workspace.Local.Gizmos:FindFirstChild("White") or nil

local PatrolPoints = {
    Vector3.new(-1137, 78, -1953),
    Vector3.new(-44, 63, -2083),
    Vector3.new(194, 60, -2884),
    Vector3.new(-412, 106, -1301),
    Vector3.new(-377, 410, -741),
    Vector3.new(-985, 380, -1145),
    Vector3.new(-854, 406, -1505)
}

local IsAutoFarmRunning = false
local AutoFarmThread = nil
local RootPart

local function GetBasePart(instance)
    if not instance then return nil end
    if instance:IsA("BasePart") then return instance end
    for _, descendant in ipairs(instance:GetDescendants()) do
        if descendant:IsA("BasePart") then return descendant end
    end
    return nil
end

local function IsValidTarget(instance)
    local typeAttr = instance:GetAttribute("gizmoType")
    return typeAttr == "ATM" or typeAttr == "Register"
end

local function FindClosestTarget()
    if not GizmoFolder or not RootPart then return nil end
    local minDistance = math.huge
    local closestPart = nil
    for _, item in ipairs(GizmoFolder:GetChildren()) do
        if IsValidTarget(item) then
            local part = GetBasePart(item)
            if part then
                local dist = (RootPart.Position - part.Position).Magnitude
                if dist < minDistance then
                    closestPart = part
                    minDistance = dist
                end
            end
        end
    end
    return closestPart
end

local function TeleportToTarget(target)
    if not RootPart then return end
    if typeof(target) ~= "Instance" then
        if typeof(target) == "Vector3" then RootPart.CFrame = CFrame.new(target) end
    else
        RootPart.CFrame = target.CFrame * CFrame.new(0, 1, 0)
    end
end

local function SpamInteract(duration)
    local start = tick()
    while tick() - start < duration do
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
        task.wait(0.01)
    end
end

local function ProcessCollection(targetPart)
    SpamInteract(1.5)
end

local function StartAutoFarm()
    if AutoFarmThread or not GizmoFolder or not RootPart then return end
    IsAutoFarmRunning = true
    AutoFarmThread = task.spawn(function()
        while IsAutoFarmRunning do
            pcall(function()
                local target = FindClosestTarget()
                if target then
                    TeleportToTarget(target)
                    ProcessCollection(target)
                else
                    TeleportToTarget(PatrolPoints[math.random(1, #PatrolPoints)])
                end
                task.wait(1.5)
            end)
        end
    end)
end

local function StopAutoFarm()
    IsAutoFarmRunning = false
    if AutoFarmThread then task.cancel(AutoFarmThread) AutoFarmThread = nil end
end

Section_AutoFarm:Toggle({
    TextSize = 14,
    Title = "自动全图刷钱",
    Callback = function(state)
        if state then StartAutoFarm() else StopAutoFarm() end
    end,
    Default = false
})

-- ========== TeleportTab 传送 ==========
local Section_Places = TeleportTab:Section({TextSize = 16,Title = "地点传送",TextXAlignment = "Left"})
local function TeleportTo(x, y, z)
    pcall(function()
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait(3)
        local hrp = character:WaitForChild("HumanoidRootPart", 3)
        hrp.CFrame = CFrame.new(x, y, z)
    end)
end

Section_Places:Button({TextSize = 14,Title = "枪店",Callback = function() TeleportTo(-180.77, 43.13, -2805.05) end})
Section_Places:Button({TextSize = 14,Title = "手机店",Callback = function() TeleportTo(-905.70, 42.98, -1563.35) end})
Section_Places:Button({TextSize = 14,Title = "黑市",Callback = function() TeleportTo(-2907.39, 37.58, 1652.25) end})

local Section_Crime = TeleportTab:Section({TextSize = 16,Title = "犯罪地点",TextXAlignment = "Left"})
Section_Crime:Button({TextSize = 14,Title = "犯罪窝点",Callback = function() TeleportTo(-7939.26, 21.74, 1073.52) end})
Section_Crime:Button({TextSize = 14,Title = "银行外",Callback = function() TeleportTo(-431.54, 40.09, -1400.08) end})
Section_Crime:Button({TextSize = 14,Title = "小银行",Callback = function() TeleportTo(-6852.36, 42.61, 965.86) end})
Section_Crime:Button({TextSize = 14,Title = "银行内部",Callback = function() TeleportTo(-399.28, 617.63, -1245.29) end})

local Section_Special = TeleportTab:Section({TextSize = 16,Title = "特殊地点",TextXAlignment = "Left"})
Section_Special:Button({TextSize = 14,Title = "警察局",Callback = function() TeleportTo(1583.31, 119.86, -716.63) end})
Section_Special:Button({TextSize = 14,Title = "烈焰要塞",Callback = function() TeleportTo(-1412.96, 181.18, 3054.46) end})

-- ========== WeaponsTab 武器获取 ==========
local Section_Weapons = WeaponsTab:Section({TextSize = 16,Title = "武器",TextXAlignment = "Left"})
Section_Weapons:Button({TextSize = 14,Title = "AWP狙击枪",Callback = function() TeleportTo(-822.97, 326.09, -506.58) end})
Section_Weapons:Button({TextSize = 14,Title = "UMP 45",Callback = function() TeleportTo(1665.20, 143.84, -644.01) end})
Section_Weapons:Button({TextSize = 14,Title = "贝内利 M1014",Callback = function() TeleportTo(1345.20, 141.52, -4809.11) end})
Section_Weapons:Button({TextSize = 14,Title = "M4",Callback = function() TeleportTo(-6342.43, 134.86, -4326.83) end})
Section_Weapons:Button({TextSize = 14,Title = "AK47",Callback = function() TeleportTo(-7835.20, 21.84, 1192.14) end})
Section_Weapons:Button({TextSize = 14,Title = "火箭筒",Callback = function() TeleportTo(-1392.87, 209.34, 3217.20) end})
Section_Weapons:Button({TextSize = 14,Title = "UZI",Callback = function() TeleportTo(-1348.55, 40.68, 2033.74) end})

-- ========== AboutTab 关于 ==========
AboutTab:Section({
    Title = "脚本信息",
    TextSize = 16,
    FontWeight = Enum.FontWeight.SemiBold,
})

AboutTab:Paragraph({
    Title = "YG/TNINE付费版",
    Desc = "主要功能：\n• 愤怒机器人(hook)\n• 武器修改\n• 自动刷钱\n• 传送功能\n• 通用功能\n\n注意：记得演戏"
})

AboutTab:Button({
    Title = "检查更新",
    Desc = "检查脚本是否有更新版本",
    Justify = "Center",
    Icon = "refresh-cw",
    Callback = function()
        WindUI:Notify({ 
            Title = "检查更新", 
            Content = "当前已是最新版本",
            Duration = 3 
        })
    end
})

AboutTab:Space({ Columns = 1 })

AboutTab:Button({
    Title = "反馈问题",
    Desc = "报告脚本使用中的问题",
    Justify = "Center",
    Icon = "alert-circle",
    Color = Color3.fromHex("#ff4830"),
    Callback = function()
        WindUI:Notify({ 
            Title = "反馈", 
            Content = "开发者qq3248788807:",
            Duration = 3 
        })
    end
})

-- ========== 窗口关闭处理 ==========
Window:OnClose(function()
    if rainbowBorderAnimation then
        rainbowBorderAnimation:Disconnect()
        rainbowBorderAnimation = nil
    end
end)

Window:OnDestroy(function()
    if rainbowBorderAnimation then
        rainbowBorderAnimation:Disconnect()
        rainbowBorderAnimation = nil
    end
    for _, animation in pairs(fontColorAnimations or {}) do
        animation:Disconnect()
    end
    fontColorAnimations = {}
end)

WindUI:Notify({ 
    Title = "YG/TNINE付费版", 
    Content = "已全部加载",
    Duration = 5,
    Icon = "check-circle"
})

local MyButton = LeftGroupBox:AddButton({
    Text = '俄亥俄州',---服务器名称
    Func = function()
    local originalUI = Library---这个不用动
-----↓↓↓↓↓源码放置↓↓↓↓↓↓

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local Character = LocalPlayer.Character
local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
local HumanoidRootPart = Character and Character:FindFirstChild("HumanoidRootPart")

LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    HumanoidRootPart = char:WaitForChild("HumanoidRootPart")
    Humanoid = char:WaitForChild("Humanoid")
end)

local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/454244513/WindUIFix/refs/heads/main/main.lua"))()
local Window = WindUI:CreateWindow({
    Title = "YG SCRIPT",
    Author = "作者byYG",
    Folder = "HackerHub",
    Size = UDim2.fromOffset(200, 395),
    Transparent = true,
    Theme = "Dark",
    User = {
        Enabled = false,
        Callback = function() print("clicked") end,
        Anonymous = false
    },
    SideBarWidth = 135,
    ScrollBarEnabled = true,
    Background = "https://raw.githubusercontent.com/dohyynd/YG-THINE/refs/heads/main/IMG_20260216_112951_671.jpg",
    BackgroundImageTransparency = 0.65,
})

Window:EditOpenButton({
    Title = "paid user",
    Icon = "https://raw.githubusercontent.com/dohyynd/YG-THINE/refs/heads/main/IMG_20260216_112951_671.jpg",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2.35,
    Color = ColorSequence.new(
        Color3.fromHex("3C1361"),
        Color3.fromHex("6A0DAD")
    ),
    Draggable = true,
})

local Tabs = {}

do
    Tabs.BladeSection = Window:Section({
        Title = "杀戮光环",
        Opened = true,
    })
    
    Tabs.MoneySection = Window:Section({
        Title = "金钱",
        Opened = true,
    })
    
    Tabs.ProSection = Window:Section({
        Title = "保护",
        Opened = true,
    })
    
    Tabs.ConfigSection = Window:Section({
        Title = "其他",
        Opened = true,
    })
    
    Tabs.BladeTab = Tabs.BladeSection:Tab({ Title = "杀戮光环", Icon = "crown" })
    Tabs.HitTab = Tabs.BladeSection:Tab({ Title = "打击", Icon = "crown" })
    Tabs.MoneyTab = Tabs.MoneySection:Tab({ Title = "金钱", Icon = "crown" })
    Tabs.BypassTab = Tabs.MoneySection:Tab({ Title = "绕过", Icon = "crown" })
    Tabs.ProTab = Tabs.ProSection:Tab({ Title = "保护", Icon = "crown" })
    Tabs.PlayerTab = Tabs.ConfigSection:Tab({ Title = "主要", Icon = "crown" })
end

Window:SelectTab(1)

_G.HealthThreshold = 0
_G.BladeAuraEnabled = false

Tabs.BladeTab:Paragraph({
    Title = "公共",
    Desc = "作者: YGPRO",
    Image = "sword",
    ImageSize = 42,
})

local plrs = game:GetService("Players")
local rs = game:GetService("ReplicatedStorage")
local runService = game:GetService("RunService")
local lp = plrs.LocalPlayer

local dvv = require(rs.devv)
local sig = dvv.load("Signal")
local guid = dvv.load("GUID")
local inv = dvv.load("v3item").inventory

local dartOn = false
local dartTeleportTargets = false
local dartCachedHitId = nil
local dartCurrentTarget = nil
local dartHeartConnections = {}
local dartNinjaStarBuyThread = nil

getgenv().TrailColors = {
    StartColor = Color3.fromRGB(200, 180, 255),
    EndColor = Color3.fromRGB(140, 100, 220),
    MiddleColor1 = Color3.fromRGB(180, 150, 240),
    MiddleColor2 = Color3.fromRGB(160, 130, 230)
}

local function createBeautifulTrail(origin, targetPos)
    local trailContainer = Instance.new("Folder")
    trailContainer.Name = "MagicTrail"
    trailContainer.Parent = Workspace
    
    local midPoint = (origin + targetPos) / 2
    local direction = (targetPos - origin).Unit
    local perpendicular = Vector3.new(-direction.Z, direction.Y, direction.X) * 3
    local controlPoint = midPoint + perpendicular + Vector3.new(0, math.random(-3, 3), 0)
    
    local function createBezierCurve(p0, p1, p2, t)
        return (1 - t)^2 * p0 + 2 * (1 - t) * t * p1 + t^2 * p2
    end
    
    local curvePoints = {}
    local numSegments = 20
    
    for i = 0, numSegments do
        local t = i / numSegments
        local point = createBezierCurve(origin, controlPoint, targetPos, t)
        table.insert(curvePoints, point)
    end
    
    for i = 1, #curvePoints - 1 do
        local startPoint = curvePoints[i]
        local endPoint = curvePoints[i + 1]
        local distance = (endPoint - startPoint).Magnitude
        
        local beamPart = Instance.new("Part")
        beamPart.Size = Vector3.new(0.15, 0.15, distance)
        beamPart.Anchored = true
        beamPart.CanCollide = false
        beamPart.Material = Enum.Material.Neon
        beamPart.Transparency = 0.3
        beamPart.CFrame = CFrame.new(startPoint, endPoint) * CFrame.new(0, 0, -distance / 2)
        beamPart.Parent = trailContainer
        
        local t = i / (#curvePoints - 1)
        local color
        if t < 0.3 then
            color = getgenv().TrailColors.StartColor or Color3.fromRGB(200, 180, 255)
        elseif t < 0.6 then
            color = getgenv().TrailColors.MiddleColor1 or Color3.fromRGB(180, 150, 240)
        elseif t < 0.9 then
            color = getgenv().TrailColors.MiddleColor2 or Color3.fromRGB(160, 130, 230)
        else
            color = getgenv().TrailColors.EndColor or Color3.fromRGB(140, 100, 220)
        end
        
        beamPart.Color = color
        
        local pointLight = Instance.new("PointLight")
        pointLight.Brightness = 5
        pointLight.Range = 3
        pointLight.Color = color
        pointLight.Parent = beamPart
        
        local particles = Instance.new("ParticleEmitter")
        particles.Size = NumberSequence.new(0.1, 0.3)
        particles.Transparency = NumberSequence.new(0.3, 0.8)
        particles.Lifetime = NumberRange.new(0.5, 1)
        particles.Rate = 50
        particles.Speed = NumberRange.new(1, 2)
        particles.VelocitySpread = 180
        particles.Color = ColorSequence.new(color)
        particles.Parent = beamPart
    end
    
    task.delay(1.5, function()
        if trailContainer and trailContainer.Parent then
            trailContainer:Destroy()
        end
    end)
    
    return trailContainer
end

local function dartCleanupConnections()
    for _, conn in ipairs(dartHeartConnections) do
        if conn then conn:Disconnect() end
    end
    dartHeartConnections = {}
end

local function dartEquipNinjaStar()
    local itm = inv.getItems and inv.getItems() or inv.items or {}
    for _, v in next, itm do
        if v.name == "Ninja Star" then
            sig.FireServer("equip", v.guid)
            return v.guid
        end
    end
    return nil
end

local function dartInitThrow()
    local sg = dartEquipNinjaStar()
    if not sg then return end
    
    local c = lp.Character
    if not c then return end
    
    local rh = c:FindFirstChild("RightHand")
    local hrp = c:FindFirstChild("HumanoidRootPart")
    if not rh or not hrp then return end
    
    local mp = rh.Position + Vector3.new(0, 0.5, 0)
    local tp = mp + Vector3.new(50, 0, 0)
    local vel = (tp - mp).Unit * 150
    
    createBeautifulTrail(mp, tp)
    
    local ok, r1, hid = pcall(function()
        return sig.InvokeServer("throwSticky", guid(), "Ninja Star", sg, vel, tp)
    end)
    
    if ok and r1 and hid then
        dartCachedHitId = hid
    end
end

local function dartHasShield(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return false end
    
    local char = targetPlayer.Character
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    for _, desc in pairs(char:GetDescendants()) do
        if desc:IsA("ForceField") then
            return true
        end
    end
    
    return false
end

local function dartFindValidTarget()
    local closest = nil
    local minDist = math.huge
    local myPos = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character.HumanoidRootPart.Position
    
    if not myPos then return nil end
    
    for _, player in ipairs(plrs:GetPlayers()) do
        if player ~= lp and player.Character then
            local char = player.Character
            local humanoid = char:FindFirstChild("Humanoid")
            local head = char:FindFirstChild("Head")
            local hrp = char:FindFirstChild("HumanoidRootPart")
            
            if humanoid and head and hrp and humanoid.Health > 0 and not dartHasShield(player) then
                local dist = (hrp.Position - myPos).Magnitude
                if dist < minDist and dist <= 50 then
                    minDist = dist
                    closest = {player = player, head = head}
                end
            end
        end
    end
    return closest
end

local function dartRapidThrowAttack()
    if not dartOn or not dartCachedHitId then return end
    
    local targetData = dartFindValidTarget()
    if not targetData then return end
    
    local head = targetData.head 
    local tp = head.Position
    local wcf = CFrame.new(tp, tp + Vector3.new(0, 1, 0))
    local rcf = CFrame.new(0, 0, 0)
    
    local c = lp.Character
    if c and c:FindFirstChild("RightHand") then
        local rh = c:FindFirstChild("RightHand")
        createBeautifulTrail(rh.Position, tp)
    end
    
    for i = 1, 15 do 
        sig.InvokeServer("hitSticky", dartCachedHitId, head, rcf, wcf)
    end
end

local function dartFindNextTeleportTarget()
    local players = plrs:GetPlayers()
    
    for _, player in ipairs(players) do
        if player ~= lp and player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 and not dartHasShield(player) then
                return player
            end
        end
    end
    return nil
end

local function dartFastTeleport()
    if not dartTeleportTargets or not dartOn then return end
    
    if not dartCurrentTarget then
        dartCurrentTarget = dartFindNextTeleportTarget()
        if not dartCurrentTarget then return end
    end
    
    if not dartCurrentTarget.Character then
        dartCurrentTarget = dartFindNextTeleportTarget()
        if not dartCurrentTarget then return end
    end
    
    local humanoid = dartCurrentTarget.Character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 or dartHasShield(dartCurrentTarget) then
        dartCurrentTarget = dartFindNextTeleportTarget()
        if not dartCurrentTarget then return end
    end
    
    local char = lp.Character
    if not char or not char.PrimaryPart then return end
    
    local targetChar = dartCurrentTarget.Character
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end
    
    char.PrimaryPart.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 1.5)
end

Tabs.BladeTab:Toggle({
     = "NinjaStar aura",
    Default = false,
    Callback = function(state)
        dartOn = state
        dartCleanupConnections()
        
        if state then
            dartEquipNinjaStar()
            task.wait(0.1)
            dartInitThrow()
            
            local fastAttackConn = runService.RenderStepped:Connect(function()
                if not dartOn then return end
                dartRapidThrowAttack()
            end)
            table.insert(dartHeartConnections, fastAttackConn)
        end
    end
})

Tabs.BladeTab:Toggle({
    Title = "传送攻击(需开启忍者星光环)",
    Default = false,
    Callback = function(state)
        dartTeleportTargets = state
        
        if state and dartOn then
            local fastTeleportConn = runService.RenderStepped:Connect(function()
                dartFastTeleport()
            end)
            table.insert(dartHeartConnections, fastTeleportConn)
            
            WindUI:Notify({
                Title = "传送攻击",
                Content = "open",
                Duration = 2,
                Icon = "zap"
            })
        elseif state then
            local checkConnection
            checkConnection = runService.Heartbeat:Connect(function()
                if dartOn then
                    checkConnection:Disconnect()
                    local fastTeleportConn = runService.RenderStepped:Connect(function()
                        dartFastTeleport()
                    end)
                    table.insert(dartHeartConnections, fastTeleportConn)
                elseif not dartTeleportTargets then
                    checkConnection:Disconnect()
                end
            end)
        end
    end
})

Tabs.BladeTab:Toggle({
    Title = "购买忍者星",
    Default = false,
    Callback = function(state)
        if dartNinjaStarBuyThread then
            dartNinjaStarBuyThread:Disconnect()
            dartNinjaStarBuyThread = nil
        end
        if state then
            local heartbeat = game:GetService("RunService").Heartbeat
            dartNinjaStarBuyThread = heartbeat:Connect(function()
                sig.InvokeServer("attemptPurchase", "Ninja Star")
                for _, v in next, inv.items do
                    if v.name == "Ninja Star" then
                        break
                    end
                end
            end)
        end
    end
})

local originalOnDestroy = Window.OnDestroy or function() end
Window.OnDestroy = function(...)
    originalOnDestroy(...)
    dartCleanupConnections()
    if dartNinjaStarBuyThread then
        dartNinjaStarBuyThread:Disconnect()
        dartNinjaStarBuyThread = nil
    end
end

Tabs.BladeTab:Toggle({
    Title = "香蕉光环",
    Default = false,
    Callback = function(state)
        _G.AuraEnabled = state
        if not state then _G.TargetId = nil end
    end
})

Tabs.BladeTab:Toggle({
    Title = "战斧光环",
    Default = false,
    Callback = function(state)
        _G.BladeAuraEnabled = state
    end
})

Tabs.BladeTab:Slider({
    Title = "无伤血量阔值",
    Value = {
        Min = 0,
        Max = 25,
        Default = 0,
    },
    Callback = function(value)
        _G.HealthThreshold = value
    end
})

local Signal = require(game:GetService("ReplicatedStorage").devv).load("Signal")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local b1 = require(game:GetService('ReplicatedStorage').devv).load('v3item').inventory.items
local autokill = false
local autostomp = false
local grabplay = false
local autoFists = false

local function equipFists()
    for i, v in next, b1 do 
        if v.name == 'Fists' then 
            Signal.FireServer("equip", v.guid)
            break
        end
    end
end

local function killAura()
    local character = localPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local targetChar = player.Character
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                local distance = (rootPart.Position - targetHRP.Position).Magnitude
                if distance <= 35 then
                    local uid = player.UserId
                    Signal.FireServer("meleeAttackHit", "player", { 
                        meleeType = "meleemegapunch", 
                        hitPlayerId = uid 
                    })
                end
            end
        end
    end
end

local function stompAura()
    local character = localPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local targetChar = player.Character
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            local targetHumanoid = targetChar:FindFirstChild("Humanoid")
            if targetHRP and targetHumanoid and targetHumanoid.Health < 20 then
                local distance = (rootPart.Position - targetHRP.Position).Magnitude
                if distance <= 40 then
                    Signal.FireServer("finish", player)
                end
            end
        end
    end
end

local function grabAura()
    local character = localPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local targetChar = player.Character
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            local targetHumanoid = targetChar:FindFirstChild("Humanoid")
            if targetHRP and targetHumanoid and targetHumanoid.Health < 20 then
                local distance = (rootPart.Position - targetHRP.Position).Magnitude
                if distance <= 40 then
                    Signal.FireServer("grabPlayer", player)
                end
            end
        end
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if autokill then
        killAura()
    end
    
    if autostomp then
        stompAura()
    end
    
    if grabplay then
        grabAura()
    end
    
    if autoFists then
        equipFists()
    end
end)

Tabs.HitTab:Toggle({
    Title = "自动拳头",
    Value = false,
    Callback = function(state) 
        autoFists = state
    end
})

Tabs.HitTab:Toggle({
    Title = "杀戮光环",
    Value = false,
    Callback = function(state) 
        autokill = state
    end
})

Tabs.HitTab:Toggle({
    Title = "践踏光环",
    Value = false,
    Callback = function(state) 
        autostomp = state
    end
})

Tabs.HitTab:Toggle({
    Title = "抓取光环",
    Value = false,
    Callback = function(state) 
        grabplay = state
    end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local localPlayer = Players.LocalPlayer

local autoKillSettings = {
    isEnabled = false,
    range = 100,
    showBeams = true
}

local activeBeams = {}
local lastShootTime = 0
local lastReloadTime = 0
local shootInterval = 0.05
local reloadInterval = 3 

local function hasShield(character)
    if not character then return false end
    local shield = character:FindFirstChild("Shield") or character:FindFirstChild("ForceField")
    return shield ~= nil
end

local function isPlayerAlive(character)
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health > 0
end

local function purchaseAmmo(weaponName)
    pcall(function()
        require(game:GetService("ReplicatedStorage").devv).load("Signal").InvokeServer("attemptPurchaseAmmo", weaponName)
    end)
end

local function createBeamEffect(startPos, endPos)
    if not autoKillSettings.showBeams then return end
    
    local beam = Instance.new("Part")
    beam.Name = "KillBeam"
    beam.Anchored = true
    beam.CanCollide = false
    beam.CastShadow = false
    beam.Transparency = 0.2
    beam.Material = Enum.Material.Neon
    beam.Color = Color3.fromRGB(255, 0, 0)
    
    local direction = (endPos - startPos)
    local distance = direction.Magnitude
    
    beam.Size = Vector3.new(0.3, 0.3, distance)
    beam.CFrame = CFrame.lookAt(startPos, endPos) * CFrame.new(0, 0, -distance/2)
    
    local startGlow = Instance.new("Part")
    startGlow.Name = "StartGlow"
    startGlow.Anchored = true
    startGlow.CanCollide = false
    startGlow.Shape = Enum.PartType.Ball
    startGlow.Size = Vector3.new(1.2, 1.2, 1.2)
    startGlow.Color = Color3.fromRGB(255, 50, 50)
    startGlow.Material = Enum.Material.Neon
    startGlow.Transparency = 0.1
    startGlow.Position = startPos
    startGlow.Parent = beam
    
    local endGlow = startGlow:Clone()
    endGlow.Name = "EndGlow"
    endGlow.Position = endPos
    endGlow.Parent = beam
    
    local innerBeam = Instance.new("Part")
    innerBeam.Name = "InnerBeam"
    innerBeam.Anchored = true
    innerBeam.CanCollide = false
    innerBeam.Transparency = 0.1
    innerBeam.Material = Enum.Material.Neon
    innerBeam.Color = Color3.fromRGB(255, 100, 100)
    innerBeam.Size = Vector3.new(0.2, 0.2, distance)
    innerBeam.CFrame = beam.CFrame
    innerBeam.Parent = beam
    
    local pointLight = Instance.new("PointLight")
    pointLight.Brightness = 6
    pointLight.Range = 12
    pointLight.Color = Color3.fromRGB(255, 0, 0)
    pointLight.Parent = startGlow
    
    local pointLight2 = pointLight:Clone()
    pointLight2.Parent = endGlow
    
    beam.Parent = Workspace
    
    local beamInfo = {
        beam = beam,
        startTime = tick(),
        endTime = tick() + 0.3
    }
    
    table.insert(activeBeams, beamInfo)
    
    delay(0.3, function()
        if beam and beam.Parent then
            local fadeTween = TweenService:Create(beam, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 1})
            fadeTween:Play()
            fadeTween.Completed:Connect(function()
                if beam and beam.Parent then
                    beam:Destroy()
                end
            end)
        end
    end)
    
    return beam
end

local function updateBeams()
    local currentTime = tick()
    local beamsToRemove = {}
    
    for i, beamInfo in ipairs(activeBeams) do
        if currentTime >= beamInfo.endTime then
            table.insert(beamsToRemove, i)
        end
    end
    
    for i = #beamsToRemove, 1, -1 do
        local index = beamsToRemove[i]
        local beamInfo = activeBeams[index]
        if beamInfo.beam and beamInfo.beam.Parent then
            beamInfo.beam:Destroy()
        end
        table.remove(activeBeams, index)
    end
end

local function isInRange(position1, position2)
    return (position1 - position2).Magnitude <= autoKillSettings.range
end

local function getShootingInfo()
    local success, reloadFunc = pcall(function()
        return getupvalue(require(game:GetService("ReplicatedStorage").devv.client.Objects.v3item.bin.Gun.modules.controller.modules.reload), 2)
    end)
    
    if not success then return nil end
    
    local success2, t = pcall(function()
        return getupvalue(require(game:GetService("ReplicatedStorage").devv.client.Objects.v3item.bin.Gun.modules.controller.modules.shoot), 1)
    end)
    
    if success2 and t and t.item then
        return {
            reload = reloadFunc,
            ammo = t.item.ammoManager,
            gunid = t.item.guid,
            firemode = t.item.firemode,
            weaponName = t.item.name
        }
    end
    return nil
end

local function autoReload(shootingInfo, forceReload)
    if not shootingInfo then return end
    
    local currentTime = tick()
    
    if forceReload or (currentTime - lastReloadTime >= reloadInterval) then
        local reloadEvent = ReplicatedStorage.devv.remoteStorage:FindFirstChild("reload")
        if reloadEvent and shootingInfo.reload then
            purchaseAmmo(shootingInfo.weaponName)
            firesignal(reloadEvent.OnClientEvent, shootingInfo.gunid, 0, shootingInfo.ammo.ammoOut)
            shootingInfo.reload()
            lastReloadTime = currentTime
        end
    end
end

local function getAlivePlayersInRange()
    local localCharacter = localPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRootPart then return {} end
    
    local targets = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and humanoid.Health > 0 and humanoidRootPart and not hasShield(character) then
                if isInRange(localRootPart.Position, humanoidRootPart.Position) then
                    table.insert(targets, {
                        player = player,
                        character = character,
                        rootPart = humanoidRootPart
                    })
                end
            end
        end
    end
    
    return targets
end

local function shootAtPlayer(targetData, shootingInfo, rightArm)
    if not shootingInfo or not targetData or not rightArm then return false end
    
    if shootingInfo.ammo.ammo <= 0 then
        autoReload(shootingInfo, true)
        return false
    end
    
    local targetParts = {
        targetData.character:FindFirstChild("Head"),
        targetData.character:FindFirstChild("UpperTorso"),
        targetData.character:FindFirstChild("HumanoidRootPart")
    }
    
    local Event1 = ReplicatedStorage.devv.remoteStorage:FindFirstChild("replicateProjectiles")
    local Event2 = ReplicatedStorage.devv.remoteStorage:FindFirstChild("projectileHit")
    
    if not Event1 or not Event2 then return false end
    
    for _, targetPart in ipairs(targetParts) do
        if targetPart and shootingInfo.ammo.ammo > 0 and isPlayerAlive(targetData.character) then
            local startPos = rightArm.Position
            createBeamEffect(startPos, targetPart.Position)
            
            Event1:FireServer(shootingInfo.gunid, {{"TrackingBullet", targetPart.CFrame}}, shootingInfo.firemode)
            Event2:FireServer("TrackingBullet", "player", {
                hitPart = targetPart,
                hitPlayerId = targetData.player.UserId,
                hitSize = targetPart.Size,
                pos = targetPart.Position
            })
            shootingInfo.ammo.ammo = shootingInfo.ammo.ammo - 1
            return true
        end
    end
    
    return false
end

local function autoKillAll()
    if not autoKillSettings.isEnabled then return end
    
    local currentTime = tick()
    if currentTime - lastShootTime < shootInterval then return end
    
    local targets = getAlivePlayersInRange()
    if #targets == 0 then return end
    
    local shootingInfo = getShootingInfo()
    if not shootingInfo then
        autoReload(shootingInfo, true)
        return
    end
    
    local localCharacter = localPlayer.Character
    if not localCharacter then return end
    
    local rightArm = localCharacter:FindFirstChild("RightHand")
    if not rightArm then return end
    
    for _, targetData in ipairs(targets) do
        if isPlayerAlive(targetData.character) and not hasShield(targetData.character) then
            if shootingInfo.ammo.ammo <= 0 then
                autoReload(shootingInfo, true)
                shootingInfo = getShootingInfo()
                if not shootingInfo then break end
            end
            
            local shotFired = shootAtPlayer(targetData, shootingInfo, rightArm)
            if shotFired then
                lastShootTime = currentTime
            end
        end
    end
end

local autoKillConnection
local beamUpdateConnection

local function toggleAutoKill(isEnabled)
    autoKillSettings.isEnabled = isEnabled
    if isEnabled then
        if autoKillConnection then
            autoKillConnection:Disconnect()
        end
        autoKillConnection = RunService.Heartbeat:Connect(autoKillAll)
        
        if beamUpdateConnection then
            beamUpdateConnection:Disconnect()
        end
        beamUpdateConnection = RunService.Heartbeat:Connect(updateBeams)
        
        lastReloadTime = tick()
    else
        if autoKillConnection then
            autoKillConnection:Disconnect()
            autoKillConnection = nil
        end
        
        if beamUpdateConnection then
            beamUpdateConnection:Disconnect()
            beamUpdateConnection = nil
        end
        
        for _, beamInfo in ipairs(activeBeams) do
            if beamInfo.beam and beamInfo.beam.Parent then
                beamInfo.beam:Destroy()
            end
        end
        activeBeams = {}
    end
end

Tabs.HitTab:Toggle({
    Title = "自瞄抢",
    Value = false,
    Callback = toggleAutoKill
})

Tabs.HitTab:Slider({
    Title = "攻击范围",
    Value = {
        Min = 1,
        Max = 600,
        Default = 100,
    },
    Callback = function(Value)
        autoKillSettings.range = Value
    end
})

Tabs.HitTab:Toggle({
    Title = "显示弹道",
    Default = true,
    Callback = function(v)
        autoKillSettings.showBeams = v
    end
})

local devv = ReplicatedStorage:WaitForChild("devv")
local load = require(devv).load
local FireServer = load("Signal").FireServer
local InvokeServer = load("Signal").InvokeServer
local GUID = load("GUID")
local Raycast = load("Raycast")
local v3item = load("v3item")
local inventory = v3item.inventory

_G.TargetId = nil
local lastAttack = 0
local lastAmmo = 0

local function getTarget()
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local target, dist = nil, 150
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local tRoot = plr.Character:FindFirstChild("HumanoidRootPart")
            local tHum = plr.Character:FindFirstChildOfClass("Humanoid")
            if tRoot and tHum and tHum.Health >= _G.HealthThreshold then
                local d = (root.Position - tRoot.Position).Magnitude
                if d < dist then
                    dist = d
                    target = plr
                end
            end
        end
    end
    return target
end

local function hackthrow(plr, itemname, itemguid, velocity, epos)
    if plr ~= LocalPlayer then
        return
    end
    task.spawn(function()
        local throwGuid = GUID()
        local char = plr.Character
        if char and char:FindFirstChild("RightHand") then
            local hand = char:FindFirstChild("RightHand")
            createBeautifulTrail(hand.Position, epos)
        end
        
        local success, stickyId = InvokeServer("throwSticky", throwGuid, itemname, itemguid, velocity, epos)
        if not success then
            return
        end
        local dummyPart = Instance.new("Part")
        dummyPart.Size = Vector3.new(2, 2, 2)
        dummyPart.Position = epos
        dummyPart.Anchored = true
        dummyPart.Transparency = 1
        dummyPart.CanCollide = true
        dummyPart.Parent = workspace
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = { plr.Character, workspace.Game.Local, workspace.Game.Drones }
        local dist = (epos - plr.Character.Head.Position).Magnitude
        local rayResult = workspace:Raycast(
            plr.Character.Head.Position,
            (epos - plr.Character.Head.Position).Unit * (dist + 5),
            rayParams
        )
        if rayResult and rayResult.Instance then
            local hitPart = rayResult.Instance
            local relativeHitCFrame = hitPart.CFrame:ToObjectSpace(CFrame.new(rayResult.Position, rayResult.Position + rayResult.Normal))
            local stickyCFrame = CFrame.new(rayResult.Position)
            if dummyPart.Parent then
                dummyPart:Destroy()
            end
            _G.throwargs = {
                "hitSticky",
                stickyId or throwGuid,
                hitPart,
                relativeHitCFrame,
                stickyCFrame,
            }
            InvokeServer("hitSticky", stickyId or throwGuid, hitPart, relativeHitCFrame, stickyCFrame)
        else
            if dummyPart.Parent then
                dummyPart:Destroy()
            end
        end
    end)
end

local function getinventory()
    return inventory.items
end

local function finditem(string)
    for guid, data in next, getinventory() do
        if data.name == string or data.type == string or data.subtype == string then
            return data
        end
    end
end

local function executebladekill(plr, head)
    local item = finditem("Tomahawk")
    if item then
        FireServer("equip", item.guid)

        if not _G.throwargs then
            local char = LocalPlayer.Character
            if not char then return end
            local hand = char:FindFirstChild("RightHand")
            if not hand then return end
            
            local spos = hand.Position
            local epos = head.Position
            local velocity = (epos - spos).Unit * ((spos - epos).Magnitude * 15)
            createBeautifulTrail(spos, epos)
            task.spawn(InvokeServer, "attemptPurchaseAmmo", "Tomahawk")
            hackthrow(LocalPlayer, "Tomahawk", item.guid, velocity, epos)
        end

        if _G.throwargs then
            _G.throwargs[3] = head
            task.spawn(InvokeServer, unpack(_G.throwargs))
        end
    else
        task.spawn(InvokeServer, "attemptPurchase", "Tomahawk")
    end
end

local function attack(plr)
    local now = tick()
    if now - lastAttack < 0.03 then return end
    lastAttack = now

    local tChar = plr.Character
    local tRoot = tChar and tChar:FindFirstChild("HumanoidRootPart")
    local tHum = tChar and tChar:FindFirstChildOfClass("Humanoid")
    if not tRoot or not tHum or tHum.Health < 15 then return end

    task.spawn(function()
        local items = inventory.items or {}
        local banana = nil
        for _, v in next, items do
            if v.name == "Banana Peel" then
                banana = v
                break
            end
        end

        if not banana then
            pcall(function() InvokeServer("attemptPurchase", "Banana Peel") end)
            return
        end

        FireServer("equip", banana.guid)

        local pred = tRoot.AssemblyLinearVelocity * 0.2
        local cf = tRoot.CFrame * CFrame.new(0, -1, 0) + pred
        local rcf = tRoot.CFrame:ToObjectSpace(cf)

        local char = LocalPlayer.Character
        if char and char:FindFirstChild("RightHand") then
            local hand = char:FindFirstChild("RightHand")
            createBeautifulTrail(hand.Position, cf.Position)
        end

        if not _G.TargetId then
            local ok, _, id = pcall(function()
                return InvokeServer("throwSticky", GUID(), "Banana Peel", banana.guid, Vector3.new(0, 100, 0), cf.Position)
            end)
            if ok and id then _G.TargetId = id end
        end

        if _G.TargetId then
            pcall(function()
                InvokeServer("hitSticky", _G.TargetId, tRoot, rcf, cf)
            end)
        end
    end)
end

RunService.Heartbeat:Connect(function()
    if _G.AuraEnabled then
        local target = getTarget()
        if target then
            attack(target)
        end
        
        if tick() - lastAmmo > 0.5 then
            lastAmmo = tick()
            task.spawn(function()
                pcall(function() InvokeServer("attemptPurchaseAmmo", "Banana Peel") end)
            end)
        end
    end
    
    if _G.BladeAuraEnabled and HumanoidRootPart then
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr == LocalPlayer then
                continue
            end
            local char = plr.Character
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            local head = char and char:FindFirstChild("Head")
            if head then
                local dist = (HumanoidRootPart.Position - head.Position).Magnitude
                if hum and hum.Health > 0 and dist < 190 then
                    executebladekill(plr, head)
                    break
                end
            end
        end
    end
end)

local autobank = false
local bankTeleportCFrame = CFrame.new(1112.12671, 10.1856346, -324.815613)  
local originalPosition = nil  

local function robBankAndReturn()
    if not autobank then return end
    
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    originalPosition = rootPart.CFrame
    
    rootPart.CFrame = bankTeleportCFrame
    task.wait(0.1)
    
    local Signal = require(game:GetService("ReplicatedStorage").devv).load("Signal")
    
    local waitTime = 0.1
    local maxWait = 10.0
    
    local startTime = tick()
    while autobank and (tick() - startTime) < maxWait do
        Signal.FireServer("stealBankCash")
        task.wait(waitTime)
    end
    
    if autobank and originalPosition then
        rootPart.CFrame = originalPosition
        task.wait(0.1)
    end
    
    originalPosition = nil
end

local bankThread = nil

local function startBankRobberyLoop()
    if bankThread then return end
    
    bankThread = task.spawn(function()
        while autobank do
            robBankAndReturn()
            task.wait(0.5)
        end
        bankThread = nil
    end)
end

local function stopBankRobberyLoop()
    if bankThread then
        task.cancel(bankThread)
        bankThread = nil
    end
end

Tabs.MoneyTab:Toggle({
    Title = "自动抢银行",
    Value = false,
    Callback = function(state) 
        autobank = state
        if autobank then
            startBankRobberyLoop()
        else
            stopBankRobberyLoop()
        end
    end
})
Tabs.MoneyTab:Toggle({
    Title = "自动ATM刷钱",
    Default = false,
    Callback = function(Value)
        autoATMCashCombo = Value
        
        if autoATMCashCombo then
            local function collectCash()
                local player = game:GetService("Players").LocalPlayer
                local cashSize = Vector3.new(2, 0.2499999850988388, 1)
                
                for _, part in ipairs(workspace.Game.Entities.CashBundle:GetDescendants()) do
                    if part:IsA("BasePart") and part.Size == cashSize then
                        player.Character.HumanoidRootPart.CFrame = part.CFrame
                        task.wait()
                    end
                end
            end
            
            coroutine.wrap(function()
                while autoATMCashCombo and task.wait() do
                   
                    local ATMsFolder = workspace:FindFirstChild("ATMs")
                    local localPlayer = game:GetService("Players").LocalPlayer
                    local hasActiveATM = false
                    
                    if ATMsFolder and localPlayer.Character then
                        for _, atm in ipairs(ATMsFolder:GetChildren()) do
                            if atm:IsA("Model") then
                                local hp = atm:GetAttribute("health")
                                if hp ~= 0 then
                                    hasActiveATM = true
                                    for _, part in ipairs(atm:GetChildren()) do
                                        if part.Name == "Main" and part:IsA("BasePart") then
                                            localPlayer.Character.HumanoidRootPart.CFrame = part.CFrame
                                            task.wait()
                                            atm:SetAttribute("health", 0)
                                            break
                                        end
                                    end
                                    task.wait()
                                end
                            end
                        end
                    end
                    
                    if hasActiveATM then
                        task.wait(0.1)
                    else
                        collectCash()
                        
                 
                        task.wait()
                    end
                end
            end)()
        end
    end
})

local autoCraftEnabled = false
local autoClaimEnabled = false
local craftConnection

local Signal = require(game:GetService("ReplicatedStorage").devv).load("Signal")

local function performCrafting()
    if autoCraftEnabled then
        Signal.InvokeServer("beginCraft", 'RollieCraft')
    end
    
    if autoClaimEnabled then
        Signal.InvokeServer("claimCraft", 'RollieCraft')
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if autoCraftEnabled or autoClaimEnabled then
        performCrafting()
    end
end)

Tabs.BypassTab:Button({
    Title = "绕过手机营销商",
    Callback = function()
local pjyd pjyd=hookmetamethod(game,"__namecall",function(self,...)local args={...}local method=getnamecallmethod()if method=="InvokeServer" and args[2]==true then args[2]=false return pjyd(self,unpack(args))end return pjyd(self,...)end)--
game:GetService("Players").LocalPlayer:SetAttribute("mobileDealer",true)
local ReplicatedStorage=game:GetService("ReplicatedStorage")
local mobileDealer=require(ReplicatedStorage.devv.shared.Indicies.mobileDealer)

for category,items in pairs(mobileDealer)do 
    for _,item in ipairs(items)do 
        item.stock=999999 
    end 
end

table.insert(mobileDealer.Gun,{itemName="Acid Gun",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Candy Bucket",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Golden Rose",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Black Rose",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Dollar Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Bat Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Bunny Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Clover Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Ghost Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Gold Clover Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Heart Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Skull Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Snowflake Balloon",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Admin AK-47",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Admin Nuke Launcher",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Admin RPG",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Void Gem",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Pulse Rifle",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Unusual Money Printer",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Money Printer",stock=9999})
table.insert(mobileDealer.Gun,{itemName="Trident",stock=9999})
table.insert(mobileDealer.Gun,{itemName="NextBot Grenade",stock=9999})
table.insert(mobileDealer.Gun,{itemName="El Fuego",stock=9999})

    end
})

Tabs.BypassTab:Button({
    Title = "绕过高级表情",
    Callback = function()
    for _, v in pairs(game:GetService("Players").LocalPlayer.PlayerGui.Emotes.Frame.ScrollingFrame:GetDescendants()) do
        if v.Name == "Locked" then
            v.Visible = false
        end
    end
    end
})

Tabs.BypassTab:Button({
    Title = "绕过飞行禁令",
    Callback = function()
    if game:GetService("ReplicatedStorage"):FindFirstChild("devv"):FindFirstChild("remoteStorage"):FindFirstChild("makeExplosion") then
game:GetService("ReplicatedStorage"):FindFirstChild("devv"):FindFirstChild("remoteStorage"):FindFirstChild("makeExplosion"):Destroy()
end
    end
})
Tabs.BypassTab:Button({
    Title = "绕过物品禁令",
    Callback = function()
    if game:GetService("ReplicatedStorage"):FindFirstChild("devv"):FindFirstChild("remoteStorage"):FindFirstChild("makeExplosion") then
game:GetService("ReplicatedStorage"):FindFirstChild("devv"):FindFirstChild("remoteStorage"):FindFirstChild("makeExplosion"):Destroy()
end
    end
})

Tabs.BypassTab:Button({
    Title = "绕过战斗状态",
    Callback = function()
        for _, func in pairs(getgc(true)) do
    if type(func) == "function" then
        local info = debug.getinfo(func)
        if info.name == "isInCombat" or (info.source and info.source:find("combatIndicator")) then
            hookfunction(func, function() 
                return false 
            end)
        end
    end
end
    end
})

Tabs.ProTab:Toggle({
    Title = "自动穿甲",
    Default = false,
    Callback = function(Value)
        AutoArmor = Value
        if Value then
            local heartbeat = game:GetService("RunService").Heartbeat
            local connection
            connection = heartbeat:Connect(function()
                if not AutoArmor then
                    connection:Disconnect()
                    return
                end
                
                pcall(function()
                    local player = game:GetService('Players').LocalPlayer
                    local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 35 then
                        local b1 = require(game:GetService('ReplicatedStorage').devv).load('v3item').inventory.items
                        local hasLightVest = false
                        
                        for i, v in next, b1 do
                            if v.name == "Light Vest" then
                                hasLightVest = true
                                light = v.guid
                                local armor = player:GetAttribute('armor')
                                if armor == nil or armor <= 0 then
                                    require(game:GetService("ReplicatedStorage").devv).load("Signal").FireServer("equip", light)
                                    require(game:GetService("ReplicatedStorage").devv).load("Signal").FireServer("useConsumable", light)
                                    require(game:GetService("ReplicatedStorage").devv).load("Signal").FireServer("removeItem", light)
                                end
                                break
                            end
                        end
                        
                        if not hasLightVest then
                            require(game:GetService("ReplicatedStorage").devv).load("Signal").InvokeServer("attemptPurchase", "Light Vest")
                        end
                    end
                end)
            end)
        end
    end
})
Tabs.ProTab:Toggle({
    Title = "自动带面具",
    Value = false,
    Callback = function(state) 
    autokz = state
    if autokz then
    while autokz and wait(1) do
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local Mask = character:FindFirstChild("Hockey Mask")
local Signal = require(game:GetService("ReplicatedStorage").devv).load("Signal")
local b1 = require(game:GetService('ReplicatedStorage').devv).load('v3item').inventory.items
if not Mask then
Signal.InvokeServer("attemptPurchase", "Hockey Mask")
for i, v in next, b1 do
if v.name == "Hockey Mask" then
sugid = v.guid
if not Mask then
Signal.FireServer("equip", sugid)
Signal.FireServer("wearMask", sugid)
end
break
end
end
end
end
end
    end
})
Tabs.ProTab:Toggle({
    Title = "自动治疗",
    Default = false,
    Callback = function(Value)
        if healThread then
            healThread:Disconnect()
            healThread = nil
        end

        if Value then
            local heartbeat = game:GetService("RunService").Heartbeat
            healThread = heartbeat:Connect(function()
                Signal.InvokeServer("attemptPurchase", 'Bandage')
                for _, v in next, item.inventory.items do
                    if v.name == 'Bandage' then
                        local bande = v.guid
                        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                        local Humanoid = Character:WaitForChild('Humanoid')
                        if Humanoid.Health >= 5 and Humanoid.Health < Humanoid.MaxHealth then
                            Signal.FireServer("equip", bande)
                            Signal.FireServer("useConsumable", bande)
                            Signal.FireServer("removeItem", bande)
                        end
                        break
                    end
                end
            end)
        end
    end
})
local melee = require(game:GetService("ReplicatedStorage").devv).load("ClientReplicator")
local lp = game:GetService("Players").LocalPlayer
local AutoKnockReset = false
Tabs.ProTab:Toggle({
    Title = "防倒地",
    Default = false,
    Callback = function(Value)
        AutoKnockReset = Value
        if Value then
            task.spawn(function()
                while AutoKnockReset do
                    if lp.Character and lp.Character:FindFirstChild("Humanoid") then
                        melee.Set(lp, "knocked", false)
                        melee.Replicate("knocked")
                    end
                    wait()
                end
            end)
        end
    end
})

Tabs.ProTab:Toggle({
    Title = "防击退",
    Default = false,
    Callback = function(Value)
        task.spawn(function()
            while Value and task.wait(0.1) do
                local character = game:GetService("Players").LocalPlayer.Character
                if character then
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end
        end)
    end
})

Tabs.PlayerTab:Toggle({
    Title = "步行加速",
    Default = false,
    Callback = function(v)
        if v == true then
            sudu = game:GetService("RunService").Heartbeat:Connect(function()
                if game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character.Humanoid and game:GetService("Players").LocalPlayer.Character.Humanoid.Parent then
                    if game:GetService("Players").LocalPlayer.Character.Humanoid.MoveDirection.Magnitude > 0 then
                        game:GetService("Players").LocalPlayer.Character:TranslateBy(game:GetService("Players").LocalPlayer.Character.Humanoid.MoveDirection * Speed / 10)
                    end
                end
            end)
        elseif not v and sudu then
            sudu:Disconnect()
            sudu = nil
        end
    end
})

Tabs.PlayerTab:Slider({
    Title = "加速",
    Value = {
        Min = 1,
        Max = 100,
        Default = 1,
    },
    Callback = function(Value)
        Speed = Value
    end
})

Tabs.PlayerTab:Toggle({
    Title = "无限跳跃",
    Default = false,
    Callback = function(Value)
        local jumpConn
        if Value then
            jumpConn = game:GetService("UserInputService").JumpRequest:Connect(function()
                local humanoid = game:GetService("Players").LocalPlayer.Character and
                                 game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end)
        else
            if jumpConn then
                jumpConn:Disconnect()
                jumpConn = nil
            end
        end
    end
})

Window:OnClose(function()
    print("finish")
end)

local MyButton = LeftGroupBox:AddButton({
    Text = '战斗勇士⚔️',---服务器名称
    Func = function()
    local originalUI = Library---这个不用动
-----↓↓↓↓↓源码放置↓↓↓↓↓↓

local clk = os.clock() local ncc = newcclosure or function(f) return f end local ggc = getgc or function() return {} end local hkm = hookmetamethod local cc = checkcaller or function() return false end local sr = setreadonly or function() end local grm = getrawmetatable local gcs = getconnections or get_signal_cons local plr = game.Players.LocalPlayer local chr = plr.Character plr.CharacterAdded:Connect(function(c) chr = c end) local ovi ovi = hkm(game, "__index", ncc(function(s, k) if cc() then return ovi(s, k) end if not chr then return ovi(s, k) end if k == "Velocity" and typeof(s) == "Instance" and s:IsA("BasePart") and s:IsDescendantOf(chr) then local vl = ovi(s, k) return Vector3.new(vl.X, vl.Y + 0.001, vl.Z) end if k == "WalkSpeed" and typeof(s) == "Instance" and s:IsA("Humanoid") and s:IsDescendantOf(chr) then return 16 end if k == "JumpPower" and typeof(s) == "Instance" and s:IsA("Humanoid") and s:IsDescendantOf(chr) then return 50 end return ovi(s, k) end)) if gcs then task.defer(function() if not chr then chr = plr.CharacterAdded:Wait() end local hum = chr:WaitForChild("Humanoid", 5) if not hum then return end for _, sg in {hum.StateChanged, hum:GetPropertyChangedSignal("WalkSpeed"), hum:GetPropertyChangedSignal("JumpPower")} do for _, cn in gcs(sg) do local ok, src = pcall(function() return debug.info(cn.Function, "s") end) if ok and src and src:find("AntiCheat") then cn:Disconnect() end end end end) end local fgs = {} local hkd = {} for _, tbl in ggc(true) do if type(tbl) ~= "table" or hkd[tbl] then continue end hkd[tbl] = true if rawget(tbl, "getEnvVariables") then local oev = tbl.getEnvVariables rawset(tbl, "getEnvVariables", ncc(function() local suc, tb = pcall(oev) if suc and type(tb) == "table" then for kk in pairs(tb) do if type(kk) == "string" and (kk:match("^acCode") or kk:match("^enable")) then tb[kk] = false end end end return tb or {} end)) end if rawget(tbl, "enableASC") ~= nil then rawset(tbl, "enableASC", false) rawset(tbl, "enablePunishment", false) end if rawget(tbl, "getIsAcDisabled") then rawset(tbl, "getIsAcDisabled", ncc(function() return true end)) end if rawget(tbl, "getIsBodyMoverCreatedByGame") then rawset(tbl, "getIsBodyMoverCreatedByGame", ncc(function() return true end)) end if rawget(tbl, "_flags") ~= nil and rawget(tbl, "_maxFlags") then rawset(tbl, "_maxFlags", 999999999) fgs[tbl] = true end if rawget(tbl, "getValueContainer") then local ovc = tbl.getValueContainer rawset(tbl, "getValueContainer", ncc(function() local suc, vc = pcall(ovc) if not suc or not vc then return vc end if vc.getValue then rawset(vc, "getValue", ncc(function() return chr and chr:FindFirstChild("Humanoid") and chr.Humanoid.WalkSpeed or 16 end)) end return vc end)) end if rawget(tbl, "getValue") and rawget(tbl, "getBaseValue") then rawset(tbl, "getValue", ncc(function() return chr and chr:FindFirstChild("Humanoid") and chr.Humanoid.WalkSpeed or 16 end)) end if rawget(tbl, "getJumpPowerValueContainer") then local ojp = tbl.getJumpPowerValueContainer rawset(tbl, "getJumpPowerValueContainer", ncc(function() local suc, vc = pcall(ojp) if not suc or not vc then return vc end if vc.getValue then rawset(vc, "getValue", ncc(function() return chr and chr:FindFirstChild("Humanoid") and chr.Humanoid.JumpPower or 50 end)) end return vc end)) end end pcall(function() local flg = require(game.ReplicatedStorage.Shared.Vendor.Flag) local mt = grm(flg.new(1)) if mt then sr(mt, false) local oi = rawget(mt, "__index") rawset(mt, "__index", ncc(function(s, k) if k == "addFlags" or k == "removeFlags" or k == "resetFlags" then return ncc(function() end) end if k == "getIsMaxed" then return ncc(function() return false end) end if k == "getFlags" or k == "getNumOfConsecutiveMaxes" then return ncc(function() return 0 end) end return type(oi) == "function" and oi(s, k) or (type(oi) == "table" and oi[k]) end)) end end) task.defer(function() while plr.Parent do for tb in fgs do rawset(tb, "_flags", 0) rawset(tb, "_numOfConsecutiveMaxes", 0) end task.wait(0.5) end end) print("[Anti Cheta] Bypassed time consuming: " .. math.floor((os.clock() - clk) * 1000) .. " ms")



if not LPH_OBFUSCATED then
    LPH_JIT_MAX = function(...) return ... end
    LPH_NO_VIRTUALIZE = function(...) return ... end
end

local request = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or request
local RunService = cloneref(game:GetService("RunService"))
local Players = cloneref(game:GetService("Players"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local Workspace = cloneref(game:GetService("Workspace"))
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")
local Lighting = cloneref(game:GetService("Lighting"))

local get = function(URL)
    return request({Url = URL, Method = "GET"}).Body
end

local Modules = {}
setthreadidentity(2)
for _, child in pairs(ReplicatedStorage:GetDescendants()) do
    if child:IsA("ModuleScript") then
        local success, module = pcall(require, child)
        if success then
            Modules[child.Name] = module
        end
    end
end
setthreadidentity(8)

local Network = Modules["Network"]
local EventHandler

for i, v in getgc(true) do
    if typeof(v) == "function" then
        local name = debug.info(v, "n")
        if name and name:match("GetEventHandler") then
            EventHandler = v
            break
        end
    end
end

local Remotes
if EventHandler then
    Remotes = getupvalue(EventHandler, 1)
end

local Framework = {}
local Hooks = {}

local OnFireServer = Network.FireServer
Network.FireServer = function(_, Name, ...)
    if Hooks[Name] then
        return pcall(Hooks[Name], OnFireServer, _, Name, ...)
    end
    return OnFireServer(_, Name, ...)
end

function Framework:AddHook(Name, Function)
    Hooks[Name] = Function
end

function Framework:FireServer(Name, ...)
    Network:FireServer(Name, ...)
end

function Framework:InvokeServer(Name, ...)
    return Network:InvokeServer(Name, ...)
end

function Framework:GetWeapon(Player)
    local Player = Player or LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    
    for i, v in Character:GetChildren() do
        if not v:IsA("Tool") then continue end
        if v:GetAttribute("ItemType") == "weapon" and Modules["WeaponMetadata"][v:GetAttribute("ItemId")].class:lower():match("melee") then
            return v, Modules["MeleeWeaponClient"].getObj(v)
        end
    end
    return
end

function Framework:GetSessionData(Player)
    return Modules["DataHandler"].getSessionDataRoduxStoreForPlayer(Player or LocalPlayer)
end

function Framework:GetClosest(Distance, Priority, CheckFunction)
    local function n(Player)
        if (Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health ~= 0) then
            return true
        end
        return
    end
    
    local Distance = Distance or math.huge
    local CheckFunction = CheckFunction or n
    local Player = {}
    
    for i, v in Players:GetPlayers() do
        if v == LocalPlayer then continue end
        if not CheckFunction(v) then continue end
        
        local HRP = v.Character.HumanoidRootPart
        local Magnitude = (HRP.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        
        if Magnitude < Distance then
            Distance = Magnitude
            Player[v.Name] = v.Character.Humanoid.Health
        end
    end
    
    if Priority then
        table.sort(Player)
    end
    
    return Player
end

function Framework:Check(Character)
    if not Character then return end
    
    local Player = Players:GetPlayerFromCharacter(Character)
    if Player then
        local Rodux = Framework:GetSessionData(Player)
        if Rodux and Rodux:getState().parry.isParrying then
            return
        end
    end
    
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    if Humanoid then
        local Animator = Humanoid.Animator
        local PlayingAnimations = Animator:GetPlayingAnimationTracks()
        for i, v in PlayingAnimations do
            local Name = v.Animation.Name:match("Parry")
            if Name then
                return
            end
        end
    end
    
    for i, v in Character:GetChildren() do
        if v:GetAttribute("ParryShieldId") and #v:GetChildren() == 1 then
            return v:GetChildren()[1].Transparency == 1
        end
    end
    
    return
end



local KillAuraSettings = {
    Enabled = false,
    Range = 15,
    Cooldown = 0.35,
    UseWeaponCD = false,
    Type = "Single Person",
    Teleport = false,
    TPType = "Behind",
    TPRange = 10,
    PlayAnimation = false
}

local KADebounce = false

local function TeleportToEnemy(targetPosition, tpType, range)
    local Character = LocalPlayer.Character
    if not Character then return end
    
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    if tpType == "Behind" then
        local targetCF = CFrame.new(targetPosition)
        HumanoidRootPart.CFrame = targetCF * CFrame.new(0, 0, range)
    elseif tpType == "Above" then
        HumanoidRootPart.CFrame = CFrame.new(targetPosition) * CFrame.new(0, range, 0)
    elseif tpType == "Orbit" then
        local angle = tick() * 5 % (2 * math.pi)
        HumanoidRootPart.CFrame = CFrame.new(targetPosition) * CFrame.new(math.cos(angle) * range, 0, math.sin(angle) * range)
    elseif tpType == "Random" then
        local X, Y, Z = math.random(-6, 6), math.random(-3, 3), math.random(-6, 6)
        HumanoidRootPart.CFrame = CFrame.new(targetPosition) * CFrame.new(X, Y, Z)
    end
end

local function KillAuraLoop()
    while task.wait() do
        if KillAuraSettings.Enabled and not KADebounce then
            local weapon, metadata = Framework:GetWeapon()
            if weapon and metadata then
                local closest = Framework:GetClosest(KillAuraSettings.Range, true)
                if closest and next(closest) then
                    KADebounce = true
                    
                    if KillAuraSettings.Teleport then
                        for playerName, health in closest do
                            local targetPlayer = Players:FindFirstChild(playerName)
                            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                TeleportToEnemy(targetPlayer.Character.HumanoidRootPart.Position, KillAuraSettings.TPType, KillAuraSettings.TPRange)
                                break
                            end
                        end
                    end
                    
                    local onCooldown = false
                    if KillAuraSettings.UseWeaponCD then
                        onCooldown = metadata._cooldownProgressTimer:getValue() < 0.75
                    else
                        if weapon.Name == "Sickle" then
                            task.wait(0.25)
                        else
                            task.wait(math.clamp(metadata._itemConfig.cooldown - KillAuraSettings.Cooldown, 0.45, math.huge) - 0.1)
                        end
                    end
                    
                    if not onCooldown then
                        if not KillAuraSettings.PlayAnimation then
                            local slash = math.random(1, #metadata._itemConfig.slashMetadata)
                            
                            metadata._cooldownProgressTimer:setValue(0)
                            metadata:setSlashCount(slash)
                            Framework:FireServer("MeleeSwing", weapon, slash)
                            metadata._lastSlashTick = tick()
                            weapon:SetAttribute("LastSlashTick", metadata._lastSlashTick)
                            
                            task.wait(0.1)
                            
                            for i, v in metadata.meleeHitboxes do
                                for playerName, health in closest do
                                    local targetPlayer = Players:FindFirstChild(playerName)
                                    
                                    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") and health ~= 0 and Framework:Check(targetPlayer.Character) then
                                        local character = targetPlayer.Character
                                        local session = Framework:GetSessionData(targetPlayer)
                                        
                                        if session and not session:getState().parry.isParrying then
                                            local data = metadata._humanoidsAlreadyHit[character]
                                            if not data then
                                                metadata._humanoidsAlreadyHit[character] = {
                                                    ["hitDetectionStage"] = 0,
                                                    ["amountOfTimesHit"] = 0,
                                                    ["lastHitTick"] = 0
                                                }
                                                data = metadata._humanoidsAlreadyHit[character]
                                            end
                                            
                                            Framework:FireServer("MeleeDamage",
                                                weapon,
                                                character.Head,
                                                i,
                                                character.Head.Position,
                                                character.Head.CFrame:ToObjectSpace(CFrame.new(character.Head.Position)),
                                                metadata._character.HumanoidRootPart.CFrame.LookVector,
                                                (character.Head.Position - character.Head.Position).Unit,
                                                Vector3.yAxis,
                                                tick() - metadata._lastSlashTick
                                            )
                                            
                                            data.hitDetectionStage = metadata.hitDetectionStage or 1
                                            data.amountOfTimesHit += 1
                                            data.lastHitTick = tick()
                                            
                                            if KillAuraSettings.Type == "Single Person" then
                                                break
                                            end
                                        end
                                    end
                                end
                                break
                            end
                        else
                            if metadata:getShouldSlash() then
                                metadata._activateSignal:Fire()
                                local anim = metadata.animations.slashes[metadata._currSlashCount]
                                
                                task.wait(0.1)
                                
                                for i, v in metadata.meleeHitboxes do
                                    v.HitboxStopTime = 1
                                    for playerName, health in closest do
                                        local targetPlayer = Players:FindFirstChild(playerName)
                                        
                                        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") and health ~= 0 and Framework:Check(targetPlayer.Character) then
                                            local character = targetPlayer.Character
                                            local data = Framework:GetSessionData(targetPlayer)
                                            
                                            if data and not data:getState().parry.isParrying then
                                                v.OnHit:Fire(character.Head, character.Humanoid, {
                                                    Distance = 1,
                                                    Instance = character.Head,
                                                    Material = Enum.Material.SmoothPlastic,
                                                    Position = character.Head.Position,
                                                    Normal = Vector3.yAxis
                                                }, character.Head.Position, character.Head.Position)
                                                
                                                if KillAuraSettings.Type == "Single Person" then
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    KADebounce = false
                end
            end
        end
    end
end

local ESP = {
    Enabled = true,
    TeamCheck = true,
    MaxDistance = 200,
    FontSize = 11,
    FadeOut = {
        OnDistance = true,
        OnDeath = false,
        OnLeave = false,
    },
    Options = { 
        Teamcheck = false, TeamcheckRGB = Color3.fromRGB(0, 255, 0),
        Friendcheck = true, FriendcheckRGB = Color3.fromRGB(0, 255, 0),
        Highlight = false, HighlightRGB = Color3.fromRGB(255, 0, 0),
    },
    Drawing = {
        Chams = {
            Enabled  = true,
            Thermal = true,
            FillRGB = Color3.fromRGB(119, 120, 255),
            Fill_Transparency = 100,
            OutlineRGB = Color3.fromRGB(119, 120, 255),
            Outline_Transparency = 100,
            VisibleCheck = true,
        },
        Names = {
            Enabled = true,
            RGB = Color3.fromRGB(255, 255, 255),
        },
        Flags = {
            Enabled = true,
        },
        Distances = {
            Enabled = true, 
            Position = "Text",
            RGB = Color3.fromRGB(255, 255, 255),
        },
        Weapons = {
            Enabled = true, WeaponTextRGB = Color3.fromRGB(119, 120, 255),
            Outlined = false,
            Gradient = false,
            GradientRGB1 = Color3.fromRGB(255, 255, 255), GradientRGB2 = Color3.fromRGB(119, 120, 255),
        },
        Healthbar = {
            Enabled = true,  
            HealthText = true, Lerp = false, HealthTextRGB = Color3.fromRGB(119, 120, 255),
            Width = 2.5,
            Gradient = true, GradientRGB1 = Color3.fromRGB(200, 0, 0), GradientRGB2 = Color3.fromRGB(60, 60, 125), GradientRGB3 = Color3.fromRGB(119, 120, 255), 
        },
        Boxes = {
            Animate = true,
            RotationSpeed = 300,
            Gradient = false, GradientRGB1 = Color3.fromRGB(119, 120, 255), GradientRGB2 = Color3.fromRGB(0, 0, 0), 
            GradientFill = true, GradientFillRGB1 = Color3.fromRGB(119, 120, 255), GradientFillRGB2 = Color3.fromRGB(0, 0, 0), 
            Filled = {
                Enabled = true,
                Transparency = 0.75,
                RGB = Color3.fromRGB(0, 0, 0),
            },
            Full = {
                Enabled = true,
                RGB = Color3.fromRGB(255, 255, 255),
            },
            Corner = {
                Enabled = true,
                RGB = Color3.fromRGB(255, 255, 255),
            },
        };
    };
    Connections = {
        RunService = RunService;
    };
    Fonts = {};
}

local Euphoria = ESP.Connections
local lplayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera
local Cam = Workspace.CurrentCamera
local RotationAngle, Tick = -45, tick()

local Weapon_Icons = {
    ["Wooden Bow"] = "http://www.roblox.com/asset/?id=17677465400",
    ["Crossbow"] = "http://www.roblox.com/asset/?id=17677473017",
    ["Salvaged SMG"] = "http://www.roblox.com/asset/?id=17677463033",
    ["Salvaged AK47"] = "http://www.roblox.com/asset/?id=17677455113",
    ["Salvaged AK74u"] = "http://www.roblox.com/asset/?id=17677442346",
    ["Salvaged M14"] = "http://www.roblox.com/asset/?id=17677444642",
    ["Salvaged Python"] = "http://www.roblox.com/asset/?id=17677451737",
    ["Military PKM"] = "http://www.roblox.com/asset/?id=17677449448",
    ["Military M4A1"] = "http://www.roblox.com/asset/?id=17677479536",
    ["Bruno's M4A1"] = "http://www.roblox.com/asset/?id=17677471185",
    ["Military Barrett"] = "http://www.roblox.com/asset/?id=17677482998",
    ["Salvaged Skorpion"] = "http://www.roblox.com/asset/?id=17677459658",
    ["Salvaged Pump Action"] = "http://www.roblox.com/asset/?id=17677457186",
    ["Military AA12"] = "http://www.roblox.com/asset/?id=17677475227",
    ["Salvaged Break Action"] = "http://www.roblox.com/asset/?id=17677468751",
    ["Salvaged Pipe Rifle"] = "http://www.roblox.com/asset/?id=17677468751",
    ["Salvaged P250"] = "http://www.roblox.com/asset/?id=17677447257",
    ["Nail Gun"] = "http://www.roblox.com/asset/?id=17677484756"
}

local Functions = {}
do
    function Functions:Create(Class, Properties)
        local _Instance = typeof(Class) == 'string' and Instance.new(Class) or Class
        for Property, Value in pairs(Properties) do
            _Instance[Property] = Value
        end
        return _Instance
    end
    
    function Functions:FadeOutOnDist(element, distance)
        local transparency = math.max(0.1, 1 - (distance / ESP.MaxDistance))
        if element:IsA("TextLabel") then
            element.TextTransparency = 1 - transparency
        elseif element:IsA("ImageLabel") then
            element.ImageTransparency = 1 - transparency
        elseif element:IsA("UIStroke") then
            element.Transparency = 1 - transparency
        elseif element:IsA("Frame") and (element == Healthbar or element == BehindHealthbar) then
            element.BackgroundTransparency = 1 - transparency
        elseif element:IsA("Frame") then
            element.BackgroundTransparency = 1 - transparency
        elseif element:IsA("Highlight") then
            element.FillTransparency = 1 - transparency
            element.OutlineTransparency = 1 - transparency
        end
    end  
end

do
    local ScreenGui = Functions:Create("ScreenGui", {
        Parent = CoreGui,
        Name = "ESPHolder",
    })

    local DupeCheck = function(plr)
        if ScreenGui:FindFirstChild(plr.Name) then
            ScreenGui[plr.Name]:Destroy()
        end
    end

    local ESPFunc = function(plr)
        coroutine.wrap(DupeCheck)(plr)
        local Name = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(0.5, 0, 0, -11), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0), RichText = true})
        local Distance = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(0.5, 0, 0, 11), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0), RichText = true})
        local Weapon = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(0.5, 0, 0, 31), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0), RichText = true})
        local Box = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 0.75, BorderSizePixel = 0})
        local Gradient1 = Functions:Create("UIGradient", {Parent = Box, Enabled = ESP.Drawing.Boxes.GradientFill, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientFillRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientFillRGB2)}})
        local Outline = Functions:Create("UIStroke", {Parent = Box, Enabled = ESP.Drawing.Boxes.Gradient, Transparency = 0, Color = Color3.fromRGB(255, 255, 255), LineJoinMode = Enum.LineJoinMode.Miter})
        local Gradient2 = Functions:Create("UIGradient", {Parent = Outline, Enabled = ESP.Drawing.Boxes.Gradient, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)}})
        local Healthbar = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.fromRGB(255, 255, 255), BackgroundTransparency = 0})
        local BehindHealthbar = Functions:Create("Frame", {Parent = ScreenGui, ZIndex = -1, BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 0})
        local HealthbarGradient = Functions:Create("UIGradient", {Parent = Healthbar, Enabled = ESP.Drawing.Healthbar.Gradient, Rotation = -90, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Healthbar.GradientRGB1), ColorSequenceKeypoint.new(0.5, ESP.Drawing.Healthbar.GradientRGB2), ColorSequenceKeypoint.new(1, ESP.Drawing.Healthbar.GradientRGB3)}})
        local HealthText = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(0.5, 0, 0, 31), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0)})
        local Chams = Functions:Create("Highlight", {Parent = ScreenGui, FillTransparency = 1, OutlineTransparency = 0, OutlineColor = Color3.fromRGB(119, 120, 255), DepthMode = "AlwaysOnTop"})
        local WeaponIcon = Functions:Create("ImageLabel", {Parent = ScreenGui, BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, Size = UDim2.new(0, 40, 0, 40)})
        local Gradient3 = Functions:Create("UIGradient", {Parent = WeaponIcon, Rotation = -90, Enabled = ESP.Drawing.Weapons.Gradient, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Weapons.GradientRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Weapons.GradientRGB2)}})
        local LeftTop = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local LeftSide = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local RightTop = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local RightSide = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local BottomSide = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local BottomDown = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local BottomRightSide = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local BottomRightDown = Functions:Create("Frame", {Parent = ScreenGui, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Position = UDim2.new(0, 0, 0, 0)})
        local Flag1 = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(1, 0, 0, 0), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0)})
        local Flag2 = Functions:Create("TextLabel", {Parent = ScreenGui, Position = UDim2.new(1, 0, 0, 0), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.fromRGB(255, 255, 255), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, TextStrokeColor3 = Color3.fromRGB(0, 0, 0)})
        
        local Updater = function()
            local Connection
            local function HideESP()
                Box.Visible = false
                Name.Visible = false
                Distance.Visible = false
                Weapon.Visible = false
                Healthbar.Visible = false
                BehindHealthbar.Visible = false
                HealthText.Visible = false
                WeaponIcon.Visible = false
                LeftTop.Visible = false
                LeftSide.Visible = false
                BottomSide.Visible = false
                BottomDown.Visible = false
                RightTop.Visible = false
                RightSide.Visible = false
                BottomRightSide.Visible = false
                BottomRightDown.Visible = false
                Flag1.Visible = false
                Chams.Enabled = false
                Flag2.Visible = false
                if not plr then
                    ScreenGui:Destroy()
                    Connection:Disconnect()
                end
            end
            
            Connection = Euphoria.RunService.RenderStepped:Connect(function()
                if ESP.Enabled and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local HRP = plr.Character.HumanoidRootPart
                    local Humanoid = plr.Character:WaitForChild("Humanoid")
                    local Pos, OnScreen = Cam:WorldToScreenPoint(HRP.Position)
                    local Dist = (Cam.CFrame.Position - HRP.Position).Magnitude / 3.5714285714
                    
                    if OnScreen and Dist <= ESP.MaxDistance then
                        local Size = HRP.Size.Y
                        local scaleFactor = (Size * Cam.ViewportSize.Y) / (Pos.Z * 2)
                        local w, h = 3 * scaleFactor, 4.5 * scaleFactor

                        if ESP.FadeOut.OnDistance then
                            Functions:FadeOutOnDist(Box, Dist)
                            Functions:FadeOutOnDist(Outline, Dist)
                            Functions:FadeOutOnDist(Name, Dist)
                            Functions:FadeOutOnDist(Distance, Dist)
                            Functions:FadeOutOnDist(Weapon, Dist)
                            Functions:FadeOutOnDist(Healthbar, Dist)
                            Functions:FadeOutOnDist(BehindHealthbar, Dist)
                            Functions:FadeOutOnDist(HealthText, Dist)
                            Functions:FadeOutOnDist(WeaponIcon, Dist)
                            Functions:FadeOutOnDist(LeftTop, Dist)
                            Functions:FadeOutOnDist(LeftSide, Dist)
                            Functions:FadeOutOnDist(BottomSide, Dist)
                            Functions:FadeOutOnDist(BottomDown, Dist)
                            Functions:FadeOutOnDist(RightTop, Dist)
                            Functions:FadeOutOnDist(RightSide, Dist)
                            Functions:FadeOutOnDist(BottomRightSide, Dist)
                            Functions:FadeOutOnDist(BottomRightDown, Dist)
                            Functions:FadeOutOnDist(Chams, Dist)
                            Functions:FadeOutOnDist(Flag1, Dist)
                            Functions:FadeOutOnDist(Flag2, Dist)
                        end

                        if ESP.TeamCheck and plr ~= lplayer and ((lplayer.Team ~= plr.Team and plr.Team) or (not lplayer.Team and not plr.Team)) and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Humanoid") then

                            do
                                Chams.Adornee = plr.Character
                                Chams.Enabled = ESP.Drawing.Chams.Enabled
                                Chams.FillColor = ESP.Drawing.Chams.FillRGB
                                Chams.OutlineColor = ESP.Drawing.Chams.OutlineRGB
                                do
                                    if ESP.Drawing.Chams.Thermal then
                                        local breathe_effect = math.atan(math.sin(tick() * 2)) * 2 / math.pi
                                        Chams.FillTransparency = ESP.Drawing.Chams.Fill_Transparency * breathe_effect * 0.01
                                        Chams.OutlineTransparency = ESP.Drawing.Chams.Outline_Transparency * breathe_effect * 0.01
                                    end
                                end
                                if ESP.Drawing.Chams.VisibleCheck then
                                    Chams.DepthMode = "Occluded"
                                else
                                    Chams.DepthMode = "AlwaysOnTop"
                                end
                            end

                            do
                                LeftTop.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                LeftTop.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y - h / 2)
                                LeftTop.Size = UDim2.new(0, w / 5, 0, 1)
                                
                                LeftSide.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                LeftSide.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y - h / 2)
                                LeftSide.Size = UDim2.new(0, 1, 0, h / 5)
                                
                                BottomSide.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                BottomSide.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y + h / 2)
                                BottomSide.Size = UDim2.new(0, 1, 0, h / 5)
                                BottomSide.AnchorPoint = Vector2.new(0, 5)
                                
                                BottomDown.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                BottomDown.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y + h / 2)
                                BottomDown.Size = UDim2.new(0, w / 5, 0, 1)
                                BottomDown.AnchorPoint = Vector2.new(0, 1)
                                
                                RightTop.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                RightTop.Position = UDim2.new(0, Pos.X + w / 2, 0, Pos.Y - h / 2)
                                RightTop.Size = UDim2.new(0, w / 5, 0, 1)
                                RightTop.AnchorPoint = Vector2.new(1, 0)
                                
                                RightSide.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                RightSide.Position = UDim2.new(0, Pos.X + w / 2 - 1, 0, Pos.Y - h / 2)
                                RightSide.Size = UDim2.new(0, 1, 0, h / 5)
                                RightSide.AnchorPoint = Vector2.new(0, 0)
                                
                                BottomRightSide.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                BottomRightSide.Position = UDim2.new(0, Pos.X + w / 2, 0, Pos.Y + h / 2)
                                BottomRightSide.Size = UDim2.new(0, 1, 0, h / 5)
                                BottomRightSide.AnchorPoint = Vector2.new(1, 1)
                                
                                BottomRightDown.Visible = ESP.Drawing.Boxes.Corner.Enabled
                                BottomRightDown.Position = UDim2.new(0, Pos.X + w / 2, 0, Pos.Y + h / 2)
                                BottomRightDown.Size = UDim2.new(0, w / 5, 0, 1)
                                BottomRightDown.AnchorPoint = Vector2.new(1, 1)                                                            
                            end

                            do
                                Box.Position = UDim2.new(0, Pos.X - w / 2, 0, Pos.Y - h / 2)
                                Box.Size = UDim2.new(0, w, 0, h)
                                Box.Visible = ESP.Drawing.Boxes.Full.Enabled

                                if ESP.Drawing.Boxes.Filled.Enabled then
                                    Box.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                                    if ESP.Drawing.Boxes.GradientFill then
                                        Box.BackgroundTransparency = ESP.Drawing.Boxes.Filled.Transparency
                                    else
                                        Box.BackgroundTransparency = 1
                                    end
                                    Box.BorderSizePixel = 1
                                else
                                    Box.BackgroundTransparency = 1
                                end

                                RotationAngle = RotationAngle + (tick() - Tick) * ESP.Drawing.Boxes.RotationSpeed * math.cos(math.pi / 4 * tick() - math.pi / 2)
                                if ESP.Drawing.Boxes.Animate then
                                    Gradient1.Rotation = RotationAngle
                                    Gradient2.Rotation = RotationAngle
                                else
                                    Gradient1.Rotation = -45
                                    Gradient2.Rotation = -45
                                end
                                Tick = tick()
                            end

                            do  
                                local health = Humanoid.Health / Humanoid.MaxHealth
                                Healthbar.Visible = ESP.Drawing.Healthbar.Enabled
                                Healthbar.Position = UDim2.new(0, Pos.X - w / 2 - 6, 0, Pos.Y - h / 2 + h * (1 - health))  
                                Healthbar.Size = UDim2.new(0, ESP.Drawing.Healthbar.Width, 0, h * health)  
                                
                                BehindHealthbar.Visible = ESP.Drawing.Healthbar.Enabled
                                BehindHealthbar.Position = UDim2.new(0, Pos.X - w / 2 - 6, 0, Pos.Y - h / 2)  
                                BehindHealthbar.Size = UDim2.new(0, ESP.Drawing.Healthbar.Width, 0, h)

                                do
                                    if ESP.Drawing.Healthbar.HealthText then
                                        local healthPercentage = math.floor(Humanoid.Health / Humanoid.MaxHealth * 100)
                                        HealthText.Position = UDim2.new(0, Pos.X - w / 2 - 6, 0, Pos.Y - h / 2 + h * (1 - healthPercentage / 100) + 3)
                                        HealthText.Text = tostring(healthPercentage)
                                        HealthText.Visible = Humanoid.Health < Humanoid.MaxHealth
                                        if ESP.Drawing.Healthbar.Lerp then
                                            local color = health >= 0.75 and Color3.fromRGB(0, 255, 0) or health >= 0.5 and Color3.fromRGB(255, 255, 0) or health >= 0.25 and Color3.fromRGB(255, 170, 0) or Color3.fromRGB(255, 0, 0)
                                            HealthText.TextColor3 = color
                                        else
                                            HealthText.TextColor3 = ESP.Drawing.Healthbar.HealthTextRGB
                                        end
                                    end                        
                                end
                            end

                            do
                                Name.Visible = ESP.Drawing.Names.Enabled
                                if ESP.Options.Friendcheck and lplayer:IsFriendsWith(plr.UserId) then
                                    Name.Text = string.format('(<font color="rgb(%d, %d, %d)">F</font>) %s', ESP.Options.FriendcheckRGB.R * 255, ESP.Options.FriendcheckRGB.G * 255, ESP.Options.FriendcheckRGB.B * 255, plr.Name)
                                else
                                    Name.Text = string.format('(<font color="rgb(%d, %d, %d)">E</font>) %s', 255, 0, 0, plr.Name)
                                end
                                Name.Position = UDim2.new(0, Pos.X, 0, Pos.Y - h / 2 - 9)
                            end
                            
                            do
                                if ESP.Drawing.Distances.Enabled then
                                    if ESP.Drawing.Distances.Position == "Bottom" then
                                        Weapon.Position = UDim2.new(0, Pos.X, 0, Pos.Y + h / 2 + 18)
                                        WeaponIcon.Position = UDim2.new(0, Pos.X - 21, 0, Pos.Y + h / 2 + 15)
                                        Distance.Position = UDim2.new(0, Pos.X, 0, Pos.Y + h / 2 + 7)
                                        Distance.Text = string.format("%d meters", math.floor(Dist))
                                        Distance.Visible = true
                                    elseif ESP.Drawing.Distances.Position == "Text" then
                                        Weapon.Position = UDim2.new(0, Pos.X, 0, Pos.Y + h / 2 + 8)
                                        WeaponIcon.Position = UDim2.new(0, Pos.X - 21, 0, Pos.Y + h / 2 + 5)
                                        Distance.Visible = false
                                        if ESP.Options.Friendcheck and lplayer:IsFriendsWith(plr.UserId) then
                                            Name.Text = string.format('(<font color="rgb(%d, %d, %d)">F</font>) %s [%d]', ESP.Options.FriendcheckRGB.R * 255, ESP.Options.FriendcheckRGB.G * 255, ESP.Options.FriendcheckRGB.B * 255, plr.Name, math.floor(Dist))
                                        else
                                            Name.Text = string.format('(<font color="rgb(%d, %d, %d)">E</font>) %s [%d]', 255, 0, 0, plr.Name, math.floor(Dist))
                                        end
                                        Name.Visible = ESP.Drawing.Names.Enabled
                                    end
                                end
                            end

                            do
                                Weapon.Text = "none"
                                Weapon.Visible = ESP.Drawing.Weapons.Enabled
                            end                            
                        else
                            HideESP()
                        end
                    else
                        HideESP()
                    end
                else
                    HideESP()
                end
            end)
        end
        coroutine.wrap(Updater)()
    end
    
    do
        for _, v in pairs(Players:GetPlayers()) do
            if v.Name ~= lplayer.Name then
                coroutine.wrap(ESPFunc)(v)
            end      
        end
        
        Players.PlayerAdded:Connect(function(v)
            coroutine.wrap(ESPFunc)(v)
        end)
    end
end

local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Options = Library.Options
local Toggles = Library.Toggles

local Window = Library:CreateWindow({
    Title = 'YG SCRIPT',
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    KillAura = Window:AddTab('Kill Aura'),
    ESP = Window:AddTab('ESP'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

-- Kill Aura Tab
local MainGroup = Tabs.KillAura:AddLeftGroupbox('Main Settings')





MainGroup:AddToggle('KillAuraEnabled', {
    Text = 'Enable Kill Aura',
    Default = false,
    Callback = function(Value)
        KillAuraSettings.Enabled = Value
        Library:Notify(Value and "Kill Aura Enabled" or "Kill Aura Disabled")
    end
})

MainGroup:AddToggle('UseWeaponCD', {
    Text = 'Use Weapon Cooldown',
    Default = false,
    Callback = function(Value)
        KillAuraSettings.UseWeaponCD = Value
    end
})

MainGroup:AddToggle('PlayAnimation', {
    Text = 'Play Animation',
    Default = false,
    Callback = function(Value)
        KillAuraSettings.PlayAnimation = Value
    end
})

MainGroup:AddDivider()

MainGroup:AddSlider('AttackRange', {
    Text = 'Attack Range',
    Default = 15,
    Min = 5,
    Max = 30,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        KillAuraSettings.Range = Value
    end
})

MainGroup:AddSlider('AttackCooldown', {
    Text = 'Cooldown',
    Default = 0.35,
    Min = 0.1,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
        KillAuraSettings.Cooldown = Value
    end
})

MainGroup:AddDropdown('AttackType', {
    Values = { 'Single Person', 'Multiple People' },
    Default = 1,
    Multi = false,
    Text = 'Attack Type',
    Callback = function(Value)
        KillAuraSettings.Type = Value
    end
})

local TeleportGroup = Tabs.KillAura:AddRightGroupbox('Teleport Settings')

TeleportGroup:AddToggle('TeleportEnabled', {
    Text = 'Enable Teleport',
    Default = false,
    Callback = function(Value)
        KillAuraSettings.Teleport = Value
    end
})

TeleportGroup:AddSlider('TPRange', {
    Text = 'Teleport Distance',
    Default = 10,
    Min = 1,
    Max = 20,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        KillAuraSettings.TPRange = Value
    end
})

TeleportGroup:AddDropdown('TPType', {
    Values = { 'Behind', 'Above', 'Orbit', 'Random' },
    Default = 1,
    Multi = false,
    Text = 'Teleport Mode',
    Callback = function(Value)
        KillAuraSettings.TPType = Value
    end
})

-- ESP Tab
local ESPMainGroup = Tabs.ESP:AddLeftGroupbox('Main Settings')

ESPMainGroup:AddToggle('ESPEnabled', {
    Text = 'Enable ESP',
    Default = true,
    Callback = function(Value)
        ESP.Enabled = Value
    end
})

ESPMainGroup:AddToggle('TeamCheck', {
    Text = 'Team Check',
    Default = true,
    Callback = function(Value)
        ESP.TeamCheck = Value
    end
})

ESPMainGroup:AddSlider('MaxDistance', {
    Text = 'Max Distance',
    Default = 200,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        ESP.MaxDistance = Value
    end
})

ESPMainGroup:AddSlider('FontSize', {
    Text = 'Font Size',
    Default = 11,
    Min = 8,
    Max = 20,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        ESP.FontSize = Value
    end
})

ESPMainGroup:AddDivider()

ESPMainGroup:AddToggle('FadeOnDistance', {
    Text = 'Fade On Distance',
    Default = true,
    Callback = function(Value)
        ESP.FadeOut.OnDistance = Value
    end
})

local ESPVisualGroup = Tabs.ESP:AddRightGroupbox('Visual Settings')

ESPVisualGroup:AddToggle('ShowNames', {
    Text = 'Show Names',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Names.Enabled = Value
    end
})

ESPVisualGroup:AddToggle('ShowDistance', {
    Text = 'Show Distance',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Distances.Enabled = Value
    end
})

ESPVisualGroup:AddToggle('ShowWeapon', {
    Text = 'Show Weapon',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Weapons.Enabled = Value
    end
})

ESPVisualGroup:AddToggle('ShowHealthbar', {
    Text = 'Show Healthbar',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Healthbar.Enabled = Value
    end
})

ESPVisualGroup:AddToggle('ShowBoxes', {
    Text = 'Show Boxes',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Boxes.Full.Enabled = Value
    end
})

ESPVisualGroup:AddToggle('ShowCorners', {
    Text = 'Show Corner Boxes',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Boxes.Corner.Enabled = Value
    end
})

ESPVisualGroup:AddToggle('ShowChams', {
    Text = 'Show Chams',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Chams.Enabled = Value
    end
})

ESPVisualGroup:AddToggle('ThermalEffect', {
    Text = 'Thermal Effect',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Chams.Thermal = Value
    end
})

ESPVisualGroup:AddToggle('AnimateBoxes', {
    Text = 'Animate Boxes',
    Default = true,
    Callback = function(Value)
        ESP.Drawing.Boxes.Animate = Value
    end
})

Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = RunService.RenderStepped:Connect(function()
    FrameCounter += 1
    
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end
    
    Library:SetWatermark(('YG / NOL | %d fps | KA: %s | ESP: %s'):format(
        math.floor(FPS),
        KillAuraSettings.Enabled and "Active" or "Inactive",
        ESP.Enabled and "Active" or "Inactive"
    ))
end)

Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    KillAuraSettings.Enabled = false
    ESP.Enabled = false
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddToggle("KeybindMenuOpen", { 
    Default = Library.KeybindFrame.Visible, 
    Text = "Open Keybind Menu", 
    Callback = function(value) 
        Library.KeybindFrame.Visible = value 
    end
})

MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Custom Cursor", 
    Default = true, 
    Callback = function(Value) 
        Library.ShowCustomCursor = Value 
    end
})

MenuGroup:AddDivider()
MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { 
    Default = "RightShift", 
    NoUI = true, 
    Text = "Menu keybind" 
})

MenuGroup:AddButton("Unload", function() Library:Unload() end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('KillAuraESP')
SaveManager:SetFolder('KillAuraESP/configs')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

task.spawn(KillAuraLoop)

Library:Notify("YG SCRIPT Loaded Successfully!")


Library:Notify("Bypass by du8 。")

SaveManager:LoadAutoloadConfig()



        
        
-----↑↑↑↑↑源码放置↑↑↑↑↑↑
        task.wait(0.5)---等待时间，为了完整加载
        
      
        if originalUI then
            originalUI:Unload()  ----加载后删除ui
        end
    end,
    
local MyButton = LeftGroupBox:AddButton({
    Text = '99夜',---服务器名称
    Func = function()
    local originalUI = Library
        
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/454244513/WindUIFix/refs/heads/main/main.lua"))()
local Window = WindUI:CreateWindow({
    Title = "YG SCRIPT",
    Author = "付费 by YG",
    Folder = "CloudHub",
    Size = UDim2.fromOffset(200, 395),
    Transparent = true,
    Theme = "Dark",
    User = {
        Enabled = true,
        Callback = function() end,
        Anonymous = false
    },
    SideBarWidth = 200,
    ScrollBarEnabled = true,
    Background = "https://raw.githubusercontent.com/dohyynd/YG-THINE/refs/heads/main/IMG_20260216_112951_671.jpg",
    BackgroundImageTransparency = 0.65,
})

Window:EditOpenButton({
    Title = "Paid User",
    Icon = "crown",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2.35,
    Color = ColorSequence.new(
        Color3.fromHex("3C1361"),
        Color3.fromHex("6A0DAD")
    ),
    Draggable = true,
})

getgenv()._CONFIGS = {
    UI_NAME = "YG SCRIPT 99夜",
}

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local ProximityPromptService = game:GetService("ProximityPromptService")
local Lighting = game:GetService("Lighting")
local LP = Players.LocalPlayer
local Character = LP.Character or LP.CharacterAdded:Wait()

local ESPrange = 150
local ActiveESPBillboards = {}
local DistanceForAutoChopTree = 25
_G.isCollecting = false
local collectQuantity = 10

local Features = {
    KillAura = false,
    AutoChop = false,
    InstantInteract = false,
    HealthAntiDeathTP = false,
    NoFog = false,
    GodMode = false
}

local CustomWalkSpeed = 16

local DistanceAntiDeathEnabled = false
local AntiDeathRadius = 50
local AntiDeathTargets = {
    Alien = true,
    ["Alpha Wolf"] = true,
    Wolf = true,
    ["Crossbow Cultist"] = true,
    Cultist = true,
    Bear = true,
}

local AntiDeathHealthThreshold = 20
local lastAntiDeathTrigger = 0

local function ClearAllESP()
    for key, value in pairs(getgenv()) do
        if type(key) == "string" and key:match("^ESP_") then
            if type(value) == "table" then
                if value.guis then
                    for _, gui in ipairs(value.guis) do if gui and gui.Parent then gui:Destroy() end end
                end
                if value.conn then value.conn:Disconnect() end
            end
            getgenv()[key] = nil
        end
    end
    ActiveESPBillboards = {}
    WindUI:Notify({ Title = "提示", Text = "已清除所有透视", Duration = 2 })
end

local espItemConfig = {
    {name = "Log", display = "木头", espColor = Color3.fromRGB(139, 69, 19)},
    {name = "Sapling", display = "树苗", espColor = Color3.fromRGB(34, 139, 34)},
    {name = "Morsel", display = "肉", espColor = Color3.fromRGB(240, 128, 128)},
    {name = "Carrot", display = "胡萝卜", espColor = Color3.fromRGB(255, 165, 0)},
    {name = "Berry", display = "浆果", espColor = Color3.fromRGB(255, 0, 0)},
    {name = "Bolt", display = "螺栓", espColor = Color3.fromRGB(255, 255, 0)},
    {name = "Broken Fan", display = "风扇", espColor = Color3.fromRGB(100, 100, 100)},
    {name = "Coal", display = "煤炭", espColor = Color3.fromRGB(0, 0, 0)},
    {name = "Coin Stack", display = "钱堆", espColor = Color3.fromRGB(255, 215, 0)},
    {name = "Fuel Canister", display = "燃料罐", espColor = Color3.fromRGB(255, 50, 50)},
    {name = "Item Chest", display = "宝箱", espColor = Color3.fromRGB(210, 180, 140)},
    {name = "Old Flashlight", display = "手电筒", espColor = Color3.fromRGB(200, 200, 200)},
    {name = "Old Radio", display = "收音机", espColor = Color3.fromRGB(150, 150, 150)},
    {name = "Rifle Ammo", display = "步枪子弹", espColor = Color3.fromRGB(150, 75, 0)},
    {name = "Revolver Ammo", display = "左轮子弹", espColor = Color3.fromRGB(150, 75, 0)},
    {name = "Sheet Metal", display = "金属板", espColor = Color3.fromRGB(192, 192, 192)},
    {name = "Revolver", display = "左轮", espColor = Color3.fromRGB(75, 75, 75)},
    {name = "Rifle", display = "步枪", espColor = Color3.fromRGB(75, 75, 75)},
    {name = "Bandage", display = "绷带", espColor = Color3.fromRGB(255, 240, 245)},
    {name = "Crossbow Cultist", display = "敌人", espColor = Color3.fromRGB(255, 0, 0)},
    {name = "Bear", display = "熊", espColor = Color3.fromRGB(139, 69, 19)},
    {name = "Alpha Wolf", display = "阿尔法狼", espColor = Color3.fromRGB(128, 128, 128)},
    {name = "Wolf", display = "狼", espColor = Color3.fromRGB(192, 192, 192)},
    {name = "Chair", display = "椅子", espColor = Color3.fromRGB(160, 82, 45)},
    {name = "Tyre", display = "轮胎", espColor = Color3.fromRGB(20, 20, 20)},
    {name = "Alien Chest", display = "外星宝箱", espColor = Color3.fromRGB(0, 255, 0)},
    {name = "Leather Body", display = "皮革", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Thorn Body", display = "荆棘铠甲", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Iron Body", display = "铁甲", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Chest", display = "宝箱", espColor = Color3.fromRGB(210, 180, 140)},
    {name = "Lost Child", display = "走失的孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Lost Child1", display = "走失的孩子1", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Lost Child2", display = "走失的孩子2", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Lost Child3", display = "走失的孩子3", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Dino Kid", display = "恐龙孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "kraken kid", display = "海怪孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Squid kid", display = "鱿鱼孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Koala Kid", display = "考拉孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "koala", display = "考拉", espColor = Color3.fromRGB(0, 255, 255)}
}

local teleportItemConfig = {
    {name = "Log", display = "木头", espColor = Color3.fromRGB(139, 69, 19)},
    {name = "Sapling", display = "树苗", espColor = Color3.fromRGB(34, 139, 34)},
    {name = "Morsel", display = "肉", espColor = Color3.fromRGB(240, 128, 128)},
    {name = "Carrot", display = "胡萝卜", espColor = Color3.fromRGB(255, 165, 0)},
    {name = "Berry", display = "浆果", espColor = Color3.fromRGB(255, 0, 0)},
    {name = "Bolt", display = "螺栓", espColor = Color3.fromRGB(255, 255, 0)},
    {name = "Broken Fan", display = "风扇", espColor = Color3.fromRGB(100, 100, 100)},
    {name = "Coal", display = "煤炭", espColor = Color3.fromRGB(0, 0, 0)},
    {name = "Coin Stack", display = "钱堆", espColor = Color3.fromRGB(255, 215, 0)},
    {name = "Fuel Canister", display = "燃料罐", espColor = Color3.fromRGB(255, 50, 50)},
    {name = "Item Chest", display = "宝箱", espColor = Color3.fromRGB(210, 180, 140)},
    {name = "Old Flashlight", display = "手电筒", espColor = Color3.fromRGB(200, 200, 200)},
    {name = "Old Radio", display = "收音机", espColor = Color3.fromRGB(150, 150, 150)},
    {name = "Rifle Ammo", display = "步枪子弹", espColor = Color3.fromRGB(150, 75, 0)},
    {name = "Revolver Ammo", display = "左轮子弹", espColor = Color3.fromRGB(150, 75, 0)},
    {name = "Sheet Metal", display = "金属板", espColor = Color3.fromRGB(192, 192, 192)},
    {name = "Revolver", display = "左轮", espColor = Color3.fromRGB(75, 75, 75)},
    {name = "Rifle", display = "步枪", espColor = Color3.fromRGB(75, 75, 75)},
    {name = "Bandage", display = "绷带", espColor = Color3.fromRGB(255, 240, 245)},
    {name = "Crossbow Cultist", display = "敌人", espColor = Color3.fromRGB(255, 0, 0)},
    {name = "Bear", display = "熊", espColor = Color3.fromRGB(139, 69, 19)},
    {name = "Alpha Wolf", display = "阿尔法狼", espColor = Color3.fromRGB(128, 128, 128)},
    {name = "Wolf", display = "狼", espColor = Color3.fromRGB(192, 192, 192)},
    {name = "Chair", display = "椅子", espColor = Color3.fromRGB(160, 82, 45)},
    {name = "Tyre", display = "轮胎", espColor = Color3.fromRGB(20, 20, 20)},
    {name = "Alien Chest", display = "外星宝箱", espColor = Color3.fromRGB(0, 255, 0)},
    {name = "Leather Body", display = "皮革", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Thorn Body", display = "荆棘铠甲", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Iron Body", display = "铁甲", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Chest", display = "宝箱", espColor = Color3.fromRGB(210, 180, 140)},
    {name = "Lost Child", display = "走失的孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Lost Child1", display = "走失的孩子1", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Lost Child2", display = "走失的孩子2", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Lost Child3", display = "走失的孩子3", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Dino Kid", display = "恐龙孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "kraken kid", display = "海怪孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Squid kid", display = "鱿鱼孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Koala Kid", display = "考拉孩子", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "koala", display = "考拉", espColor = Color3.fromRGB(0, 255, 255)}
}

local collectItemConfig = {
    {name = "Log", display = "木头", espColor = Color3.fromRGB(139, 69, 19)},
    {name = "Sapling", display = "树苗", espColor = Color3.fromRGB(34, 139, 34)},
    {name = "Morsel", display = "肉", espColor = Color3.fromRGB(240, 128, 128)},
    {name = "Carrot", display = "胡萝卜", espColor = Color3.fromRGB(255, 165, 0)},
    {name = "Berry", display = "浆果", espColor = Color3.fromRGB(255, 0, 0)},
    {name = "Bolt", display = "螺栓", espColor = Color3.fromRGB(255, 255, 0)},
    {name = "Broken Fan", display = "风扇", espColor = Color3.fromRGB(100, 100, 100)},
    {name = "Coal", display = "煤炭", espColor = Color3.fromRGB(0, 0, 0)},
    {name = "Coin Stack", display = "钱堆", espColor = Color3.fromRGB(255, 215, 0)},
    {name = "Fuel Canister", display = "燃料罐", espColor = Color3.fromRGB(255, 50, 50)},
    {name = "Item Chest", display = "宝箱", espColor = Color3.fromRGB(210, 180, 140)},
    {name = "Old Flashlight", display = "手电筒", espColor = Color3.fromRGB(200, 200, 200)},
    {name = "Old Radio", display = "收音机", espColor = Color3.fromRGB(150, 150, 150)},
    {name = "Rifle Ammo", display = "步枪子弹", espColor = Color3.fromRGB(150, 75, 0)},
    {name = "Revolver Ammo", display = "左轮子弹", espColor = Color3.fromRGB(150, 75, 0)},
    {name = "Sheet Metal", display = "金属板", espColor = Color3.fromRGB(192, 192, 192)},
    {name = "Revolver", display = "左轮", espColor = Color3.fromRGB(75, 75, 75)},
    {name = "Rifle", display = "步枪", espColor = Color3.fromRGB(75, 75, 75)},
    {name = "Bandage", display = "绷带", espColor = Color3.fromRGB(255, 240, 245)},
    {name = "Chair", display = "椅子", espColor = Color3.fromRGB(160, 82, 45)},
    {name = "Tyre", display = "轮胎", espColor = Color3.fromRGB(20, 20, 20)},
    {name = "Leather Body", display = "皮革", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Thorn Body", display = "荆棘铠甲", espColor = Color3.fromRGB(0, 255, 255)},
    {name = "Iron Body", display = "铁甲", espColor = Color3.fromRGB(0, 255, 255)},
}

local BONFIRE_POSITION = Vector3.new(0.189, 7.831, -0.341)

local originalLighting = {}
local function setFog(enabled)
    if enabled and not originalLighting.FogEnd then
        originalLighting = {
            FogEnd = Lighting.FogEnd, FogStart = Lighting.FogStart, Brightness = Lighting.Brightness,
            Ambient = Lighting.Ambient, ColorShift_Top = Lighting.ColorShift_Top
        }
        Lighting.FogEnd = 100000
        Lighting.FogStart = 0
        Lighting.Brightness = 1
        Lighting.Ambient = Color3.fromRGB(180, 180, 180)
        Lighting.ColorShift_Top = Color3.fromRGB(255, 255, 255)
    elseif not enabled and originalLighting.FogEnd then
        Lighting.FogEnd = originalLighting.FogEnd
        Lighting.FogStart = originalLighting.FogStart
        Lighting.Brightness = originalLighting.Brightness
        Lighting.Ambient = originalLighting.Ambient
        Lighting.ColorShift_Top = originalLighting.ColorShift_Top
        originalLighting = {}
    end
end

local function findItems(itemName)
    local found = {}
    local folders = {"ltems", "Items", "MapItems", "WorldItems"}
    for _, folderName in ipairs(folders) do
        local folder = Workspace:FindFirstChild(folderName)
        if folder then
            for _, item in ipairs(folder:GetDescendants()) do
                if item.Name == itemName and item:IsA("Model") then
                    local primaryPart = item.PrimaryPart or item:FindFirstChild("HumanoidRootPart") or item:FindFirstChild("Handle")
                    if primaryPart then
                        table.insert(found, {model = item, part = primaryPart})
                    end
                end
            end
        end
    end
    return found
end

local function teleportToItem(itemName, displayName)
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then
        WindUI:Notify({ Title = "错误", Text = "角色未准备好", Duration = 2 })
        return
    end
    local items = findItems(itemName)
    if #items == 0 then
        WindUI:Notify({ Title = "提示", Text = "未找到"..displayName, Duration = 2 })
        return
    end
    local closest, minDist = nil, math.huge
    local charPos = Character.HumanoidRootPart.Position
    for _, item in ipairs(items) do
        local dist = (item.part.Position - charPos).Magnitude
        if dist < minDist then
            minDist = dist
            closest = item.part
        end
    end
    if closest then
        Character:MoveTo(closest.Position + Vector3.new(0, 3, 0))
        WindUI:Notify({ Title = "成功", Text = "已传送到"..displayName, Duration = 2 })
    end
end

local function teleportToBonfire()
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then
        WindUI:Notify({ Title = "错误", Text = "角色未准备好", Duration = 2 })
        return
    end
    Character:MoveTo(BONFIRE_POSITION)
    WindUI:Notify({ Title = "成功", Text = "已传送回篝火", Duration = 2 })
end

function collectAndDropLoop(itemName, displayName, quantity)
    local MIN_SEARCH_DISTANCE = 15
    local TELEPORT_VERIFICATION_RANGE = 25

    local rootPart = Character:WaitForChild("HumanoidRootPart")
    local Humanoid = Character:WaitForChild("Humanoid")
    local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
    local initialPosition = rootPart.Position
    local inventory = LP:WaitForChild("Inventory")
    
    local activeSack = nil
    for _, item in ipairs(inventory:GetChildren()) do
        if string.match(item.Name, "Sack$") then
            activeSack = item
            break
        end
    end

    if not activeSack then
        WindUI:Notify({Title = "致命错误", Text = "找不到任何以 'Sack' 结尾的背包", Duration = 4})
        _G.isCollecting = false
        return
    end
    
    WindUI:Notify({Title = "任务开始", Text = "将收集 " .. quantity .. " 个" .. displayName, Duration = 3})

    local function safeTeleport(targetPosition)
        rootPart.CFrame = CFrame.new(targetPosition + Vector3.new(0, 4, 0))
        task.wait(0.1)
        Humanoid.PlatformStand = true
        task.wait(0.1)
        Humanoid.PlatformStand = false
    end

    local function dropItemAfterReturn(itemSample)
        pcall(function()
            if not itemSample or not itemSample.Parent then return end
            local requestBagDrop = RemoteEvents:WaitForChild("RequestBagDropItem")
            requestBagDrop:FireServer(activeSack, itemSample, true)
        end)
    end

    local function pickupItem(itemModelOrPart)
        local wasSuccessful = false
        pcall(function()
            local requestBagStore = RemoteEvents:WaitForChild("RequestBagStoreItem")
            requestBagStore:InvokeServer(activeSack, itemModelOrPart)
            wasSuccessful = true
        end)
        return wasSuccessful
    end

    local function findTargets()
        local allItems = {}
        local foldersToSearch = {Workspace, Workspace:FindFirstChild("Items"), Workspace:FindFirstChild("ltems"), Workspace:FindFirstChild("MapItems")}
        for _, folder in pairs(foldersToSearch) do
            if folder then
                for _, item in ipairs(folder:GetChildren()) do
                    if item.Name == itemName and (item:IsA("Model") or item:IsA("BasePart")) then
                        table.insert(allItems, item)
                    end
                end
            end
        end
        if #allItems == 0 then return nil, nil end
        local closestTarget, minDistance = nil, math.huge
        for _, item in ipairs(allItems) do
            local primaryPart = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item
            if primaryPart then
                local distance = (primaryPart.Position - initialPosition).Magnitude
                if distance < minDistance and distance > MIN_SEARCH_DISTANCE then
                    minDistance = distance
                    closestTarget = item
                end
            end
        end
        local dropSample = nil
        for _, item in ipairs(allItems) do
            if item ~= closestTarget then dropSample = item; break end
        end
        if not dropSample and closestTarget then dropSample = closestTarget
        elseif #allItems > 0 and not dropSample then dropSample = allItems[1] end
        return closestTarget, dropSample
    end

    for i = 1, quantity do
        if not _G.isCollecting then
            WindUI:Notify({Title = "任务中断", Text = "收集任务已被手动停止。", Duration = 3})
            break
        end

        local pickupTarget, dropSample = findTargets()

        if pickupTarget then
            local targetPart = pickupTarget.PrimaryPart or pickupTarget:FindFirstChildWhichIsA("BasePart") or pickupTarget
            
            safeTeleport(targetPart.Position)
            task.wait(0.05)

            local distanceAfterTeleport = (rootPart.Position - targetPart.Position).Magnitude
            if distanceAfterTeleport > TELEPORT_VERIFICATION_RANGE then
                WindUI:Notify({Title = "错误", Text = "传送被服务器拉回！正在返回篝火...", Duration = 4})
                rootPart.CFrame = CFrame.new(BONFIRE_POSITION + Vector3.new(0, 4, 0))
                task.wait(0.2)
                _G.isCollecting = false
                break
            end
            
            local pickupSuccess = pickupItem(pickupTarget)
            
            if pickupSuccess then
                safeTeleport(initialPosition)
                task.wait(0.05)

                local distanceAfterReturn = (rootPart.Position - initialPosition).Magnitude
                if distanceAfterReturn > TELEPORT_VERIFICATION_RANGE then
                    WindUI:Notify({Title = "错误", Text = "返回时被服务器拉回！正在尝试校正位置...", Duration = 4})
                    rootPart.CFrame = CFrame.new(BONFIRE_POSITION + Vector3.new(0, 4, 0))
                    task.wait(0.2)
                    _G.isCollecting = false
                    break
                end

                dropItemAfterReturn(dropSample)
                task.wait(0.05)
            else
                WindUI:Notify({Title = "警告", Text = "拾取失败，跳过当前目标。", Duration = 3})
                task.wait(1)
            end
        else
            WindUI:Notify({Title = "提示", Text = "找不到更多" .. displayName .. "，任务提前结束。", Duration = 4})
            break
        end
    end
    
    if _G.isCollecting then
        WindUI:Notify({Title = "任务完成", Text = "所有收集任务已完成！", Duration = 5})
    end
    _G.isCollecting = false
end

local function toggleESP(itemName, displayName, color)
    local espKey = "ESP_" .. itemName:gsub(" ", "_")
    if getgenv()[espKey] then
        local espData = getgenv()[espKey]
        if espData.guis then
            for _, gui in ipairs(espData.guis) do
                for i, activeGui in ipairs(ActiveESPBillboards) do
                    if activeGui == gui then
                        table.remove(ActiveESPBillboards, i)
                        break
                    end
                end
                if gui and gui.Parent then gui:Destroy() end
            end
        end
        if espData.conn then espData.conn:Disconnect() end
        getgenv()[espKey] = nil
        WindUI:Notify({ Title = "提示", Text = "已关闭"..displayName.."透视", Duration = 2 })
        return
    end

    local items = findItems(itemName)
    getgenv()[espKey] = {guis = {}}

    local function createESP(itemPart)
        if not itemPart or not itemPart:IsDescendantOf(Workspace) then return end
        local billboard = Instance.new("BillboardGui")
        billboard.Adornee = itemPart
        billboard.Size = UDim2.new(0, 100, 0, 40)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = ESPrange
        local text = Instance.new("TextLabel")
        text.Text = displayName
        text.Size = UDim2.new(1, 0, 1, 0)
        text.Font = Enum.Font.GothamBold
        text.TextSize = 18
        text.TextColor3 = color
        text.BackgroundTransparency = 1
        text.TextStrokeTransparency = 0.5
        text.TextStrokeColor3 = Color3.new(0, 0, 0)
        text.Parent = billboard
        billboard.Parent = itemPart
        table.insert(getgenv()[espKey].guis, billboard)
        table.insert(ActiveESPBillboards, billboard)

        local conn = itemPart.AncestryChanged:Connect(function(_, parent)
            if not parent then
                if billboard then billboard:Destroy() end
                if conn then conn:Disconnect() end
            end
        end)
    end

    for _, item in ipairs(items) do createESP(item.part) end

    getgenv()[espKey].conn = Workspace.DescendantAdded:Connect(function(descendant)
        if descendant.Name == itemName and descendant:IsA("Model") then
            local primaryPart = descendant.PrimaryPart or descendant:FindFirstChild("HumanoidRootPart") or descendant:FindFirstChild("Handle")
            if primaryPart then createESP(primaryPart) end
        end
    end)

    WindUI:Notify({ Title = "提示", Text = "已开启"..displayName.."透视 ("..#items.."个)", Duration = 2 })
end

local detectionCircle = Instance.new("Part")
detectionCircle.Name = "AntiDeathCircle"
detectionCircle.Anchored = true
detectionCircle.CanCollide = false
detectionCircle.Transparency = 1 
detectionCircle.Material = Enum.Material.Neon
detectionCircle.Color = Color3.fromRGB(255, 0, 0)
detectionCircle.Parent = Workspace
local mesh = Instance.new("SpecialMesh", detectionCircle)
mesh.MeshType = Enum.MeshType.Cylinder
mesh.Scale = Vector3.new(AntiDeathRadius * 2, 0.2, AntiDeathRadius * 2)

local function updateDetectionCircle()
    local hrp = Character and Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        detectionCircle.Position = Vector3.new(hrp.Position.X, hrp.Position.Y - 3, hrp.Position.Z)
        mesh.Scale = Vector3.new(AntiDeathRadius * 2, 0.2, AntiDeathRadius * 2)
        detectionCircle.Transparency = DistanceAntiDeathEnabled and 0.5 or 1
    else
        detectionCircle.Transparency = 1
    end
end

task.spawn(function()
    while task.wait(0.2) do
        if DistanceAntiDeathEnabled then
            local hrp = Character and Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local pos = hrp.Position
                for _, npc in ipairs(Workspace.Characters:GetChildren()) do
                    if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") and AntiDeathTargets[npc.Name] then
                        local npcPos = npc.HumanoidRootPart.Position
                        if (npcPos - pos).Magnitude <= AntiDeathRadius then
                            teleportToBonfire()
                            break
                        end
                    end
                end
            end
        end
    end
end)

local PlantSettings = {
    Radius = 10,
    Count = 12,
    Delay = 3,
    IsPlanting = false
}

local function getGroundPosition(originPosition)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {game:GetService("Players").LocalPlayer.Character}
    local rayOrigin = originPosition + Vector3.new(0, 100, 0)
    local rayDirection = Vector3.new(0, -200, 0)
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult and raycastResult.Position or (originPosition - Vector3.new(0, 3, 0))
end

local function startPlantingTrees()
    if PlantSettings.IsPlanting then
        WindUI:Notify({ Title = "错误", Text = "已经在种树了！", Duration = 3 })
        return
    end

    PlantSettings.IsPlanting = true
    
    task.spawn(function()
        local TARGET_ITEM_NAME = "Sapling"
        local ITEM_FOLDER_NAME = "Items"
        local RemoteEvents = game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents")
        local itemFolder = workspace:FindFirstChild(ITEM_FOLDER_NAME)

        if not itemFolder then
            WindUI:Notify({ Title = "错误", Text = "找不到物品文件夹 " .. ITEM_FOLDER_NAME, Duration = 3 })
            PlantSettings.IsPlanting = false
            return
        end
        
        WindUI:Notify({ Title = "开始种树", Text = "将在篝火旁种植 " .. PlantSettings.Count .. " 棵树。", Duration = 4 })

        local centerPosition = BONFIRE_POSITION
        local treesPlanted = 0

        for i = 1, PlantSettings.Count do
            local targetItem = itemFolder:FindFirstChild(TARGET_ITEM_NAME)
            
            if not targetItem then
                WindUI:Notify({ Title = "提示", Text = "背包里没有树苗了！", Duration = 3 })
                break
            end

            local angle = (2 * math.pi / PlantSettings.Count) * (i - 1)
            local x_offset = PlantSettings.Radius * math.cos(angle)
            local z_offset = PlantSettings.Radius * math.sin(angle)
            local horizontalTargetPos = centerPosition + Vector3.new(x_offset, 0, z_offset)
            local finalPlantPosition = getGroundPosition(horizontalTargetPos)
            
            pcall(function()
                RemoteEvents.RequestStartDraggingItem:FireServer(targetItem)
                task.wait(0.2)
                RemoteEvents.RequestPlantItem:InvokeServer(targetItem, finalPlantPosition)
                task.wait(0.2)
                RemoteEvents.StopDraggingItem:FireServer(targetItem)
            end)
            
            treesPlanted = i

            if i < PlantSettings.Count then
                task.wait(PlantSettings.Delay)
            end
        end

        WindUI:Notify({ Title = "完成", Text = "种树任务完成，共种植 " .. treesPlanted .. " 棵。", Duration = 3 })
        PlantSettings.IsPlanting = false
    end)
end

local lastKillAura, lastAutoChop, lastGodModeTrigger = 0, 0, 0
local connection
RunService.Heartbeat:Connect(function()
    local now = tick()
    if not Character or not Character:FindFirstChild("HumanoidRootPart") or not Character:FindFirstChildOfClass("Humanoid") then
        Character = LP.Character or LP.CharacterAdded:Wait()
        return
    end
    local humanoid = Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    if humanoid.WalkSpeed ~= CustomWalkSpeed then
        humanoid.WalkSpeed = CustomWalkSpeed
    end

    updateDetectionCircle() 

    if Features.HealthAntiDeathTP and humanoid.Health < AntiDeathHealthThreshold and now - lastAntiDeathTrigger > 5 then
        lastAntiDeathTrigger = now
        WindUI:Notify({ Title = "警告", Text = "血量过低！正在传送回篝火...", Duration = 3 })
        teleportToBonfire()
    end
    
    if Features.GodMode and now - lastGodModeTrigger >= 0.5 then
        lastGodModeTrigger = now
        pcall(function()
            local args = {
                [1] = -math.huge 
            }
            ReplicatedStorage.RemoteEvents.DamagePlayer:FireServer(unpack(args))
        end)
    end

    if Features.InstantInteract then
        if not connection then
            connection = ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
                if prompt then
                    prompt.HoldDuration = 0
                    fireproximityprompt(prompt)
                end
            end)
        end
    else
        if connection then connection:Disconnect(); connection = nil end
    end

    if Features.KillAura and now - lastKillAura >= 0.7 then
        lastKillAura = now
        if Character:FindFirstChild("ToolHandle") then
            local tool = Character.ToolHandle.OriginalItem.Value
            if tool and ({["Old Axe"] = true, ["Good Axe"] = true, ["Spear"] = true, ["Hatchet"] = true, ["Bone Club"] = true})[tool.Name] then
                for _, target in next, Workspace.Characters:GetChildren() do
                    if target:IsA("Model") and target:FindFirstChild("HumanoidRootPart") and target:FindFirstChild("HitRegisters") then
                        if (Character.HumanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude <= 100 then
                            ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("ToolDamageObject"):InvokeServer(target, tool, true, Character.HumanoidRootPart.CFrame)
                        end
                    end
                end
            end
        end
    end

    if Features.AutoChop and now - lastAutoChop >= 0.1 then 
        lastAutoChop = now
        local hrp = Character:WaitForChild("HumanoidRootPart")
        local weapon = (LP.Inventory:FindFirstChild("Old Axe") or LP.Inventory:FindFirstChild("Good Axe") or LP.Inventory:FindFirstChild("Strong Axe") or LP.Inventory:FindFirstChild("Chainsaw"))
        if weapon then
            local function ChopTree(path)
                for _, tree in pairs(path:GetChildren()) do
                    if tree:IsA("Model") and (tree.Name == "Small Tree" or tree.Name == "TreeBig1" or tree.Name == "TreeBig2") and tree.PrimaryPart then
                        local distance = (tree.PrimaryPart.Position - hrp.Position).Magnitude
                        if distance <= DistanceForAutoChopTree then
                            ReplicatedStorage.RemoteEvents.ToolDamageObject:InvokeServer(tree, weapon, 999, hrp.CFrame)
                        end
                    end
                end
            end
            ChopTree(Workspace.Map.Foliage)
            ChopTree(Workspace.Map.Landmarks)
        end
    end

end)

local PlayerList = {}
local function UpdatePlayerList()
    PlayerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(PlayerList, player.Name)
    end
    if WindUI and WindUI.flags and WindUI.flags["Player_Teleport"] then
        WindUI.flags["Player_Teleport"]:SetOptions(PlayerList)
    end
end
Players.PlayerAdded:Connect(UpdatePlayerList)
Players.PlayerRemoving:Connect(UpdatePlayerList)

local MainTab = Window:Tab({
    Title = "主要功能",
    Icon = "home"
})

MainTab:Button({
    Title = "注意: 自动功能需要装备对应工具",
    Callback = function() end
})

MainTab:Toggle({
    Title = "杀戮光环 (范围固定)",
    Description = "Kill_Aura",
    Callback = function(value)
        Features.KillAura = value
        WindUI:Notify({ Title = "提示", Text = value and "已开启杀戮光环" or "已关闭杀戮光环", Duration = 2 })
    end
})

MainTab:Toggle({
    Title = "锁血 (God Mode)",
    Description = "God_Mode",
    Callback = function(value)
        Features.GodMode = value
        WindUI:Notify({ Title = "提示", Text = value and "已开启锁血" or "已关闭锁血", Duration = 2 })
    end
})

MainTab:Slider({
    Title = "自动砍树范围 (米)",
    Description = "Auto_Chop_Distance",
    Min = 25,
    Max = 500,
    Default = 25,
    Callback = function(value)
        DistanceForAutoChopTree = value
    end
})

MainTab:Toggle({
    Title = "自动砍树",
    Description = "Auto_Chop_Toggle",
    Callback = function(value)
        Features.AutoChop = value
        WindUI:Notify({ Title = "提示", Text = value and "已开启自动砍树" or "已关闭自动砍树", Duration = 2 })
    end
})

MainTab:Toggle({
    Title = "瞬间互动",
    Description = "Instant_Interact",
    Callback = function(value)
        Features.InstantInteract = value
        WindUI:Notify({ Title = "提示", Text = value and "已开启瞬间互动" or "已关闭瞬间互动", Duration = 2 })
    end
})

MainTab:Slider({
    Title = "移动速度",
    Description = "walk_speed",
    Min = 16,
    Max = 200,
    Default = 16,
    Callback = function(value)
        CustomWalkSpeed = value
        WindUI:Notify({
            Title = "设置更新",
            Text = "移动速度已设置为: " .. value,
            Duration = 2
        })
    end
})

MainTab:Toggle({
    Title = "防死传送(低血量)",
    Description = "Health_AntiDeath_TP",
    Callback = function(value)
        Features.HealthAntiDeathTP = value
        WindUI:Notify({ Title = "提示", Text = value and "已开启低血量防死传送" or "已关闭低血量防死传送", Duration = 2 })
    end
})

MainTab:Toggle({
    Title = "去除迷雾",
    Description = "No_Fog",
    Callback = function(value)
        Features.NoFog = value
        setFog(value)
        WindUI:Notify({ Title = "提示", Text = value and "已去除迷雾" or "已恢复迷雾", Duration = 2 })
    end
})

MainTab:Button({
    Title = "传送回篝火",
    Callback = teleportToBonfire
})

local ESPTab = Window:Tab({
    Title = "物品透视",
    Icon = "visibility"
})

ESPTab:Slider({
    Title = "透视范围 (米)",
    Description = "ESP_Range",
    Min = 50,
    Max = 1000,
    Default = 150,
    Callback = function(value)
        ESPrange = value
        for _, billboard in ipairs(ActiveESPBillboards) do
            if billboard and billboard.Parent then
                billboard.MaxDistance = ESPrange
            end
        end
    end
})

for _, item in ipairs(espItemConfig) do
    ESPTab:Button({
        Title = item.display.."透视",
        Callback = function() 
            toggleESP(item.name, item.display, item.espColor) 
        end
    })
end

local TeleportTab = Window:Tab({
    Title = "传送功能",
    Icon = "send"
})

UpdatePlayerList()

TeleportTab:Dropdown({
    Title = "选择玩家",
    Description = "Player_Teleport",
    Values = PlayerList,
    Callback = function(selected)
        local target = Players[selected]
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            Character:PivotTo(target.Character.HumanoidRootPart.CFrame)
            WindUI:Notify({ Title = "成功", Text = "已传送到玩家 "..selected, Duration = 2 })
        else
            WindUI:Notify({ Title = "错误", Text = "无法传送到该玩家", Duration = 2 })
        end
    end
})

for _, item in ipairs(teleportItemConfig) do
    TeleportTab:Button({
        Title = "传送到"..item.display,
        Callback = function()
            teleportToItem(item.name, item.display)
        end
    })
end

local CollectTab = Window:Tab({
    Title = "收集功能",
    Icon = "inventory"
})

CollectTab:Button({
    Title = "停止当前收集任务",
    Callback = function()
        if _G.isCollecting then
            _G.isCollecting = false
            WindUI:Notify({Title = "操作成功", Text = "收集任务将在当前循环结束后停止。", Duration = 3})
        else
            WindUI:Notify({Title = "提示", Text = "当前没有正在运行的收集任务。", Duration = 3})
        end
    end
})

CollectTab:Input({
    Title = "自定义收集数量",
    Default = "10",
    Placeholder = "输入数量",
    Callback = function(text)
        local num = tonumber(text)
        if num and num > 0 then
            collectQuantity = math.floor(num)
            WindUI:Notify({Title = "设置成功", Text = "下次收集数量已设为: " .. collectQuantity, Duration = 3})
        else
            WindUI:Notify({Title = "输入错误", Text = "请输入一个有效的正整数。", Duration = 3})
        end
    end
})

for _, item in ipairs(collectItemConfig) do
    CollectTab:Button({
        Title = "循环收集: "..item.display,
        Callback = function()
            if _G.isCollecting then
                WindUI:Notify({Title = "错误", Text = "已有收集任务在运行！请先停止。", Duration = 3})
                return
            end
            _G.isCollecting = true
            task.spawn(function()
                collectAndDropLoop(item.name, item.display, collectQuantity)
            end)
        end
    })
end

local PlantTab = Window:Tab({
    Title = "自动种树",
    Icon = "park"
})

PlantTab:Button({
    Title = "在篝火周围种树 (需要有树苗)",
    Callback = function() end
})

PlantTab:Slider({
    Title = "种植半径 (米)",
    Description = "Plant_Radius",
    Min = 5,
    Max = 50,
    Default = 10,
    Callback = function(value)
        PlantSettings.Radius = value
    end
})

PlantTab:Slider({
    Title = "种植数量 (棵)",
    Description = "Plant_Count",
    Min = 1,
    Max = 50,
    Default = 12,
    Callback = function(value)
        PlantSettings.Count = value
    end
})

PlantTab:Slider({
    Title = "种植间隔 (秒)",
    Description = "Plant_Delay",
    Min = 0.5,
    Max = 10,
    Default = 3,
    Callback = function(value)
        PlantSettings.Delay = value
    end
})

PlantTab:Button({
    Title = "开始种树",
    Callback = startPlantingTrees
})

local AntiDeathTab = Window:Tab({
    Title = "防死设置",
    Icon = "security"
})

AntiDeathTab:Button({
    Title = "基于距离的防死设置",
    Callback = function() end
})

AntiDeathTab:Toggle({
    Title = "敌人靠近时传送",
    Description = "Distance_AntiDeath_Toggle",
    Callback = function(value)
        DistanceAntiDeathEnabled = value
        WindUI:Notify({ Title = "提示", Text = "敌人靠近传送已" .. (value and "开启" or "关闭"), Duration = 2 })
    end
})

AntiDeathTab:Slider({
    Title = "检测半径 (米)",
    Description = "AntiDeath_Radius",
    Min = 10,
    Max = 150,
    Default = 50,
    Callback = function(value)
        AntiDeathRadius = value
    end
})

AntiDeathTab:Button({
    Title = "要规避的敌人列表",
    Callback = function() end
})

for npcName, _ in pairs(AntiDeathTargets) do
    AntiDeathTab:Toggle({
        Title = "规避 " .. npcName,
        Description = "Avoid_"..npcName:gsub(" ", "_"),
        Default = true,
        Callback = function(value)
            AntiDeathTargets[npcName] = value or nil
        end
    })
end

local SettingsTab = Window:Tab({
    Title = "设置",
    Icon = "settings"
})

SettingsTab:Slider({
    Title = "低血量防死阈值",
    Description = "AntiDeath_Threshold",
    Min = 10,
    Max = 90,
    Default = 20,
    Callback = function(value)
        AntiDeathHealthThreshold = value
        WindUI:Notify({ Title = "设置", Text = "低血量防死阈值已设置为: " .. value, Duration = 2 })
    end
})

SettingsTab:Button({
    Title = "清除所有透视",
    Callback = ClearAllESP
})

WindUI:Notify({
    Title = "欢迎使用YG SCRIPT",
    Text = "祝您游戏愉快！",
    Duration = 5
})

if setclipboard then
    setclipboard("276209873")
    WindUI:Notify({
        Title = "提示",
        Text = "已自动复制交流群号:1015718032",
        Duration = 5
    })
end

-- ========== 窗口关闭处理 ==========
Window:OnClose(function()
    if rainbowBorderAnimation then
        rainbowBorderAnimation:Disconnect()
        rainbowBorderAnimation = nil
    end
end)

Window:OnDestroy(function()
    if rainbowBorderAnimation then
        rainbowBorderAnimation:Disconnect()
        rainbowBorderAnimation = nil
    end
    for _, animation in pairs(fontColorAnimations or {}) do
        animation:Disconnect()
    end
    fontColorAnimations = {}
end)

WindUI:Notify({ 
    Title = "YG付费版", 
    Content = "已全部加载",
    Duration = 5,
    Icon = "check-circle"
})
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})

local MyButton = LeftGroupBox:AddButton({
    Text = '终极战场',---服务器名称
    Func = function()
    local originalUI = Library
        
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Potato5466794/New/refs/heads/main/Library%E2%80%93ZeroXNOL.lua"))()
local Window = WindUI:CreateWindow({
    Title = "YG SCRIPT",
    Icon = "star",
    Author = "终极战场",
    Folder = "CloudHub",
    Size = UDim2.fromOffset(500, 400),
    Transparent = true,
    Theme = "Light",
    User = {
        Enabled = true,
        Callback = function() print("联邦全体傻逼") end,
        Anonymous = false
    },
    SideBarWidth = 200,
    ScrollBarEnabled = true
})

local TimeTag = Window:Tag({
    Title = "--:--",
    Radius = 999,
    Color = Color3.fromRGB(255, 255, 255),
})

task.spawn(function()
	while true do
		local now = os.date("*t")
		local hours = string.format("%02d", now.hour)
		local minutes = string.format("%02d", now.min)
		
		TimeTag:SetTitle(hours .. ":" .. minutes)
		task.wait(0.06)
	end
end)
local Tab = Window:Tab({
    Title = "主要功能",
    Icon = "sword",
    Locked = false,
})

Tab:Button({
    Flag = "1",
    Title = "篡改",
    Desc = "玩的时候第一先开启这个功能",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/dream77239/ubg-script/refs/heads/main/%E6%8B%A6%E6%88%AA.txt"))()
    end
})

local fakeBlockEnabled = false
local loopRunning = false
Tab:Toggle({
    Flag = "2",
    Title = "假防(关闭功能后按一次防御即可取消假防)",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("假防") else RemoveFromArrayList("假防") end
        fakeBlockEnabled = state

        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local BlockRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("Block")
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        local function enableBlock()
            pcall(function()
                BlockRemote:FireServer(true)
            end)
        end

        if fakeBlockEnabled then
            enableBlock()
        end

        if not loopRunning then
            loopRunning = true
            task.spawn(function()
                while true do
                    task.wait(0.01)
                    if fakeBlockEnabled then
                        local success, isBlocking = pcall(function()
                            return character:GetAttribute("IsBlocking")
                        end)
                        if success and not isBlocking then
                            enableBlock()
                        end
                    end
                end
            end)
        end
    end
})

local defaultCooldown = game:GetService("ReplicatedStorage").Settings.Cooldowns.Dash.Value

Tab:Toggle({
    Flag = "3",
    Title = "侧闪无冷却",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("侧闪无冷却") else RemoveFromArrayList("侧闪无冷却") end
        local dashCooldown = game:GetService("ReplicatedStorage").Settings.Cooldowns.Dash
        if state then
            dashCooldown.Value = 1
        else
            dashCooldown.Value = defaultCooldown
        end
    end
})
local defaultMeleeCooldown = game:GetService("ReplicatedStorage").Settings.Cooldowns.Melee.Value

Tab:Toggle({
    Flag = "4",
    Title = "近战无冷却",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("近战无冷却") else RemoveFromArrayList("近战无冷却") end
        local meleeCooldown = game:GetService("ReplicatedStorage").Settings.Cooldowns.Melee
        if state then
            meleeCooldown.Value = 1
        else
            meleeCooldown.Value = defaultMeleeCooldown
        end
    end
})
local rs = game:GetService("ReplicatedStorage")
local settings = rs.Settings

local defaultAbility = settings.Cooldowns.Ability.Value
Tab:Toggle({
    Flag = "5",
    Title = "技能无冷却(仅宿傩角色)",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("技能无冷却") else RemoveFromArrayList("技能无冷却") end
        settings.Cooldowns.Ability.Value = state and 1 or defaultAbility
    end
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage.Remotes
local Combat = Remotes.Combat
local EmoteClaim = Combat.EmoteClaim

local emoteClaimActive = false
local emoteClaimConnection = nil

local function startEmoteClaim()
    emoteClaimConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if emoteClaimActive then
            EmoteClaim:FireServer()
        end
    end)
end

local function stopEmoteClaim()
    if emoteClaimConnection then
        emoteClaimConnection:Disconnect()
        emoteClaimConnection = nil
    end
end

Tab:Toggle({
    Flag = "6",
    Title = "自动签到表情",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("自动签到表情") else RemoveFromArrayList("自动签到表情") end
        emoteClaimActive = state
        if state then
            startEmoteClaim()
        else
            stopEmoteClaim()
        end
    end
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local noSlowdownsToggle = ReplicatedStorage.Settings.Toggles.NoSlowdowns

local defaultValue = false

Tab:Toggle({
    Flag = "7",
    Title = "无减速效果",
    Value = noSlowdownsToggle.Value,
    Callback = function(state)
        if state then AddToArrayList("无减速") else RemoveFromArrayList("无减速") end
        if state then
            noSlowdownsToggle.Value = true
        else
            noSlowdownsToggle.Value = defaultValue
        end
    end
})

local defaultDisableHitStun = settings.Toggles.DisableHitStun.Value
Tab:Toggle({
    Flag = "8",
    Title = "取消被攻击硬直",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("取消硬直") else RemoveFromArrayList("取消硬直") end
        settings.Toggles.DisableHitStun.Value = state
    end
})

local defaultDisableIntros = settings.Toggles.DisableIntros.Value
Tab:Toggle({
    Flag = "9",
    Title = "跳过角色开场动作",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("跳过开场") else RemoveFromArrayList("跳过开场") end
        settings.Toggles.DisableIntros.Value = state
    end
})

local defaultNoStunOnMiss = settings.Toggles.NoStunOnMiss.Value
Tab:Toggle({
    Flag = "10",
    Title = "普攻无僵直",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("普攻无僵直") else RemoveFromArrayList("普攻无僵直") end
        settings.Toggles.NoStunOnMiss.Value = state
    end
})

local defaultRagdollTimer = settings.Multipliers.RagdollTimer.Value
Tab:Toggle({
    Flag = "11",
    Title = "被别人击倒不会变成布娃娃",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("防布娃娃") else RemoveFromArrayList("防布娃娃") end
        settings.Multipliers.RagdollTimer.Value = state and 0.5 or defaultRagdollTimer
    end
})

local defaultUltimateTimer = settings.Multipliers.UltimateTimer.Value
Tab:Toggle({
    Flag = "12",
    Title = "延长大招时间",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("无限大招") else RemoveFromArrayList("无限大招") end
        settings.Multipliers.UltimateTimer.Value = state and 100000 or defaultUltimateTimer
    end
})

local defaultInstantTransformation = settings.Toggles.InstantTransformation.Value
Tab:Toggle({
    Flag = "13",
    Title = "秒开大",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("秒开大") else RemoveFromArrayList("秒开大") end
        settings.Toggles.InstantTransformation.Value = state
    end
})
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local Ping = player:WaitForChild("Info"):WaitForChild("Ping")

local loop

Tab:Toggle({
    Flag = "14",
    Title = "ping乱码",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("Ping乱码") else RemoveFromArrayList("Ping乱码") end
        if state then
            loop = task.spawn(function()
                while state do
                    for i = 0, 999, 25 do
                        if not state then break end
                        Ping.Value = i
                        task.wait(0.03)
                    end
                    for i = 999, 0, -25 do
                        if not state then break end
                        Ping.Value = i
                        task.wait(0.03)
                    end
                end
            end)
        else
            if loop then
                task.cancel(loop)
                loop = nil
            end
        end
    end
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MeleeDamage = ReplicatedStorage:WaitForChild("Settings"):WaitForChild("Multipliers"):WaitForChild("MeleeDamage")

MeleeDamage.Value = 100

Tab:Toggle({
    Flag = "15",
    Title = "一拳倒地",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("一拳倒地") else RemoveFromArrayList("一拳倒地") end
        if state then
            MeleeDamage.Value = 1000000
        else
            MeleeDamage.Value = 100
        end
    end
})
Tab:Toggle({
    Flag = "16",
    Title = "一拳击飞",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("一拳击飞") else RemoveFromArrayList("一拳击飞") end
        local Players = game:GetService("Players")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")

        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

        local RagdollPower = ReplicatedStorage:WaitForChild("Settings"):WaitForChild("Multipliers"):WaitForChild("RagdollPower")

        local maxTeleportDistance = 50
        local lastPosition = HumanoidRootPart.Position
        local connection

        if state then
            RagdollPower.Value = 10000

            connection = RunService.RenderStepped:Connect(function()
                
                if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
                    lastPosition = HumanoidRootPart.Position
                end

                local currentPos = HumanoidRootPart.Position
                local distance = (currentPos - lastPosition).Magnitude

                if distance > maxTeleportDistance then
                    HumanoidRootPart.CFrame = CFrame.new(lastPosition)
                else
                    lastPosition = currentPos
                end
            end)
        else
            RagdollPower.Value = 100
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local wallCombo = ReplicatedStorage.Settings.Cooldowns.WallCombo

Tab:Toggle({
    Flag = "17",
    Title = "墙打无冷却",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("墙打无冷却") else RemoveFromArrayList("墙打无冷却") end
        if state then
            wallCombo.Value = 0
            print("WallCombo cooldown set to 0")
        else
            wallCombo.Value = 100
            print("WallCombo cooldown reset to 100")
        end
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local wall = nil
pcall(function()
    wall = workspace.Map.Structural.Terrain:GetChildren()[5]:GetChildren()[12]
end)

if not wall then
    wall = Instance.new("Part")
    wall.Parent = workspace
end

wall.Size = Vector3.new(12,6,2)
wall.Transparency = 0.6
wall.Material = Enum.Material.SmoothPlastic
wall.Anchored = true
wall.CanCollide = true
wall.CFrame = wall.CFrame or CFrame.new(0,5,0)

if getconnections then
    for _, conn in pairs(getconnections(wall.AncestryChanged)) do
        conn:Disable()
    end
end

local mt = getrawmetatable(game)
setreadonly(mt,false)
local old = mt.__namecall
mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    if self == wall and method == "Destroy" then
        return
    end
    return old(self, ...)
end)
setreadonly(mt,true)

local followConnection = nil
Tab:Toggle({
    Flag = "18",
    Title = "随处墙打",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("随处墙打") else RemoveFromArrayList("随处墙打") end
        if state then
            if not followConnection then
                followConnection = RunService.RenderStepped:Connect(function()
                    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        wall.CFrame = hrp.CFrame * CFrame.new(0,0,-8)
                    end
                end)
            end
        else
            if followConnection then
                followConnection:Disconnect()
                followConnection = nil
            end
        end
    end
})
local originalData = {}
local skyBackup = nil

Tab:Toggle({
    Flag = "19",
    Title = "防卡",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("防卡") else RemoveFromArrayList("防卡") end
        if state then
            originalData = {}
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") or v:IsA("Explosion") then
                    originalData[v] = v.Enabled
                    v.Enabled = false
                elseif v:IsA("Decal") or v:IsA("Texture") then
                    originalData[v] = v.Transparency
                    v.Transparency = 1
                elseif v:IsA("MeshPart") or v:IsA("UnionOperation") or v:IsA("Part") then
                    if v.Name ~= "HumanoidRootPart" then
                        originalData[v] = v.Material
                        v.Material = Enum.Material.SmoothPlastic
                    end
                elseif v:IsA("SurfaceGui") or v:IsA("BillboardGui") or v:IsA("Beam") then
                    if v:IsA("Beam") then
                        originalData[v] = v.Enabled
                        v.Enabled = false
                    else
                        originalData[v] = v.Enabled ~= nil and v.Enabled or true
                        if v.Enabled ~= nil then
                            v.Enabled = false
                        end
                    end
                end
            end
            originalData["GlobalShadows"] = game.Lighting.GlobalShadows
            originalData["FogEnd"] = game.Lighting.FogEnd
            game.Lighting.GlobalShadows = false
            game.Lighting.FogEnd = 9e9
            local sky = game.Lighting:FindFirstChildOfClass("Sky")
            if sky then
                skyBackup = sky:Clone()
                sky:Destroy()
            end
            local newSky = Instance.new("Sky")
            newSky.SkyboxBk = ""
            newSky.SkyboxDn = ""
            newSky.SkyboxFt = ""
            newSky.SkyboxLf = ""
            newSky.SkyboxRt = ""
            newSky.SkyboxUp = ""
            newSky.SunAngularSize = 0
            newSky.MoonAngularSize = 0
            newSky.Parent = game.Lighting
            game.Lighting.Ambient = Color3.fromRGB(128,128,128)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(128,128,128)
        else
            for obj, value in pairs(originalData) do
                if typeof(obj) == "Instance" and obj.Parent then
                    if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Explosion") then
                        obj.Enabled = value
                    elseif obj:IsA("Decal") or obj:IsA("Texture") then
                        obj.Transparency = value
                    elseif obj:IsA("MeshPart") or obj:IsA("UnionOperation") or obj:IsA("Part") then
                        obj.Material = value
                    elseif obj:IsA("SurfaceGui") or obj:IsA("BillboardGui") or obj:IsA("Beam") then
                        if obj:IsA("Beam") then
                            obj.Enabled = value
                        elseif obj.Enabled ~= nil then
                            obj.Enabled = value
                        end
                    end
                elseif obj == "GlobalShadows" then
                    game.Lighting.GlobalShadows = value
                elseif obj == "FogEnd" then
                    game.Lighting.FogEnd = value
                end
            end
            if skyBackup then
                local currentSky = game.Lighting:FindFirstChildOfClass("Sky")
                if currentSky then
                    currentSky:Destroy()
                end
                skyBackup.Parent = game.Lighting
                skyBackup = nil
            end
            originalData = {}
        end
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Camera = workspace.CurrentCamera

local clone, platform, originalCFrame, originalCameraSubject

local function CreatePlatform(position)
    local part = Instance.new("Part")
    part.Size = Vector3.new(10, 1, 10)
    part.Position = position - Vector3.new(0, 3, 0)
    part.Anchored = true
    part.CanCollide = true
    part.Transparency = 0.5
    part.Parent = workspace
    return part
end

local function CreateClone()
    local newClone = Character:Clone()
    for _, v in ipairs(newClone:GetDescendants()) do
        if v:IsA("BasePart") then
            v.Transparency = 0.5
        end
    end
    newClone.Parent = workspace
    return newClone
end

local function ToggleInvisibility(state)
    if state then
        originalCFrame = HumanoidRootPart.CFrame
        HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + Vector3.new(0, -50, 0)
        platform = CreatePlatform(HumanoidRootPart.Position)
        
        task.wait(1)
        
        clone = CreateClone()
        clone:MoveTo(originalCFrame.Position)
        Camera.CameraSubject = clone:FindFirstChildWhichIsA("Humanoid")
        LocalPlayer.Character = clone
    else
        if clone then
            clone:Destroy()
            clone = nil
        end
        
        if platform then
            platform:Destroy()
            platform = nil
        end
        
        if originalCFrame then
            HumanoidRootPart.CFrame = originalCFrame
            originalCFrame = nil
        end
        
        Camera.CameraSubject = Character:FindFirstChildWhichIsA("Humanoid")
        LocalPlayer.Character = Character
    end
end

Tab:Toggle({
    Flag = "20",
    Title = "隐身",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("隐身") else RemoveFromArrayList("隐身") end
        ToggleInvisibility(state)
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local CircleParts = {}
local Connection

local function RainbowColor(t)
    local r = math.sin(t) * 40 + 180
    local g = math.sin(t + 2) * 40 + 180
    local b = math.sin(t + 4) * 40 + 180
    return Color3.fromRGB(r, g, b)
end

Tab:Toggle({
    Flag = "27",
    Title = "墙打/杀戮光环范围显示",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("范围显示") else RemoveFromArrayList("范围显示") end
        local function CreateCircle(radius, segments, thickness)
            local parts = {}
            for i = 1, segments do
                local part = Instance.new("Part")
                part.Anchored = true
                part.CanCollide = false
                part.Material = Enum.Material.Neon
                part.Size = Vector3.new(thickness, 0.2, radius * 2 * math.pi / segments)
                part.Color = Color3.fromRGB(180,180,180)
                part.Parent = workspace
                table.insert(parts, part)
            end
            return parts
        end

        local function DestroyCircle()
            if Connection then
                Connection:Disconnect()
                Connection = nil
            end
            for _, part in ipairs(CircleParts) do
                if part and part.Parent then
                    part:Destroy()
                end
            end
            CircleParts = {}
        end

        if state then
            DestroyCircle()
            local radius = 60
            local segments = 60
            local thickness = 0.2
            CircleParts = CreateCircle(radius, segments, thickness)

            local time = 0
            local updateAccumulator = 0
            local updateRate = 1/60

            Connection = RunService.RenderStepped:Connect(function(dt)
                time = time + dt
                updateAccumulator = updateAccumulator + dt
                if updateAccumulator < updateRate then return end
                updateAccumulator = 0

                local char = LocalPlayer.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    local rootPos = char.HumanoidRootPart.Position
                    local humanoid = char:FindFirstChild("Humanoid")
                    local heightOffset = humanoid and humanoid.HipHeight / 2 + 0.1 or 0.9 
                    local pos = rootPos - Vector3.new(0, heightOffset, 0)

                    for i, part in ipairs(CircleParts) do
                        local angle = (i / #CircleParts) * 2 * math.pi
                        local x = pos.X + math.cos(angle) * radius
                        local z = pos.Z + math.sin(angle) * radius
                        part.Position = Vector3.new(x, pos.Y, z)
                        part.Orientation = Vector3.new(0, -math.deg(angle), 0)
                        part.Color = RainbowColor(time + i * 0.1)
                    end
                end
            end)
        else
            DestroyCircle()
        end
    end
})

Tab:Button({
    Flag = "28",
    Title = "删除墙打特效",
    Desc = "点了该功能就无法恢复墙打特效",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local paths = {
            ReplicatedStorage.Characters.Gon.WallCombo.GonWallCombo.Center,
            ReplicatedStorage.Characters.Gon.WallCombo.GonWallCombo.Explosion,
            ReplicatedStorage.Characters.Gon.WallCombo.GonIntroHands,
            ReplicatedStorage.Characters.Mob.WallCombo.MobWallCombo.Center,
            ReplicatedStorage.Characters.Nanami.WallCombo.NanamiWallCombo.Center,
            ReplicatedStorage.Characters.Stark.WallCombo.StarkWallCombo.Center,
            ReplicatedStorage.Characters.Sukuna.WallCombo.SukunaTransformWallCombo,
            ReplicatedStorage.Characters.Sukuna.WallCombo.SukunaWallCombo
        }

        for _, obj in ipairs(paths) do
            if obj and obj:IsA("Instance") then
                for _, child in ipairs(obj:GetChildren()) do
                    child:Destroy()
                end
            end
        end
    end
})
Tab:Button({
    Flag = "29",
    Title = "删除击杀表情特效",
    Desc = "点击删除击杀表情的部分特效,不可恢复",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local KillEmote = ReplicatedStorage:WaitForChild("Cosmetics"):WaitForChild("KillEmote")

        local function removeEffects(obj)
            for _, child in ipairs(obj:GetChildren()) do
                if child:IsA("ParticleEmitter") 
                or child:IsA("Trail") 
                or child:IsA("Beam") 
                or child:IsA("Fire") 
                or child:IsA("Smoke") 
                or child:IsA("Sparkles") 
                or child:IsA("Light") then
                    child:Destroy()
                else
                    removeEffects(child)
                end
            end
        end

        removeEffects(KillEmote)
        print("KillEmote 特效已删除（保留本体）")
    end
})
 local ReplicatedStorage = game:GetService("ReplicatedStorage")
local multiUseCutscenesToggle = ReplicatedStorage.Settings.Toggles.MultiUseCutscenes

local defaultValue = false

Tab:Toggle({
    Flag = "30",
    Title = "艾斯帕大招技能多次使用(全角色通用)",
    Value = multiUseCutscenesToggle.Value,
    Callback = function(state)
        if state then AddToArrayList("大招多次使用") else RemoveFromArrayList("大招多次使用") end
        if state then
            multiUseCutscenesToggle.Value = true
        else
            multiUseCutscenesToggle.Value = defaultValue
        end
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local QEfly = true

local FLYING = false
local flyKeyDown, flyKeyUp, mobileFlyConn
local iyflyspeed = 2
local vehicleflyspeed = 2

local function getRoot(char)
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
end

local function NOFLY()
    FLYING = false
    if flyKeyDown then flyKeyDown:Disconnect() flyKeyDown = nil end
    if flyKeyUp then flyKeyUp:Disconnect() flyKeyUp = nil end
    if mobileFlyConn then mobileFlyConn:Disconnect() mobileFlyConn = nil end
    local char = LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        local root = getRoot(char)
        if humanoid then humanoid.PlatformStand = false end
        for _, v in pairs(root:GetChildren()) do
            if v:IsA("BodyGyro") or v:IsA("BodyVelocity") then
                v:Destroy()
            end
        end
    end
    pcall(function()
        workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    end)
end

local function sFLY(vfly)
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
    local root = getRoot(char)

    if flyKeyDown then flyKeyDown:Disconnect() end
    if flyKeyUp then flyKeyUp:Disconnect() end
    if mobileFlyConn then mobileFlyConn:Disconnect() end

    local CONTROL = {F=0,B=0,L=0,R=0,Q=0,E=0}

    local BG = Instance.new("BodyGyro")
    local BV = Instance.new("BodyVelocity")
    BG.P = 9e4
    BG.MaxTorque = Vector3.new(9e9,9e9,9e9)
    BG.CFrame = root.CFrame
    BG.Parent = root
    BV.MaxForce = Vector3.new(9e9,9e9,9e9)
    BV.Velocity = Vector3.new(0,0,0)
    BV.Parent = root

    FLYING = true

    flyKeyDown = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            if input.KeyCode == Enum.KeyCode.W then CONTROL.F = iyflyspeed end
            if input.KeyCode == Enum.KeyCode.S then CONTROL.B = -iyflyspeed end
            if input.KeyCode == Enum.KeyCode.A then CONTROL.L = -iyflyspeed end
            if input.KeyCode == Enum.KeyCode.D then CONTROL.R = iyflyspeed end
            if input.KeyCode == Enum.KeyCode.E and QEfly then CONTROL.Q = iyflyspeed*2 end
            if input.KeyCode == Enum.KeyCode.Q and QEfly then CONTROL.E = -iyflyspeed*2 end
        end
    end)

    flyKeyUp = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            if input.KeyCode == Enum.KeyCode.W then CONTROL.F = 0 end
            if input.KeyCode == Enum.KeyCode.S then CONTROL.B = 0 end
            if input.KeyCode == Enum.KeyCode.A then CONTROL.L = 0 end
            if input.KeyCode == Enum.KeyCode.D then CONTROL.R = 0 end
            if input.KeyCode == Enum.KeyCode.E then CONTROL.Q = 0 end
            if input.KeyCode == Enum.KeyCode.Q then CONTROL.E = 0 end
        end
    end)

    mobileFlyConn = RunService.RenderStepped:Connect(function()
        if not FLYING then return end
        local camera = workspace.CurrentCamera
        local moveVector = Vector3.new(CONTROL.L+CONTROL.R, CONTROL.Q+CONTROL.E, CONTROL.F+CONTROL.B)

        local ok, controlModule = pcall(function()
            return require(LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
        end)
        if ok and controlModule then
            local mv = controlModule:GetMoveVector()
            moveVector = Vector3.new(mv.X*(vfly and vehicleflyspeed or iyflyspeed), moveVector.Y, -mv.Z*(vfly and vehicleflyspeed or iyflyspeed))
        end

        BV.Velocity = (camera.CFrame.RightVector*moveVector.X + Vector3.new(0,moveVector.Y,0) + camera.CFrame.LookVector*moveVector.Z)*50
        BG.CFrame = camera.CFrame
        humanoid.PlatformStand = true
    end)
end

local function applyFly()
    sFLY()
    LocalPlayer.CharacterAdded:Connect(function()
        if FLY_TOGGLE_STATE then
            task.wait(0.5)
            sFLY()
        end
    end)
end

local FLY_TOGGLE_STATE = false

Tab:Toggle({
    Flag = "31",
    Title = "飞行",
    Value = false,
    Callback = function(state)
        FLY_TOGGLE_STATE = state
        if state then AddToArrayList("飞行", iyflyspeed) else RemoveFromArrayList("飞行") end
        if state then
            applyFly()
        else
            NOFLY()
        end
    end
})

Tab:Slider({
    Flag = "32",
    Title = "飞行速度",
    Value = {
        Min = 1,
        Max = 10,
        Default = 2
    },
    Callback = function(value)
        iyflyspeed = value
        vehicleflyspeed = value
        if FLY_TOGGLE_STATE then UpdateModuleDisplay("飞行", value) end
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local tpwalking = false
local tpwalkSpeed = 100

Tab:Toggle({
    Flag = "33",
    Title = "速度",
    Value = false,
    Callback = function(state)
        tpwalking = state
        if state then AddToArrayList("速度", tpwalkSpeed) else RemoveFromArrayList("速度") end
        if state then
            spawn(function()
                while tpwalking do
                    local chr = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                    local hrp = chr:FindFirstChild("HumanoidRootPart")
                    local hum = chr:FindFirstChildWhichIsA("Humanoid")
                    local delta = RunService.Heartbeat:Wait()
                    if hrp and hum and hum.MoveDirection.Magnitude > 0 then
                        hrp.CFrame = hrp.CFrame + (hum.MoveDirection * tpwalkSpeed * delta)
                    end
                end
            end)
        end
    end
})

Tab:Slider({
    Flag = "34",
    Title = "速度调节",
    Value = {
        Min = 0,
        Max = 250,
        Default = tpwalkSpeed,
    },
    Callback = function(value)
        tpwalkSpeed = value
        if tpwalking then UpdateModuleDisplay("速度", value) end
    end
})

Tab:Slider({
    Flag = "35",
    Title = "冲刺加速(默认值100)",
    Value = {
        Min = 0,
        Max = 1000,
        Default = 100,
    },
    Callback = function(value)
        game:GetService("ReplicatedStorage").Settings.Multipliers.DashSpeed.Value = value
    end
})

Tab:Slider({
    Flag = "36",
    Title = "跳跃增强(默认值100)",
    Value = {
        Min = 0,
        Max = 1000,
        Default = 100,
    },
    Callback = function(value)
        game:GetService("ReplicatedStorage").Settings.Multipliers.JumpHeight.Value = value
    end
})

Tab:Slider({
    Flag = "37",
    Title = "攻击加速(默认值100)",
    Value = {
        Min = 0,
        Max = 1000,
        Default = 100,
    },
    Callback = function(value)
        game:GetService("ReplicatedStorage").Settings.Multipliers.MeleeSpeed.Value = value
    end
})
local Tab = Window:Tab({  
    Title = "暴力功能",  
    Icon = "hand-fist",  
    Locked = false,
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local active = false

local function getLocalPlayerCharacter()
    return LocalPlayer.Character
end

local function generateActionNumber()
    return "Action" .. math.random(1000, 9999)
end

local function getServerTime()
    return tick()
end

local function wallcomboveryud()
    local playerChar = getLocalPlayerCharacter()
    if not playerChar then return false end

    local head = playerChar:FindFirstChild("Head")
    if not head then return false end

    local charData = LocalPlayer:FindFirstChild("Data")
    local charValue = charData and charData:FindFirstChild("Character") and charData.Character.Value
    if not charValue then return false end

    local charsFolder = ReplicatedStorage:FindFirstChild("Characters")
    if not charsFolder or not charsFolder:FindFirstChild(charValue) then return false end

    local wallComboAbility = charsFolder[charValue]:FindFirstChild("WallCombo")
    if not wallComboAbility then return false end

    local targetCharacter = playerChar
    if not targetCharacter then return false end

    local actionNumber = generateActionNumber()
    local serverTime = getServerTime()
    local randomId = math.random(100000, 999999)

    local remoteArgs = {
        wallComboAbility,
        "Characters:" .. charValue .. ":WallCombo",
        1,
        randomId,
        {
            HitboxCFrames = {nil},
            BestHitCharacter = targetCharacter,
            HitCharacters = {targetCharacter},
            Ignore = {[actionNumber] = {targetCharacter}},
            DeathInfo = {},
            Actions = {[actionNumber] = {}},
            HitInfo = {
                Blocked = false,
                IsFacing = true,
                IsInFront = true
            },
            BlockedCharacters = {},
            ServerTime = serverTime,
            FromCFrame = nil
        },
        actionNumber
    }

    pcall(function()
        ReplicatedStorage.Remotes.Abilities.Ability:FireServer(wallComboAbility, randomId)
    end)

    pcall(function()
        ReplicatedStorage.Remotes.Combat.Action:FireServer(unpack(remoteArgs))
    end)
end

task.spawn(function()
    while task.wait(0.01) do
        if active then
            pcall(wallcomboveryud)
        end
    end
end)

Tab:Toggle({
    Flag = "21",
    Title = "无敌",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("无敌") else RemoveFromArrayList("无敌") end
        active = state
    end
})
Tab:Button({
    Flag = "22",
    Title = "卡服",
    Callback = function()
        local Players = game:GetService("Players")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")

        local player = Players.LocalPlayer
        local active = true
        local spawnedTasks = {}

        local function buildCombatArgs()
            return {
                [1] = ReplicatedStorage.Characters.Gon.WallCombo,
                [2] = "Characters:Gon:WallCombo",
                [3] = 1,
                [4] = 33036,
                [5] = {
                    ["HitboxCFrames"] = {},
                    ["BestHitCharacter"] = workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum"),
                    ["HitCharacters"] = {workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum")},
                    ["Ignore"] = {},
                    ["DeathInfo"] = {},
                    ["Actions"] = {},
                    ["HitInfo"] = {
                        ["IsFacing"] = true,
                        ["IsInFront"] = true
                    },
                    ["BlockedCharacters"] = {},
                    ["ServerTime"] = os.clock(),
                    ["FromCFrame"] = CFrame.new(534.693, 5.532, 79.486)
                },
                [6] = "Action651",
                [7] = 0
            }
        end

        local abilityArgs = {
            [1] = ReplicatedStorage.Characters.Gon.WallCombo,
            [2] = 33036,
            [4] = workspace.Characters.NPCs:FindFirstChild("The Ultimate Bum"),
            [5] = Vector3.new(527.693, 4.532, 79.978)
        }

        for i = 1, 10000 do
            local t = task.spawn(function()
                if active then
                    pcall(function()
                        local combatArgs = buildCombatArgs()
                        ReplicatedStorage.Remotes.Abilities.Ability:FireServer(unpack(abilityArgs))
                        ReplicatedStorage.Remotes.Combat.Action:FireServer(unpack(combatArgs))
                    end)
                end
            end)
            table.insert(spawnedTasks, t)
        end

        task.delay(3, function()
            active = false
            for _, t in ipairs(spawnedTasks) do
                if task.cancel then
                    task.cancel(t)
                end
            end
            spawnedTasks = {}

            local localContainers = workspace:FindFirstChild("Container(Drawing)")
            if localContainers then
                for _, v in ipairs(localContainers:GetChildren()) do
                    if v.Name:match(tostring(player.UserId)) then
                        v:Destroy()
                    end
                end
            end

            print("已卡服该死妈服务器")
        end)
    end
})
local _F = {}

_F.P = game:GetService("Players")
_F.R = game:GetService("RunService")
_F.RS = game:GetService("ReplicatedStorage")
_F.W = game:GetService("Workspace")
_F.L = _F.P.LocalPlayer

_F.Cfg = {
    Enabled = false,
    Range = 67.5,
    Friends = true,
    Target = "Closest" 
}

_F.Data = {
    List = {},
    Idx = 1,
    FCon = nil,
    KCon = nil,
    OSub = nil,
    OType = nil,
    SCFrame = nil,
    SCCFrame = nil,
    SCType = nil
}

_F.Dash = function()
    local char = _F.L.Character or _F.L.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp then
        require(_F.RS:WaitForChild("Core")).Library("Remote").Send("Dash", hrp.CFrame, "L", 1)
    end
end

_F.HRP = function()
    local c = _F.L.Character
    if c and c:FindFirstChild('Humanoid') and c.Humanoid.RootPart then
        return c.Humanoid.RootPart
    end
    return nil
end

_F.IsF = function(p)
    if not p or p == _F.L then return false end
    return _F.L:IsFriendsWith(p.UserId)
end

_F.GetT = function()
    local tgs = {}
    local root = _F.HRP()
    if not root then return tgs end
    local pos = root.Position
    
    for _, v in ipairs(_F.P:GetPlayers()) do
        local char = v.Character
        if char and v ~= _F.L and char:FindFirstChild(' ') == nil then
            if _F.Cfg.Friends and _F.IsF(v) then continue end
            local hum = char:FindFirstChild('Humanoid')
            local hrp = char:FindFirstChild('HumanoidRootPart')
            
            if hum and hrp then
                local dist = (hrp.Position - pos).Magnitude
                if dist < _F.Cfg.Range then
                    local lchar = _F.L.Character
                    if lchar then
                        local lName = lchar.Name
                        local cs = char:GetAttribute("Cutscene")
                        local csV = not cs or cs == lchar:GetAttribute("Cutscene")
                        
                        if hrp and not char:GetAttribute("Ignore") and csV and 
                           ((not char:GetAttribute("Grabbed") or char:GetAttribute("Grabbed") == lName) and 
                           (not char:GetAttribute("Victim") or char:GetAttribute("Victim") == lName)) and 
                           not char:GetAttribute("Invincible") and not char:GetAttribute("Grabbing") then
                            
                            table.insert(tgs, {c = char, d = dist, h = hum:GetAttribute("Health") or hum.Health or 0})
                        end
                    end
                end
            end
        end
    end
    
    if _F.Cfg.Target == "Closest" and #tgs > 0 then
        table.sort(tgs, function(a, b) return a.d < b.d end)
        return {tgs[1]}
    end
    return tgs
end

_F.Aura = function(n)
    local root = _F.HRP()
    if not root then return end
    local tgs = _F.GetT()
    for _, data in ipairs(tgs) do
        if data.c then
            for i=1, n do
                _F.Data.List[_F.Data.Idx] = data.c
                _F.Data.Idx = _F.Data.Idx + 1
            end
        end
    end
    if _F.Data.Idx > 1 then
        local name = _F.L.Data.Character.Value
        local combo = _F.RS.Characters[name].WallCombo
        _F.RS.Remotes.Abilities.Ability:FireServer(combo, 69)
        _F.RS.Remotes.Combat.Action:FireServer(combo, "", 4, 69, {BestHitCharacter=nil, HitCharacters=_F.Data.List, Ignore={}, Actions={}})
        for k in pairs(_F.Data.List) do _F.Data.List[k] = nil end
        _F.Data.Idx = 1
    end
end

_F.GetR = function()
    local al = {}
    for _, p in ipairs(_F.P:GetPlayers()) do
        if p ~= _F.L and p.Character then
            local hu = p.Character:FindFirstChild("Humanoid")
            local hr = p.Character:FindFirstChild("HumanoidRootPart")
            if hu and hr and (hu:GetAttribute("Health") or 0) > 0 and not hu:GetAttribute("Godmode") then
                table.insert(al, p)
            end
        end
    end
    return #al > 0 and al[math.random(1, #al)] or nil
end

_F.TP = function(p)
    if not p or not p.Character then return false end
    local hr = p.Character:FindFirstChild("HumanoidRootPart")
    if not hr then return false end
    pcall(function()
        require(_F.L.PlayerScripts.Character.FullCustomReplication).Override(_F.L.Character, CFrame.new(hr.Position - Vector3.new(0, 30, 0)))
    end)
    return true
end

_F.Spec = function(p)
    local cam = _F.W.CurrentCamera
    if cam and p and p.Character then
        local hu = p.Character:FindFirstChildOfClass("Humanoid")
        if hu then cam.CameraType = Enum.CameraType.Custom cam.CameraSubject = hu end
    end
end

_F.Loop = function()
    local c = _F.L.Character
    if not c or not c.Parent then return end
    local r = _F.GetR()
    if r then
        _F.TP(r)
        _F.Spec(r)
        task.wait(0.5)
    end
end

_F.Grav = function(b)
    local c = _F.L.Character
    if not c then return end
    for _, p in ipairs(c:GetDescendants()) do
        if p:IsA("BasePart") then
            p.Anchored = not b
            if not b then p.Velocity = Vector3.new(0,0,0) end
        end
    end
end

_F.Save = function()
    local c = _F.L.Character
    local hr = c and c:FindFirstChild("HumanoidRootPart")
    if not hr then return false end
    _F.Data.SCFrame = hr.CFrame
    local cam = _F.W.CurrentCamera
    if cam then 
        _F.Data.SCCFrame = cam.CFrame 
        _F.Data.SCType = cam.CameraType 
    end
    return true
end

_F.Rest = function()
    if not _F.Data.SCFrame or not _F.L.Character then return end
    pcall(function() require(_F.L.PlayerScripts.Character.FullCustomReplication).Override(_F.L.Character, _F.Data.SCFrame) end)
    task.delay(0.1, function()
        local cam = _F.W.CurrentCamera
        if cam and _F.Data.SCCFrame then 
            cam.CameraType = _F.Data.SCType 
            cam.CFrame = _F.Data.SCCFrame 
        end
    end)
end

_F.Start = function()
    if not _F.Save() then return end
    _F.Grav(false)
    local cam = _F.W.CurrentCamera
    if cam then 
        _F.Data.OSub = cam.CameraSubject 
        _F.Data.OType = cam.CameraType 
    end
    _F.Data.FCon = _F.R.Heartbeat:Connect(_F.Loop)
    _F.Data.KCon = _F.R.Heartbeat:Connect(function()
        _F.Dash()
        local cn = _F.L.Data.Character.Value
        _F.Aura(cn == "Gon" and 20 or 50)
    end)
end

_F.Stop = function()
    if _F.Data.FCon then _F.Data.FCon:Disconnect() _F.Data.FCon = nil end
    if _F.Data.KCon then _F.Data.KCon:Disconnect() _F.Data.KCon = nil end
    _F.Rest()
    _F.Grav(true)
    local cam = _F.W.CurrentCamera
    if cam and _F.Data.OSub then 
        cam.CameraSubject = _F.Data.OSub 
        cam.CameraType = _F.Data.OType 
    end
end

Tab:Toggle({
    Title = "全图秒杀",
    Value = false,
    Callback = function(state)
        _F.Cfg.Enabled = state
        if _F.Cfg.Enabled then
            _F.Start()
        else
            _F.Stop()
        end
    end
})

_F.L.CharacterAdded:Connect(function()
    if _F.Cfg.Enabled then
        _F.Stop()
        _F.Cfg.Enabled = false
    end
end)


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Core = require(ReplicatedStorage:WaitForChild("Core"))

local LocalPlayer = Players.LocalPlayer
local charValue = LocalPlayer:WaitForChild("Data"):WaitForChild("Character").Value
local chars = ReplicatedStorage:WaitForChild("Characters")
local ability = chars:WaitForChild(charValue):WaitForChild("WallCombo")
local interruptAttr = ability:GetAttribute("Interrupt")

local wallComboCooldown = 0.05
local lastWallComboTime = 0
local wallComboKey = Enum.KeyCode.E
local lastDashTime = 0

local wallComboEnabled = false
local ignoreFriends = false

local wallComboConn = nil
local dashConn = nil

local function isFriend(player)
    local ok, res = pcall(function() return LocalPlayer:IsFriendsWith(player.UserId) end)
    return ok and res
end

local function shouldIgnorePlayerModel(model)
    if not model then return false end
    if ignoreFriends then
        for _, pl in ipairs(Players:GetPlayers()) do
            if pl ~= LocalPlayer and pl.Character == model then
                if isFriend(pl) then
                    return true
                end
            end
        end
    end
    return false
end

local function getHead()
    local character = LocalPlayer.Character
    if not character then return nil end
    return character:FindFirstChild("Head")
end

local function hasValidTargetsForWallCombo(range)
    local head = getHead()
    if not head then return false end
    local hrpPos = head.Position
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            if not shouldIgnorePlayerModel(pl.Character) then
                local d = (pl.Character.HumanoidRootPart.Position - hrpPos).Magnitude
                if d <= range then return true end
            end
        end
    end
    return false
end

local function executeWallCombo()
    local head = getHead()
    if not head then return end
    local now = tick()
    if now - lastWallComboTime < wallComboCooldown then return end
    if not hasValidTargetsForWallCombo(100) then return end
    lastWallComboTime = now
    local res
    local success = pcall(function()
        res = Core.Get("Combat","Hit").Box(nil, LocalPlayer.Character, {Size = Vector3.new(100,100,100)})
    end)
    if not success or not res then return end
    pcall(function()
        Core.Get("Combat","Ability").Activate(chars[charValue].WallCombo, res, head.Position + Vector3.new(0,0,2.5))
    end)
end

local function fireDash()
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local now = tick()
    if now - lastDashTime < 0.1 then return end
    lastDashTime = now
    local args = {
        [1] = hrp.CFrame,
        [2] = "F",
        [3] = hrp.CFrame.LookVector,
        [5] = now
    }
    if ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("Character") and ReplicatedStorage.Remotes.Character:FindFirstChild("Dash") then
        ReplicatedStorage.Remotes.Character.Dash:FireServer(unpack(args))
    else
        pcall(function()
            ReplicatedStorage.Remotes.Character.Dash:FireServer(unpack(args))
        end)
    end
end

local function toggleWallCombo(state)
    wallComboEnabled = state
    if wallComboConn then wallComboConn:Disconnect(); wallComboConn = nil end
    if dashConn then dashConn:Disconnect(); dashConn = nil end
    if wallComboEnabled then
        wallComboConn = RunService.Heartbeat:Connect(function()
            executeWallCombo()
        end)
        dashConn = RunService.Heartbeat:Connect(function()
            fireDash()
        end)
    end
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == wallComboKey then
        executeWallCombo()
    end
end)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Core = require(ReplicatedStorage:WaitForChild("Core"))
local LocalPlayer = Players.LocalPlayer

local Configs = {
    IgnoreFriends = false,
    MaxDistance = 100,
    Damage = 9999,
    HealthLimit = 0,
    DashInterval = 0.7,
    AttackInterval = 0.001
}

local running = false
local conn
local lastDash = 0
local lastAttack = 0

local data = LocalPlayer:WaitForChild("Data")
local charValue = data:WaitForChild("Character")
local localCharacterName = charValue.Value
local ability = ReplicatedStorage:WaitForChild("Characters"):WaitForChild(localCharacterName):WaitForChild("WallCombo")
local AbilitiesRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Abilities"):WaitForChild("Ability")
local CombatRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("Action")

local function getLocalRootPart()
    local c = LocalPlayer.Character
    return c and c:FindFirstChild("HumanoidRootPart")
end

local function triggerDash()
    if tick() - lastDash < Configs.DashInterval then return end
    lastDash = tick()
    local hrp = getLocalRootPart()
    if not hrp then return end
    local dashRemote = ReplicatedStorage.Remotes.Character:FindFirstChild("Dash")
    if dashRemote then
        pcall(function()
            dashRemote:FireServer(hrp.CFrame, "L", hrp.CFrame.LookVector, nil, tick())
        end)
    end
end

local function sendKillAura()
    if tick() - lastAttack < Configs.AttackInterval then return end
    lastAttack = tick()
    local localRootPart = getLocalRootPart()
    if not localRootPart then return end
    triggerDash()
    local maxDistSq = Configs.MaxDistance * Configs.MaxDistance
    for _, targetPlayer in ipairs(Players:GetPlayers()) do
        if targetPlayer ~= LocalPlayer then
            local targetChar = targetPlayer.Character
            if targetChar then
                local targetRootPart = targetChar:FindFirstChild("HumanoidRootPart")
                local targetHumanoid = targetChar:FindFirstChild("Humanoid")
                if targetRootPart and targetHumanoid and targetHumanoid.Health > Configs.HealthLimit then
                    if not (Configs.IgnoreFriends and LocalPlayer:IsFriendsWith(targetPlayer.UserId)) then
                        local delta = localRootPart.Position - targetRootPart.Position
                        if delta.Magnitude * delta.Magnitude <= maxDistSq then
                            pcall(function()
                                AbilitiesRemote:FireServer(ability, Configs.Damage, {}, targetRootPart.Position)
                            end)
                            pcall(function()
                                CombatRemote:FireServer(
                                    ability,
                                    localCharacterName .. ":WallCombo",
                                    2,
                                    Configs.Damage,
                                    {
                                        HitboxCFrames = {targetRootPart.CFrame, targetRootPart.CFrame},
                                        BestHitCharacter = targetChar,
                                        HitCharacters = {targetChar},
                                        Ignore = {},
                                        DeathInfo = {},
                                        BlockedCharacters = {},
                                        HitInfo = {IsFacing = false, IsInFront = true},
                                        ServerTime = os.time(),
                                        Actions = {
                                            ActionNumber1 = {
                                                [targetPlayer.Name] = {
                                                    StartCFrameStr = tostring(localRootPart.CFrame),
                                                    Local = true,
                                                    Collision = false,
                                                    Animation = "Punch1Hit",
                                                    Preset = "Punch",
                                                    Velocity = Vector3.zero,
                                                    FromPosition = targetRootPart.Position,
                                                    Seed = math.random(1,999999)
                                                }
                                            }
                                        },
                                        FromCFrame = targetRootPart.CFrame
                                    },
                                    "Action150",
                                    0
                                )
                            end)
                        end
                    end
                end
            end
        end
    end
end

local function startAura()
    if conn then conn:Disconnect() conn = nil end
    conn = RunService.Heartbeat:Connect(function()
        if running then
            sendKillAura()
        end
    end)
end

local function stopAura()
    if conn then conn:Disconnect() conn = nil end
end

Tab:Toggle({
    Flag = "23",
    Title = "杀戮光环v1(慢)",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("杀戮光环") else RemoveFromArrayList("杀戮光环") end
        running = state
        if running then
            startAura()
        else
            stopAura()
        end
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local enabled = false
local conn
local PlayersList = {}
local index = 1

local RANGE = 70
local DASH_INTERVAL = 0.25
local lastDash = 0

local function C()
    return LocalPlayer.Character
end

local function HRP()
    if C() and C():FindFirstChild("Humanoid") then
        return C().Humanoid.RootPart
    end
end

local function isFriend(p)
    return LocalPlayer:IsFriendsWith(p.UserId)
end

local function triggerDash()
    local now = tick()
    if now - lastDash < DASH_INTERVAL then return end
    lastDash = now

    local hrp = HRP()
    if not hrp then return end

    local dashRemote = ReplicatedStorage.Remotes.Character:FindFirstChild("Dash")
    if dashRemote then
        pcall(function()
            dashRemote:FireServer(
                hrp.CFrame,
                "L",
                hrp.CFrame.LookVector,
                nil,
                now
            )
        end)
    end
end

local function getTargets()
    local targets = {}
    local hrp = HRP()
    if not hrp then return targets end

    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            if isFriend(p) then continue end

            local hum = p.Character:FindFirstChild("Humanoid")
            local root = p.Character:FindFirstChild("HumanoidRootPart")

            if hum and root and hum.Health > 0 then
                if (root.Position - hrp.Position).Magnitude <= RANGE then
                    if not p.Character:GetAttribute("Invincible") then
                        table.insert(targets, p.Character)
                    end
                end
            end
        end
    end

    return targets
end

local function KillAura(count)
    triggerDash()

    local targets = getTargets()
    for _, char in ipairs(targets) do
        for i = 1, count do
            PlayersList[index] = char
            index += 1
        end
    end

    if index > 1 then
        local combo = ReplicatedStorage.Characters[LocalPlayer.Data.Character.Value].WallCombo

        ReplicatedStorage.Remotes.Abilities.Ability:FireServer(combo, 69)

        ReplicatedStorage.Remotes.Combat.Action:FireServer(
            combo,
            "",
            4,
            69,
            {
                BestHitCharacter = nil,
                HitCharacters = PlayersList,
                Ignore = {},
                Actions = {}
            }
        )

        table.clear(PlayersList)
        index = 1
    end
end

Tab:Toggle({
    Flag = "23.5",
    Title = "杀戮光环v2(快)",
    Value = false,
    Callback = function(state)
        enabled = state
        if enabled then
            conn = RunService.Heartbeat:Connect(function()
                local count = (LocalPlayer.Data.Character.Value == "Gon") and 20 or 50
                KillAura(count)
            end)
        else
            if conn then
                conn:Disconnect()
                conn = nil
            end
        end
    end
})
Tab:Toggle({
    Flag = "24",
    Title = "杀戮光环忽略好友",
    Value = false,
    Callback = function(state)
        Configs.IgnoreFriends = state
    end
})
Tab:Toggle({
    Flag = "25",
    Title = "墙打秒杀",
    Value = false,
    Callback = function(state)
        if state then AddToArrayList("墙打秒杀") else RemoveFromArrayList("墙打秒杀") end
        toggleWallCombo(state)
    end
})

Tab:Toggle({
    Flag = "26",
    Title = "墙打秒杀忽略好友",
    Value = false,
    Callback = function(state)
        ignoreFriends = state
    end
})

local Tab = Window:Tab({
    Title = "碰撞箱扩大",
    Icon = "box",
    Locked = false,
})
pcall(function()
    setthreadidentity(8)
end)

local S = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Cfg = {
        Hitbox = false,
        X = 150,
        Y = 150,
        Z = 150,
        Enhancer = false,
        Multi = 3
    },
    Cache = {},
    Conn = nil,
    DashT = 0
}

local LP = S.Players.LocalPlayer

getgenv().HitboxEnabled = false

function S:HRP()
    local c = LP.Character
    return c and c:FindFirstChild("HumanoidRootPart")
end

function S:GetCore()
    if self.Cache.Core then
        return self.Cache.Core
    end
    local ok, core = pcall(function()
        return require(self.ReplicatedStorage:WaitForChild("Core", 10))
    end)
    if ok then
        self.Cache.Core = core
        return core
    end
end

function S:ToggleHitbox(state)
    self.Cfg.Hitbox = state
    getgenv().HitboxEnabled = state

    local core = self:GetCore()
    if not core or not core.Get then return end

    local hit = core.Get("Combat", "Hit")
    if not hit or not hit.Box then return end

    if state then
        if not self.Cache.OrigBox then
            self.Cache.OrigBox = hit.Box
        end
        hit.Box = function(_, char, data)
            data = data or {}
            data.Size = Vector3.new(self.Cfg.X, self.Cfg.Y, self.Cfg.Z)
            return self.Cache.OrigBox(nil, char, data)
        end
    else
        if self.Cache.OrigBox then
            hit.Box = self.Cache.OrigBox
        end
    end
end

function S:Dash()
    if tick() - self.DashT < 0.18 then return end
    self.DashT = tick()

    local hrp = self:HRP()
    if not hrp then return end

    pcall(function()
        self:GetCore()
            .Library("Remote")
            .Send("Dash", hrp.CFrame, "L", 1)
    end)
end

function S:EnableEnhancer()
    if self.Cache.HitProc then return end

    local ok, hit = pcall(function()
        return require(LP.PlayerScripts:WaitForChild("Combat"):WaitForChild("Hit"))
    end)
    if not ok or not hit.Process then return end

    self.Cache.HitProc = hit.Process

    hit.Process = function(...)
        local best, targets, blocked = self.Cache.HitProc(...)
        if not targets or #targets == 0 then
            return best, targets, blocked
        end

        self:Dash()

        local r = self.ReplicatedStorage.Remotes.Combat.Action
        for _ = 1, self.Cfg.Multi do
            pcall(function()
                r:FireServer(
                    nil, "", 4, 69,
                    {BestHitCharacter=nil, HitCharacters=targets, Ignore={}, Actions={}}
                )
            end)
        end

        return best, targets, blocked
    end
end

function S:DisableEnhancer()
    if not self.Cache.HitProc then return end
    local ok, hit = pcall(function()
        return require(LP.PlayerScripts.Combat.Hit)
    end)
    if ok then
        hit.Process = self.Cache.HitProc
    end
    self.Cache.HitProc = nil
end

function S:StartDashLoop()
    if self.Conn then return end
    self.Conn = self.RunService.Heartbeat:Connect(function()
        self:Dash()
    end)
end

function S:StopDashLoop()
    if self.Conn then
        self.Conn:Disconnect()
        self.Conn = nil
    end
end

Tab:Toggle({
    Title = "碰撞箱扩大",
    Desc = "如果你不会调参数这些你就直接开启碰撞箱扩大功能就行了",
    Value = false,
    Callback = function(v)
        if v then
            S:ToggleHitbox(true)
            S:EnableEnhancer()
            S:StartDashLoop()
        else
            S:ToggleHitbox(false)
            S:DisableEnhancer()
            S:StopDashLoop()
        end
    end
})

Tab:Input({
    Title = "碰撞箱X轴",
    Value = tostring(S.Cfg.X),
    Callback = function(v)
        v = tonumber(v)
        if v then
            S.Cfg.X = math.clamp(v, 10, 150)
        end
    end
})

Tab:Input({
    Title = "碰撞箱Y轴",
    Value = tostring(S.Cfg.Y),
    Callback = function(v)
        v = tonumber(v)
        if v then
            S.Cfg.Y = math.clamp(v, 10, 150)
        end
    end
})

Tab:Input({
    Title = "碰撞箱Z轴",
    Value = tostring(S.Cfg.Z),
    Callback = function(v)
        v = tonumber(v)
        if v then
            S.Cfg.Z = math.clamp(v, 10, 150)
        end
    end
})
local LockTab = Window:Tab({
    Title = "锁人",
    Icon = "crosshair",
    Locked = false,
})

local S = {}

S.Players = game:GetService("Players")
S.RunService = game:GetService("RunService")
S.LocalPlayer = S.Players.LocalPlayer

S.v3new = Vector3.new
S.cfnew = CFrame.new
S.mathcos = math.cos
S.mathsin = math.sin
S.tableinsert = table.insert
S.pairs = pairs

S.BEHIND_DISTANCE = 5
S.CIRCLE_RADIUS = 6
S.CIRCLE_SPEED = 13

S.followEnabled = false
S.circleEnabled = false
S.lookEnabled = false
S.selectedTargetName = nil

S.circleAngle = 0
S.mainConnection = nil
S.playerDropdown = nil

function S.getRoot(player)
    if player and player.Character then
        return player.Character:FindFirstChild("HumanoidRootPart")
    end
end

function S.getPlayerByName(name)
    for _, p in S.pairs(S.Players:GetPlayers()) do
        if p.Name == name then
            return p
        end
    end
end

function S.getPlayerNames()
    local names = {}
    for _, p in S.pairs(S.Players:GetPlayers()) do
        if p ~= S.LocalPlayer then
            S.tableinsert(names, p.Name)
        end
    end
    return names
end

function S.updateLoop(dt)
    if not S.selectedTargetName then return end

    local target = S.getPlayerByName(S.selectedTargetName)
    local targetRoot = S.getRoot(target)
    local myRoot = S.getRoot(S.LocalPlayer)

    if not targetRoot or not myRoot then return end

    local targetPos = targetRoot.Position
    local finalPos = nil

    if S.circleEnabled then
        S.circleAngle += (S.CIRCLE_SPEED * dt)
        local x = S.mathcos(S.circleAngle) * S.CIRCLE_RADIUS
        local z = S.mathsin(S.circleAngle) * S.CIRCLE_RADIUS
        finalPos = targetPos + S.v3new(x, 0, z)
    elseif S.followEnabled then
        local offset = targetRoot.CFrame.LookVector * S.BEHIND_DISTANCE
        finalPos = targetPos - offset
    end

    if finalPos then
        if S.lookEnabled then
            myRoot.CFrame = S.cfnew(finalPos, S.v3new(targetPos.X, finalPos.Y, targetPos.Z))
        else
            myRoot.CFrame = S.cfnew(finalPos) * myRoot.CFrame.Rotation
        end
    elseif S.lookEnabled then
        local myPos = myRoot.Position
        myRoot.CFrame = S.cfnew(myPos, S.v3new(targetPos.X, myPos.Y, targetPos.Z))
    end
end

function S.toggleConnection()
    if S.followEnabled or S.circleEnabled or S.lookEnabled then
        if not S.mainConnection then
            S.mainConnection = S.RunService.RenderStepped:Connect(S.updateLoop)
        end
    else
        if S.mainConnection then
            S.mainConnection:Disconnect()
            S.mainConnection = nil
        end
    end
end

S.playerDropdown = LockTab:Dropdown({
    Title = "选择目标玩家",
    Multi = false,
    AllowNone = true,
    Value = nil,
    Values = S.getPlayerNames(),
    Callback = function(name)
        S.selectedTargetName = name
    end
})

LockTab:Button({
    Title = "刷新玩家列表",
    Callback = function()
        S.selectedTargetName = nil
        local newNames = S.getPlayerNames()
        local d = S.playerDropdown
        if d then
            if d.SetValues then
                d:SetValues(newNames)
            elseif d.Refresh then
                d:Refresh(newNames, true)
            end
            if d.SetValue then
                d:SetValue(nil)
            end
        end
    end
})

LockTab:Toggle({
    Title = "锁背",
    Value = false,
    Callback = function(state)
        S.followEnabled = state
        if state then S.circleEnabled = false end
        S.toggleConnection()
    end
})

LockTab:Toggle({
    Title = "转圈",
    Value = false,
    Callback = function(state)
        S.circleEnabled = state
        if state then S.followEnabled = false end
        S.toggleConnection()
    end
})

LockTab:Toggle({
    Title = "看着玩家(需要关移位锁)",
    Value = false,
    Callback = function(state)
        S.lookEnabled = state
        S.toggleConnection()
    end
})
local T = {}

T.env = {
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Players = game:GetService("Players"),
}
T.env.LocalPlayer = T.env.Players.LocalPlayer
T.env.core = require(T.env.ReplicatedStorage:WaitForChild("Core"))
T.env.Character = T.env.LocalPlayer.Character or T.env.LocalPlayer.CharacterAdded:Wait()
T.env.HumanoidRootPart = T.env.Character:WaitForChild("HumanoidRootPart")

T.state = {
    killEmotes = {},
    aura = false,
    spam = false,
    auraDelay = 0.5,
    spamDelay = 0.5,
    selectedEmote = "",
    keybind = Enum.KeyCode.G,
    dropdown = nil,
    tmp = {}
}

T.services = {
    UserInputService = game:GetService("UserInputService")
}

T.ui = {}
T.ui.forceKillEmoteTab = Window:Tab({
    Title = "击杀表情功能",
    Icon = "smile",
    Locked = false,
})

function T.getRoot(char)
    return char and char:FindFirstChild("HumanoidRootPart")
end

function T.useEmote(name)
    local tmp = T.state.tmp
    tmp.emote = T.env.ReplicatedStorage:WaitForChild("Cosmetics"):WaitForChild("KillEmote"):FindFirstChild(name)
    tmp.myRoot = T.getRoot(T.env.LocalPlayer.Character)
    if not tmp.emote or not tmp.myRoot then return end

    tmp.closest = nil
    tmp.dist = math.huge
    for _, p in pairs(T.env.Players:GetPlayers()) do
        if p ~= T.env.LocalPlayer and p.Character then
            tmp.r = T.getRoot(p.Character)
            if tmp.r then
                tmp.d = (tmp.myRoot.Position - tmp.r.Position).Magnitude
                if tmp.d < tmp.dist then
                    tmp.dist = tmp.d
                    tmp.closest = p.Character
                end
            end
        end
    end

    if tmp.closest then
        task.spawn(function()
            _G.KillEmote = true
            pcall(function()
                T.env.core.Get("Combat", "Ability").Activate(tmp.emote, tmp.closest)
            end)
            _G.KillEmote = false
        end)
    end
end

function T.useRandom()
    local list = T.state.killEmotes
    if #list > 0 then
        T.useEmote(list[math.random(#list)])
    end
end

task.spawn(function()
    while true do
        if T.state.aura then
            T.useRandom()
            task.wait(T.state.auraDelay)
        else
            task.wait(0.1)
        end
    end
end)

task.spawn(function()
    while true do
        if T.state.spam and T.state.selectedEmote ~= "" then
            T.useEmote(T.state.selectedEmote)
            task.wait(T.state.spamDelay)
        else
            task.wait(0.1)
        end
    end
end)

T.services.UserInputService.InputBegan:Connect(function(i, g)
    if not g and i.KeyCode == T.state.keybind and T.state.selectedEmote ~= "" then
        T.useEmote(T.state.selectedEmote)
    end
end)

function T.updateDropdown(list)
    local values = (#list > 0 and list) or { "No emotes found" }
    if T.state.dropdown then
        pcall(function()
            T.state.dropdown:Destroy()
        end)
        T.state.dropdown = nil
    end
    T.state.dropdown = T.ui.forceKillEmoteTab:Dropdown({
        Title = "击杀表情功能(要靠近别人)",
        Values = values,
        Multi = false,
        AllowNone = false,
        Callback = function(v)
            if v ~= "No emotes found" then
                T.state.selectedEmote = v
                T.useEmote(v)
            end
        end
    })
end

T.ui.forceKillEmoteTab:Button({
    Title = "刷新击杀表情",
    Callback = function()
        table.clear(T.state.killEmotes)
        for _, e in pairs(T.env.ReplicatedStorage:WaitForChild("Cosmetics"):WaitForChild("KillEmote"):GetChildren()) do
            T.state.killEmotes[#T.state.killEmotes + 1] = e.Name
        end
        T.updateDropdown(T.state.killEmotes)
    end
})

for _, e in pairs(T.env.ReplicatedStorage:WaitForChild("Cosmetics"):WaitForChild("KillEmote"):GetChildren()) do
    T.state.killEmotes[#T.state.killEmotes + 1] = e.Name
end

T.updateDropdown(T.state.killEmotes)

T.ui.forceKillEmoteTab:Toggle({
    Title = "击杀表情光环",
    Default = false,
    Callback = function(v)
        T.state.aura = v
    end
})

T.ui.forceKillEmoteTab:Slider({
    Title = "击杀表情光环间隔",
    Step = 0.01,
    Value = { Min = 0.01, Max = 5, Default = 0.5 },
    Callback = function(v)
        T.state.auraDelay = v
    end
})

T.ui.forceKillEmoteTab:Toggle({
    Title = "持续发送你选择的表情",
    Default = false,
    Callback = function(v)
        T.state.spam = v
    end
})

T.ui.forceKillEmoteTab:Slider({
    Title = "调整你选择的表情速度",
    Step = 0.01,
    Value = { Min = 0.01, Max = 5, Default = 0.5 },
    Callback = function(v)
        T.state.spamDelay = v
    end
})

T.keyMap = {
    G = Enum.KeyCode.G, F = Enum.KeyCode.F, H = Enum.KeyCode.H, J = Enum.KeyCode.J,
    K = Enum.KeyCode.K, L = Enum.KeyCode.L, Z = Enum.KeyCode.Z, X = Enum.KeyCode.X,
    C = Enum.KeyCode.C, V = Enum.KeyCode.V, B = Enum.KeyCode.B, N = Enum.KeyCode.N,
    M = Enum.KeyCode.M, Q = Enum.KeyCode.Q, E = Enum.KeyCode.E, R = Enum.KeyCode.R,
    T = Enum.KeyCode.T, Y = Enum.KeyCode.Y, U = Enum.KeyCode.U, I = Enum.KeyCode.I,
    O = Enum.KeyCode.O, P = Enum.KeyCode.P,
}

local keyList = {}
for k in pairs(T.keyMap) do
    keyList[#keyList + 1] = k
end
table.sort(keyList)

T.ui.forceKillEmoteTab:Dropdown({
    Title = "快捷键设置",
    Values = keyList,
    Value = "G",
    Callback = function(v)
        T.state.keybind = T.keyMap[v]
    end
})

T.ui.forceKillEmoteTab:Button({
    Title = "随机用一个击杀表情",
    Callback = T.useRandom
})
local HttpService = game:GetService("HttpService")

local State = {
    ConfigName = "default",
    ConfigManager = Window.ConfigManager,
    CurrentConfig = nil,
    UI = {}
}

local Tab = Window:Tab({
    Title = "设置",
    Icon = "settings",
    Locked = false,
})

local Section = Tab:Section({
    Title = "配置系统",
    Icon = "folder-cog",
})

State.UI.ConfigNameInput = Section:Input({
    Title = "配置名字",
    Icon = "file-cog",
    Callback = function(value)
        State.ConfigName = value
    end
})

Section:Space()

State.UI.AutoLoadToggle = Section:Toggle({
    Title = "自动加载你所选的配置",
    Value = false,
    Callback = function(v)
        if State.CurrentConfig then
            State.CurrentConfig:SetAutoLoad(v)
        end
    end
})

Section:Space()

local function RefreshConfigs()
    if not State.UI.ConfigDropdown then
        return
    end
    local list = State.ConfigManager:AllConfigs()
    State.UI.ConfigDropdown:Refresh(list)
end

State.UI.ConfigDropdown = Section:Dropdown({
    Title = "全部配置",
    Desc = "这里展示你全部以前保存过的配置",
    Values = State.ConfigManager:AllConfigs(),
    Value = nil,
    Callback = function(value)
        State.ConfigName = value
        State.UI.ConfigNameInput:Set(value)

        local cfg = State.ConfigManager:GetConfig(value)
        State.CurrentConfig = cfg

        State.UI.AutoLoadToggle:Set(cfg and cfg.AutoLoad or false)
    end
})

Section:Space()

Section:Button({
    Title = "保存配置",
    Justify = "Center",
    Callback = function()
        local cfg = State.ConfigManager:Config(State.ConfigName)
        State.CurrentConfig = cfg

        if cfg:Save() then
            WindUI:Notify({
                Title = "saved",
                Desc = "config '" .. State.ConfigName .. "' has been saved",
                Icon = "check",
            })
        end

        RefreshConfigs()
    end
})

Section:Space()

Section:Button({
    Title = "加载配置",
    Justify = "Center",
    Callback = function()
        local cfg = State.ConfigManager:Config(State.ConfigName)
        State.CurrentConfig = cfg

        if cfg:Load() then
            WindUI:Notify({
                Title = "loaded",
                Desc = "config '" .. State.ConfigName .. "' has been loaded",
                Icon = "refresh-cw",
            })
        end

        State.UI.AutoLoadToggle:Set(cfg.AutoLoad or false)
    end
})

Section:Space()

Section:Button({
    Title = "打印配置功能信息",
    Justify = "Center",
    Callback = function()
        local data = State.ConfigManager:GetAutoLoadConfigs()
        print(HttpService:JSONDecode(data))
    end
})

local themes = {}
for name in pairs(WindUI:GetThemes()) do
    themes[#themes + 1] = name
end

Tab:Dropdown({
    Title = "切换ui颜色",
    Values = themes,
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})
      

local MyButton = LeftGroupBox:AddButton({
    Text = 'dorrs🚪门',---服务器名称
    Func = function()
    local originalUI = Library
        
do
    local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

local Window = Library:CreateWindow({
    Title = "YG SCRIPT｜Doors👁",
    Footer = "Doors l floor ",
    Icon = "rbxassetid://4483362748",
    ShowCustomCursor = true,
})

    local Tabs = {
        Home = Window:AddTab('开始', 'house'),
        Player = Window:AddTab('玩家', 'user'),
        Misc = Window:AddTab('其他', 'box'),
        Visuals = Window:AddTab('视觉', 'eye'),
        Entities = Window:AddTab('实体', 'shield'),
    }
    local HomeGroup = Tabs.Home:AddLeftGroupbox('欢迎')
    local Players = game:GetService('Players')
    local player = Players.LocalPlayer
    local avatarImage = HomeGroup:AddImage('AvatarThumbnail', {
        Image = 'rbxassetid://0',
        Callback = function(image)
            print('Image changed!', image)
        end,
    })

    task.spawn(function()
        repeat
            task.wait()
        until player

        task.wait(1)

        local success, thumbnail = pcall(function()
            return Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size180x180)
        end)

        if (success and thumbnail) then
            avatarImage:SetImage(thumbnail)
        else
            local alternatives = {
                Enum.ThumbnailType.AvatarThumbnail,
                Enum.ThumbnailType.AvatarBust,
                Enum.ThumbnailType.Avatar,
            }

            for _, thumbnailType in ipairs(alternatives)do
                local altSuccess, altThumbnail = pcall(function()
                    return Players:GetUserThumbnailAsync(player.UserId, thumbnailType, Enum.ThumbnailSize.Size180x180)
                end)

                if (altSuccess and altThumbnail) then
                    avatarImage:SetImage(altThumbnail)

                    break
                end
            end
        end
    end)


local IntroductionGroup = Tabs.Home:AddRightGroupbox("介绍")
IntroductionGroup:AddLabel("Dev: 怀YG")

local ChangelogsGroup = Tabs.Home:AddRightGroupbox("公告")
ChangelogsGroup:AddLabel('<font color="rgb(0,255,0)"> 加入QQ1015718032</font>')

    local LocalPlayer = game.Players.LocalPlayer
    local Rooms = workspace.CurrentRooms
    local Unloaded = false
    local ClonedCollision
    local OldAccel = LocalPlayer.Character.HumanoidRootPart.CustomPhysicalProperties
    local AntiConnections = {}
    local oldBrightness = game.Lighting.Brightness
    local oldClockTime = game.Lighting.ClockTime
    local oldFogEnd = game.Lighting.FogEnd
    local oldGlobalShadows = game.Lighting.GlobalShadows
    local oldAmbient = game.Lighting.Ambient
    local GodmodeStuff = Tabs.Player:AddLeftGroupbox('Godmode')
    local Players = game:GetService('Players')
    local RunService = game:GetService('RunService')
    local UserInputService = game:GetService('UserInputService')
    local lp = Players.LocalPlayer
    local Toggles = Library.Toggles
    local Options = Library.Options
    local AutoMode = 'Toggle'
    local PreviousMode = 'Toggle'
    local AutoDistance = 166
    local ActiveEntities = {}

    local function setGodmode(state)
        local char = lp.Character

        if not char then
            return
        end

        local hum = char:FindFirstChildOfClass('Humanoid')
        local collision = char:FindFirstChild('Collision')

        if not (hum and collision) then
            return
        end
        if state then
            hum.HipHeight = 0.09
            collision.Size = Vector3.new(1, 3, 3)

            if collision:FindFirstChild('CollisionCrouch') then
                collision.CollisionCrouch.Size = Vector3.new(1, 3, 3)
            end
        else
            hum.HipHeight = 2.4
            collision.Size = Vector3.new(5.5, 3, 3)

            if collision:FindFirstChild('CollisionCrouch') then
                collision.CollisionCrouch.Size = Vector3.new(5.5, 3, 3)
            end
        end
    end
    local function safeDisableGod()
        if not lp.Character then
            return
        end

        local hum = lp.Character:FindFirstChildOfClass('Humanoid')
        local collision = lp.Character:FindFirstChild('Collision')

        if not (hum and collision) then
            setGodmode(false)

            return
        end

        local wasNoclip = Toggles.Noclip and Toggles.Noclip.Value
        local shouldShim = (AutoMode ~= 'Never') and not wasNoclip

        if (shouldShim and Toggles.Noclip) then
            Toggles.Noclip:SetValue(true)
        end

        setGodmode(false)

        if (shouldShim and Toggles.Noclip) then
            task.delay(0.2, function()
                if (Toggles.Noclip and Toggles.Noclip.Value) then
                    Toggles.Noclip:SetValue(false)
                end
            end)
        end
    end

    GodmodeStuff:AddDropdown('GodmodeMode', {
        Text = '无敌模式',
        Default = '切换',
        Values = {
            '切换',
            '自动',
            '抓住',
            '总是',
        },
        Callback = function(mode)
            if ((PreviousMode == 'Always') and (mode ~= 'Always')) then
                if (Toggles.PositionSpoof and Toggles.PositionSpoof.Value) then
                    Toggles.PositionSpoof:SetValue(false)
                    setGodmode(false)

                    if (Toggles.Noclip and not Toggles.Noclip.Value) then
                        Toggles.Noclip:SetValue(true)
                        task.delay(0.2, function()
                            if (Toggles.Noclip and Toggles.Noclip.Value) then
                                Toggles.Noclip:SetValue(false)
                            end
                        end)
                    end
                end
            end

            AutoMode = mode
            PreviousMode = mode

            if Options.PositionSpoofKey then
                Options.PositionSpoofKey.Text = '位置伪装 (' .. mode .. ')'
            end
            if (mode == 'Always') then
                Toggles.PositionSpoof:SetValue(true)
            elseif (mode == 'Never') then
                Toggles.PositionSpoof:SetValue(false)
            end
        end,
    })
    GodmodeStuff:AddCheckbox('PositionSpoof', {
        Text = '无敌模式切换',
        Default = false,
        Disabled = false,
        Callback = function(v)
            if v then
                setGodmode(true)

                if (Toggles.AntiFigure and not Toggles.AntiFigure.Value) then
                    Toggles.AntiFigure:SetValue(true)
                    Library:Notify({
                        Title = '无敌模式启动',
                        Description = '反Figure已自动启用.',
                        Duration = 5,
                        Color = Color3.fromRGB(0, 200, 255),
                    })
                end

                Library:Notify({
                    Title = 'null',
                    Description = '',
                    Duration = 10,
                    Color = Color3.fromRGB(255, 64, 64),
                })
            else
                safeDisableGod()

                if (Toggles.AntiFigure and Toggles.AntiFigure.Value) then
                    Toggles.AntiFigure:SetValue(false)
                    Library:Notify({
                        Title = '无敌模式禁用',
                        Description = '反Figure已自动禁用',
                        Duration = 5,
                        Color = Color3.fromRGB(255, 128, 128),
                    })
                end
            end
        end,
    }):AddKeyPicker('PositionSpoofKey', {
        Default = 'K',
        Mode = 'Toggle',
        Text = '位置伪装 (切换)',
        NoUI = false,
        SyncToggleState = true,
    })

    local EntList = {
        'a60',
        'ambushmoving',
        'backdoorrush',
        'rushmoving',
        'mandrake',
    }

    local function IsValidEntity(entity)
        return table.find(EntList, entity.Name:lower()) ~= nil
    end

    workspace.DescendantAdded:Connect(function(entity)
        if not IsValidEntity(entity) then
            return
        end

        local part = entity:FindFirstChildWhichIsA('BasePart')

        if part then
            ActiveEntities[entity] = part
        end
    end)
    RunService.RenderStepped:Connect(function()
        local lib = getgenv().Library

        if (not lib or lib.Unloaded) then
            return
        end

        local root = lp.Character and lp.Character:FindFirstChild('HumanoidRootPart')

        if not root then
            return
        end
        if (AutoMode == 'Never') then
            if Toggles.PositionSpoof.Value then
                Toggles.PositionSpoof:SetValue(false)
            end
        elseif (AutoMode == 'Always') then
            if not Toggles.PositionSpoof.Value then
                Toggles.PositionSpoof:SetValue(true)
            end
        elseif (AutoMode == 'Automatic') then
            local shouldEnable = false

            for entity, part in pairs(ActiveEntities)do
                if (entity.Parent == nil) then
                    ActiveEntities[entity] = nil
                elseif part then
                    local dist = (root.Position - part.Position).Magnitude

                    if (dist < AutoDistance) then
                        shouldEnable = true

                        break
                    end
                end
            end

            if shouldEnable then
                if not Toggles.PositionSpoof.Value then
                    Toggles.PositionSpoof:SetValue(true)
                end
            elseif Toggles.PositionSpoof.Value then
                Toggles.PositionSpoof:SetValue(false)
                safeDisableGod()
            end
        elseif (AutoMode == 'Hold') then
            local keyCode = Options.PositionSpoofKey and Options.PositionSpoofKey.Value

            if (keyCode and UserInputService:IsKeyDown(keyCode)) then
                if not Toggles.PositionSpoof.Value then
                    Toggles.PositionSpoof:SetValue(true)
                end
            elseif Toggles.PositionSpoof.Value then
                Toggles.PositionSpoof:SetValue(false)
                safeDisableGod()
            end
        elseif (AutoMode == 'Toggle') then
        end
    end)
    task.spawn(function()
        while true do
            task.wait(0.1)

            if getgenv().Library.Unloaded then
                break
            end
            if (Toggles.PositionSpoof and Toggles.PositionSpoof.Value) then
                setGodmode(true)
            end
        end
    end)

    local MovementGroup = Tabs.Player:AddRightGroupbox('移动速度')
local LocalPlayer = game.Players.LocalPlayer
local Unloaded = false
local ClonedCollision
local OldAccel = PhysicalProperties.new(0.01, 0.7, 0, 1, 1)

if (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('CollisionPart')) then
    ClonedCollision = LocalPlayer.Character.CollisionPart:Clone()
    ClonedCollision.Name = '_CollisionClone'
    ClonedCollision.Massless = true
    ClonedCollision.Parent = LocalPlayer.Character
    ClonedCollision.CanCollide = false
    ClonedCollision.CanQuery = false
    ClonedCollision.CustomPhysicalProperties = OldAccel
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1.5)

    if (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('CollisionPart')) then
        ClonedCollision = LocalPlayer.Character.CollisionPart:Clone()
        ClonedCollision.Name = '_CollisionClone'
        ClonedCollision.Massless = true
        ClonedCollision.Parent = LocalPlayer.Character
        ClonedCollision.CanCollide = false
        ClonedCollision.CanQuery = false
        ClonedCollision.CustomPhysicalProperties = OldAccel
    end
end)

-- 方式一：原版速度绕过
task.spawn(function()
    while task.wait(0.23) and not Unloaded do
        if (Toggles.WalkspeedModifier.Value and (Options.WalkspeedAmount.Value > 21) and ClonedCollision) then
            ClonedCollision.Massless = false
            task.wait(0.23)

            if (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and LocalPlayer.Character.HumanoidRootPart.Anchored) then
                ClonedCollision.Massless = true
                task.wait(1)
            end

            ClonedCollision.Massless = true
        end
    end
end)

-- 方式二：EB速度绕过
task.spawn(function()
    while task.wait(0.23) and not Unloaded do
        if Toggles.EB_SpeedBypass.Value then
            if ClonedCollision then
                ClonedCollision.Massless = false
                task.wait(0.23)

                if LocalPlayer.Character.HumanoidRootPart.Anchored then
                    ClonedCollision.Massless = true
                    task.wait(1)
                end

                ClonedCollision.Massless = true
            end
        end
    end
end)

-- 方式三：第三人称
task.spawn(function()
    while task.wait() and not Unloaded do
        if LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and Toggles.VV_Thirdperson.Value and Options.VV_Thirdperson_K:GetState() then
            for _, v in LocalPlayer.Character:GetChildren() do
                if v:IsA("Accessory") then
                    local Clone = v:FindFirstChildWhichIsA("MeshPart"):Clone()
                    Clone.Parent = ThirdpersonParts
                end
            end

            local Clone = LocalPlayer.Character.Head:Clone()
            Clone.Parent = ThirdpersonParts
            Clone.Material = "SmoothPlastic"

            local ThirdpersonRenderstepped = game:GetService("RunService").RenderStepped:Connect(function()
                if Main_Game then
                    if Toggles.VV_ThirdpersonCamCollision.Value then
                        local RaycastParams = RaycastParams.new()
                        RaycastParams.FilterDescendantsInstances = {LocalPlayer.Character, ThirdpersonParts}
                        RaycastParams.FilterType = Enum.RaycastFilterType.Exclude

                        local Direction = (Main_Game.basecamcf * CFrame.new(Options.VV_ThirdpersonOffset.Value, Options.VV_ThirdpersonOffsetUp.Value, 3.5 * (Options.VV_ThirdpersonDistance.Value / 7.5))).Position - Main_Game.basecamcf.Position
                        local Spherecast = workspace:Spherecast(Main_Game.basecamcf.Position, 0.2, Direction, RaycastParams)

                        if Spherecast and Spherecast.Instance.CanCollide and Spherecast.Instance.Transparency < 0.99 then
                            local RayPosition = Main_Game.basecamcf.Position + Direction.Unit * Spherecast.Distance
                            workspace.CurrentCamera.CFrame = CFrame.new(RayPosition, RayPosition + Main_Game.basecamcf.LookVector) * (Toggles.VV_NoCamShake.Value and CFrame.new() or Main_Game.csgo)
                        else
                            workspace.CurrentCamera.CFrame = Main_Game.basecamcf * CFrame.new(Options.VV_ThirdpersonOffset.Value, Options.VV_ThirdpersonOffsetUp.Value, 3.5 * (Options.VV_ThirdpersonDistance.Value / 7.5)) * (Toggles.VV_NoCamShake.Value and CFrame.new() or Main_Game.csgo)
                        end
                    else
                        workspace.CurrentCamera.CFrame = Main_Game.basecamcf * CFrame.new(Options.VV_ThirdpersonOffset.Value, Options.VV_ThirdpersonOffsetUp.Value, 3.5 * (Options.VV_ThirdpersonDistance.Value / 7.5)) * (Toggles.VV_NoCamShake.Value and CFrame.new() or Main_Game.csgo)
                    end
                end
            end)

            repeat task.wait() until Unloaded or not Options.VV_Thirdperson_K:GetState() or not Toggles.VV_Thirdperson.Value
            ThirdpersonRenderstepped:Disconnect()
            ThirdpersonParts:ClearAllChildren()
        end
    end
end)

BypassLabel = MovementGroup:AddLabel('<font color="rgb(255,0,0)">速度绕过: 无法使用</font>')

function updateBypassLabel()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')

    if humanoid then
        realSpeed = humanoid.WalkSpeed
        local active = realSpeed > 21
        local color = (active and '0,255,0') or '255,0,0'
        status = (active and '运行中') or '无法使用'

        BypassLabel:SetText('<font color="rgb(' .. color .. ')">速度绕过: ' .. status .. '</font>')
    end
end

task.spawn(function()
    while task.wait(0.1) and not Unloaded do
        humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')

        if humanoid then
            if Toggles.WalkspeedModifier.Value then
                humanoid.WalkSpeed = Options.WalkspeedAmount.Value
            end
            updateBypassLabel()
        end
    end
end)
MovementGroup:AddDivider()

function bindHumanoid(humanoid)
    humanoid:GetPropertyChangedSignal('WalkSpeed'):Connect(updateBypassLabel)
end

-- 添加下拉框选择绕过方式
MovementGroup:AddDropdown('BypassMethod', {
    Values = {'Default', 'Eioopb', '自动'},
    Default = 1,
    Multi = false,
    Text = '绕过方式',
    Tooltip = '选择速度绕过方式',
})

-- 启用速度绕过Toggle
MovementGroup:AddToggle('EnableSpeedBypass', {
    Text = '启用速度绕过',
    Default = false,
    Tooltip = '启用速度绕过系统',
    Callback = function(Value)
        if Value then
            local method = Options.BypassMethod.Value
            if method == 'Default' then
                Toggles.WalkspeedModifier:SetValue(true)
            elseif method == 'Eioopb' then
                Toggles.EB_SpeedBypass:SetValue(true)
            else
                Toggles.WalkspeedModifier:SetValue(true)
            end
        else
            Toggles.WalkspeedModifier:SetValue(false)
            Toggles.EB_SpeedBypass:SetValue(false)
        end
        updateBypassLabel()
    end
})

MovementGroup:AddCheckbox('WalkspeedModifier', {
    Text = '行走速度',
    Default = false,
    Disabled = false,
    Tooltip = '将您的步行速度更改为设定值.',
    Callback = function(Value)
        updateBypassLabel()
    end,
})
MovementGroup:AddCheckbox('NoAcceleration', {
    Text = '瞬时加速',
    Default = false,
    Disabled = false,
    Tooltip = '更改方向时消除减速.',
    Callback = function(Value)
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
        if hrp then
            hrp.CustomPhysicalProperties = (Value and PhysicalProperties.new(100, 0, 0, 0, 0)) or OldAccel
        end
    end,
})
MovementGroup:AddSlider('WalkspeedAmount', {
    Text = '行走速度',
    Default = 21,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Compact = true,
    Tooltip = '设置您的步行速度.',
    Callback = function(Value)
        updateBypassLabel()
    end,
})
    LocalPlayer.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild('Humanoid')

        bindHumanoid(humanoid)
        updateBypassLabel()
    end)

    if (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')) then
        bindHumanoid(LocalPlayer.Character.Humanoid)
    end

    updateBypassLabel()

    MovementGroupZ = Tabs.Player:AddLeftGroupbox('移动')

    MovementGroupZ:AddCheckbox('AlwaysJump', {
        Text = '始终可跳',
        Default = false,
        Disabled = false,
        Tooltip = '让您随时跳跃.',
        Callback = function(Value)
            LocalPlayer.Character:SetAttribute('CanJump', Value or CanJump)
        end,
    })

    isFlying = false
    flyConnections = {}
    keys = {
        W = false,
        A = false,
        S = false,
        D = false,
        Space = false,
        Shift = false,
    }
    FlySpeed = 50

    function startFly()
        player = game.Players.LocalPlayer
        character = player.Character

        if not character then
            return
        end

        humanoid = character:FindFirstChildOfClass('Humanoid')

        if not humanoid then
            return
        end

        hrp = character:FindFirstChild('HumanoidRootPart')

        if not hrp then
            return
        end

        bv = Instance.new('BodyVelocity')
        bv.Name = 'FlyVelocity'
        bv.MaxForce = Vector3.new(1000000000, 1000000000, 1000000000)
        bv.Velocity = Vector3.new(0, 0, 0)
        bv.Parent = hrp
        bg = Instance.new('BodyGyro')
        bg.Name = 'FlyGyro'
        bg.MaxTorque = Vector3.new(1000000000, 1000000000, 1000000000)
        bg.P = 20000
        bg.D = 1000
        bg.Parent = hrp
        humanoid.AutoRotate = false
        humanoid.PlatformStand = true

        humanoid:ChangeState(Enum.HumanoidStateType.Physics)

        inputBegan = game:GetService('UserInputService').InputBegan:Connect(function(input, gpe)
            if gpe then
                return
            end
            if (input.KeyCode == Enum.KeyCode.W) then
                keys.W = true
            elseif (input.KeyCode == Enum.KeyCode.A) then
                keys.A = true
            elseif (input.KeyCode == Enum.KeyCode.S) then
                keys.S = true
            elseif (input.KeyCode == Enum.KeyCode.D) then
                keys.D = true
            elseif (input.KeyCode == Enum.KeyCode.Space) then
                keys.Space = true
            elseif (input.KeyCode == Enum.KeyCode.LeftShift) then
                keys.Shift = true
            end
        end)

        table.insert(flyConnections, inputBegan)

        local inputEnded = game:GetService('UserInputService').InputEnded:Connect(function(input)
            if (input.KeyCode == Enum.KeyCode.W) then
                keys.W = false
            elseif (input.KeyCode == Enum.KeyCode.A) then
                keys.A = false
            elseif (input.KeyCode == Enum.KeyCode.S) then
                keys.S = false
            elseif (input.KeyCode == Enum.KeyCode.D) then
                keys.D = false
            elseif (input.KeyCode == Enum.KeyCode.Space) then
                keys.Space = false
            elseif (input.KeyCode == Enum.KeyCode.LeftShift) then
                keys.Shift = false
            end
        end)

        table.insert(flyConnections, inputEnded)

        local renderConnection = game:GetService('RunService').RenderStepped:Connect(function()
            local cam = workspace.CurrentCamera

            if (not cam or not hrp or not hrp:FindFirstChild('FlyVelocity') or not humanoid or (humanoid.Health <= 0)) then
                stopFly()

                return
            end

            local move = Vector3.new(0, 0, 0)

            if keys.W then
                move = move + cam.CFrame.LookVector
            end
            if keys.S then
                move = move - cam.CFrame.LookVector
            end
            if keys.A then
                move = move - cam.CFrame.RightVector
            end
            if keys.D then
                move = move + cam.CFrame.RightVector
            end
            if keys.Space then
                move = move + Vector3.new(0, 1, 0)
            end
            if keys.Shift then
                move = move - Vector3.new(0, 1, 0)
            end

            local direction = ((move.Magnitude > 0) and (move.Unit * FlySpeed)) or Vector3.new(0, 0, 0)

            bv.Velocity = direction
            bg.CFrame = cam.CFrame
        end)

        table.insert(flyConnections, renderConnection)
    end

    local function stopFly()
        local player = game.Players.LocalPlayer
        local character = player.Character
        local humanoid = character and character:FindFirstChildOfClass('Humanoid')
        local hrp = character and character:FindFirstChild('HumanoidRootPart')

        if hrp then
            local flyVelocity = hrp:FindFirstChild('FlyVelocity')

            if flyVelocity then
                flyVelocity:Destroy()
            end

            local flyGyro = hrp:FindFirstChild('FlyGyro')

            if flyGyro then
                flyGyro:Destroy()
            end
        end
        if humanoid then
            humanoid.AutoRotate = true
            humanoid.PlatformStand = false

            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end

        for _, conn in ipairs(flyConnections)do
            conn:Disconnect()
        end

        flyConnections = {}
        keys = {
            W = false,
            A = false,
            S = false,
            D = false,
            Space = false,
            Shift = false,
        }
    end

    MovementGroupZ:AddCheckbox('Fly', {
        Text = '飞行',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            isFlying = Value

            if Value then
                startFly()
            else
                stopFly()
            end
        end,
    }):AddKeyPicker('FlyKeybind', {
        Default = 'F',
        SyncToggleState = true,
        Mode = 'Toggle',
        Text = '飞行 Toggle',
        NoUI = false,
        Callback = function(Value) end,
    })

    local Players = game:GetService('Players')
    local RunService = game:GetService('RunService')
    local lp = Players.LocalPlayer
    local noclipConnection
    local originalGroups = {}

    local function enableNoclip()
        if noclipConnection then
            return
        end

        noclipConnection = RunService.Stepped:Connect(function()
            if lp.Character then
                for _, part in pairs(lp.Character:GetDescendants())do
                    if part:IsA('BasePart') then
                        part.CanCollide = false

                        if not originalGroups[part] then
                            originalGroups[part] = part.CollisionGroup
                        end

                        part.CollisionGroup = 'Default'
                    end
                end
            end
        end)
    end
    local function disableNoclip()
        if noclipConnection then
            noclipConnection:Disconnect()

            noclipConnection = nil
        end

        local char = lp.Character

        if not char then
            return
        end

        local collision = char:FindFirstChild('Collision')
        local crouch = collision and collision:FindFirstChild('CollisionCrouch')

        if (collision and crouch) then
            local crouching = collision.CollisionGroup == 'PlayerCrouching'

            collision.CanCollide = not crouching
            crouch.CanCollide = crouching
        end
    end

    MovementGroupZ:AddCheckbox('Noclip', {
        Text = '穿墙',
        Default = false,
        Disabled = false,
        Tooltip = '你知道它的作用',
        Callback = function(Value)
            if Value then
                enableNoclip()
            else
                disableNoclip()
            end
        end,
    }):AddKeyPicker('NoclipKeybind', {
        Default = 'N',
        SyncToggleState = true,
        Mode = 'Toggle',
        Text = '穿墙切换',
        NoUI = false,
        Callback = function(Value) end,
    })
    game.Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        if isFlying then
            newCharacter:WaitForChild('HumanoidRootPart')
            newCharacter:WaitForChild('Humanoid')
            startFly()
        end
    end)
    game.Players.LocalPlayer.CharacterRemoving:Connect(function()
        if isFlying then
            stopFly()
        end
    end)

    local RunService = game:GetService('RunService')

    MovementGroupZ:AddCheckbox('LadderSpeedBoost', {
        Text = '更快爬梯',
        Default = false,
        Disabled = false,
        Callback = function(on)
            if on then
                AntiConnections.LadderBoost = RunService.Heartbeat:Connect(function()
                    local char = LocalPlayer.Character
                    local hum = char and char:FindFirstChildOfClass('Humanoid')
                    local hrp = char and char:FindFirstChild('HumanoidRootPart')

                    if (hum and hrp and (hum:GetState() == Enum.HumanoidStateType.Climbing)) then
                        hrp.Velocity = Vector3.new(hrp.Velocity.X, Options.LadderSpeedBoostAmount.Value, hrp.Velocity.Z)
                    end
                end)
            elseif AntiConnections.LadderBoost then
                AntiConnections.LadderBoost:Disconnect()

                AntiConnections.LadderBoost = nil
            end
        end,
    })

    local Players = game:GetService('Players')
    local RunService = game:GetService('RunService')
    local Camera = workspace.CurrentCamera
    local LocalPlayer = Players.LocalPlayer
    local PlayerGui = LocalPlayer:WaitForChild('PlayerGui')
    local UserInputService = game:GetService('UserInputService')
    local savedCamCFrame
    local camLocked = false
    local acmButton
    local acmButtonActive = false
    local BUTTON_SIZE = UDim2.new(0, 70, 0, 35)
    local BUTTON_POSITION = UDim2.new(1, -80, 0.5, -17)
    local BUTTON_COLOR = Color3.fromRGB(45, 45, 45)
    local BUTTON_ACTIVE_COLOR = Color3.fromRGB(90, 90, 90)
    local BUTTON_TEXT_COLOR = Color3.fromRGB(255, 255, 255)

    MovementGroupZ:AddCheckbox('AntiCheatManipulation', {
        Text = '反作弊操控',
        Default = false,
    }):AddKeyPicker('AntiCheatManipulation_K', {
        Default = 'T',
        Mode = 'Hold',
        Text = '反作弊操控',
    })

    local function createACMButton()
        if (not UserInputService.TouchEnabled or acmButton) then
            return
        end

        local screenGui = Instance.new('ScreenGui')

        screenGui.Name = 'ACMGui'
        screenGui.ResetOnSpawn = false
        screenGui.Parent = PlayerGui

        local button = Instance.new('TextButton')

        button.Name = 'ACMButton'
        button.Size = BUTTON_SIZE
        button.Position = BUTTON_POSITION
        button.BackgroundColor3 = BUTTON_COLOR
        button.Text = 'ACM'
        button.TextColor3 = BUTTON_TEXT_COLOR
        button.Font = Enum.Font.GothamBold
        button.TextSize = 16
        button.BorderSizePixel = 0
        button.Parent = screenGui

        button.MouseButton1Down:Connect(function()
            acmButtonActive = true
            button.BackgroundColor3 = BUTTON_ACTIVE_COLOR
        end)
        button.MouseButton1Up:Connect(function()
            acmButtonActive = false
            button.BackgroundColor3 = BUTTON_COLOR
        end)

        acmButton = screenGui
    end
    local function removeACMButton()
        if acmButton then
            acmButton:Destroy()

            acmButton = nil
            acmButtonActive = false
        end
    end

    Toggles.AntiCheatManipulation:OnChanged(function()
        if Toggles.AntiCheatManipulation.Value then
            createACMButton()
        else
            removeACMButton()
        end
    end)
    RunService.RenderStepped:Connect(function()
        local cam = workspace.CurrentCamera

        if not cam then
            return
        end

        local active = (Toggles.AntiCheatManipulation.Value and Options.AntiCheatManipulation_K:GetState()) or acmButtonActive
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')

        if (active and hrp) then
            if not camLocked then
                savedCamCFrame = cam.CFrame
                cam.CameraType = Enum.CameraType.Scriptable
                camLocked = true
                hrp.CFrame = hrp.CFrame * CFrame.new(0, 0, 10000)
            end

            cam.CFrame = savedCamCFrame
        elseif camLocked then
            cam.CameraType = Enum.CameraType.Custom
            camLocked = false
            savedCamCFrame = nil
        end
    end)
    MovementGroupZ:AddSlider('LadderSpeedBoostAmount', {
        Text = '爬梯速度',
        Default = 20,
        Min = 0,
        Max = 100,
        Rounding = 0,
        Compact = true,
        Tooltip = [[Boost for climbing ladders. Higher values might be unstable.]],
    })

    local FlySpeed = 50

    MovementGroupZ:AddSlider('Fly Speed', {
        Text = '飞行速度',
        Default = FlySpeed,
        Min = 0,
        Max = 150,
        Rounding = 0,
        Compact = true,
        Tooltip = '更改飞行速度',
        Callback = function(Value)
            FlySpeed = Value
        end,
    })

    local BypassGroupp = Tabs.Player:AddRightGroupbox('Bypass')
    local Players = game:GetService('Players')
    local LocalPlayer = Players.LocalPlayer

    BypassGroupp:AddButton('DisableAntiCheat', {
        Text = '关闭反作弊',
        Tooltip = '这将是错误的有时，但大多数工作',
        Visible = replicatesignal ~= nil,
        Func = function()
            local currentRoom = LocalPlayer:GetAttribute('CurrentRoom')

            if (currentRoom == 0) then
                replicatesignal(LocalPlayer.Kill)
                Library:Notify('Anti Cheat has been disabled, you can fly trough everything', 10)
            else
                Library:Notify('You have to do this in the elevator', 5)
            end
        end,
    })
    BypassGroupp:AddCheckbox('AnticheatBypass', {
        Text = '反作弊绕过',
        Default = false,
    })
    Toggles.AnticheatBypass:OnChanged(function(Value)
        if not Value then
            RemoteFolder.ClimbLadder:FireServer()
        else
            Library:Notify('get on a ladder', 9)
        end
    end)
    LocalPlayer.Character:GetAttributeChangedSignal('Climbing'):Connect(function()
        if (Toggles.AnticheatBypass.Value and (LocalPlayer.Character:GetAttribute('Climbing') == true)) then
            task.spawn(function()
                task.wait(0.1)
                LocalPlayer.Character:SetAttribute('Climbing', false)
                Library:Notify('Bypassed anticheat, climb reset', 7)
            end)
        end
    end)

    local AutomationGroup = Tabs.Player:AddRightGroupbox('自动化')
    local Players = game:GetService('Players')
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService('Workspace')
    local running = false

    AutomationGroup:AddCheckbox('AnchorCodeSolver', {
        Text = '锚点代码解算',
        Default = false,
        Disabled = false,
        Callback = function(enabled)
            if enabled then
                if running then
                    return
                end

                running = true

                task.spawn(function()
                    local playerGui = LocalPlayer:WaitForChild('PlayerGui')

                    local function findFrame()
                        local mainUI = playerGui:FindFirstChild('MainUI')

                        if (mainUI and mainUI:FindFirstChild('MainFrame')) then
                            local frame = mainUI.MainFrame:FindFirstChild('AnchorHintFrame')

                            if frame then
                                return frame
                            end
                        end

                        local anchorUI = playerGui:FindFirstChild('AnchorHintUI')

                        if anchorUI then
                            local frame = anchorUI:FindFirstChild('AnchorHintFrame')

                            if frame then
                                return frame
                            end
                        end

                        return nil
                    end

                    while running do
                        task.wait(0.9)

                        local frame = findFrame()

                        if frame then
                            local anchorName = (frame:FindFirstChild('AnchorCode') and frame.AnchorCode.Text) or ''
                            local codeText = (frame:FindFirstChild('Code') and frame.Code.Text) or ''

                            if ((anchorName ~= '') and (codeText ~= '')) then
                                local anchorObject

                                for _, obj in ipairs(Workspace.CurrentRooms:GetDescendants())do
                                    if (obj.Name == 'MinesAnchor') then
                                        local sign = obj:FindFirstChild('Sign')

                                        if sign then
                                            local label = sign:FindFirstChild('TextLabel') or sign:FindFirstChildWhichIsA('TextLabel')

                                            if (label and (label.Text == anchorName)) then
                                                anchorObject = obj

                                                break
                                            end
                                        end
                                    end
                                end

                                if anchorObject then
                                    local note = anchorObject:FindFirstChild('Note')

                                    if not note then
                                        Library:Notify(string.format('Anchor %s Code is %s', anchorName, codeText), 3)
                                    else
                                        local surfaceGui = note:FindFirstChildOfClass('SurfaceGui') or note:FindFirstChild('SurfaceGui')
                                        local noteText = (surfaceGui and surfaceGui:FindFirstChild('TextLabel') and surfaceGui.TextLabel.Text) or '0'
                                        local noteValue = tonumber(noteText) or 0
                                        local solved = ''

                                        for i = 1, #codeText do
                                            local digit = tonumber(codeText:sub(i, i)) or 0

                                            digit = (digit + noteValue) % 10
                                            solved = solved .. tostring(digit)
                                        end

                                        Library:Notify(string.format('Anchor %s Code is %s', anchorName, solved), 5)
                                    end
                                end
                            end
                        else
                            task.wait(0.25)
                        end
                    end
                end)
            else
                running = false
            end
        end,
    })

    local Players = game:GetService('Players')
    local VirtualUser = game:GetService('VirtualUser')
    local LocalPlayer = Players.LocalPlayer
    local AntiAFKConnection

    AutomationGroup:AddCheckbox('AntiAFK', {
        Text = '防挂机',
        Visible = getconnections ~= nil,
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if Value then
                AntiAFKConnection = LocalPlayer.Idled:Connect(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                end)
            elseif AntiAFKConnection then
                AntiAFKConnection:Disconnect()

                AntiAFKConnection = nil
            end
        end,
    })

    local Script = {}

    Script.Functions = {}
    Script.Temp = {}
    Script.PromptTable = {}
    Script.PromptTable.GamePrompts = {}
    shared.Connections = {}

    local Players = game:GetService('Players')
    local ReplicatedStorage = game:GetService('ReplicatedStorage')
    local LocalPlayer = Players.LocalPlayer
    local Breaker = nil
    local RemoteFolder = ReplicatedStorage:FindFirstChild('RemotesFolder') or ReplicatedStorage:FindFirstChild('EntityInfo') or ReplicatedStorage:FindFirstChild('Bricks')

    AutomationGroup:AddCheckbox('AutoBreakerSolver', {
        Text = '自动破译小游戏',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            while task.wait() do
                if not Toggles.AutoBreakerSolver.Value then
                    break
                end

                local currentRoom = LocalPlayer:GetAttribute('CurrentRoom')

                if (currentRoom ~= 100) then
                    Library:Notify([[You have to do this in room 100 otherwise your FPS goes in the -'s]], 5)

                    break
                end

                Breaker = nil

                for _, v in ipairs(workspace.CurrentRooms:GetDescendants())do
                    if (v.Name == 'ElevatorBreaker') then
                        Breaker = v

                        break
                    end
                end

                if Breaker then
                    local solved = true

                    for _, v in ipairs(Breaker:GetChildren())do
                        if (v.Name == 'BreakerSwitch') then
                            local codeText = Breaker:WaitForChild('SurfaceGui').Frame.Code.Text

                            if (v:GetAttribute('ID') == tonumber(codeText)) then
                                if (Breaker.SurfaceGui.Frame.Code.Frame.BackgroundTransparency == 0) then
                                    v:SetAttribute('Enabled', true)

                                    if not v.Sound.Playing then
                                        v.Sound.Playing = true
                                    end

                                    v.Material = Enum.Material.Neon

                                    v.Light.Attachment.Spark:Emit(1)

                                    v.PrismaticConstraint.TargetPosition = -0.2
                                else
                                    v:SetAttribute('Enabled', false)

                                    if not v.Sound.Playing then
                                        v.Sound.Playing = true
                                    end

                                    v.PrismaticConstraint.TargetPosition = 0.2
                                    v.Material = Enum.Material.Glass
                                    solved = false
                                end
                            end
                        end
                    end

                    if (solved and RemoteFolder) then
                        local breakerRemote = RemoteFolder:FindFirstChild('BreakerMinigame')

                        if breakerRemote then
                            breakerRemote:FireServer('Solved')
                        end
                    end
                end
            end
        end,
    })

    local function HasItem(itemName)
        return LocalPlayer.Character:FindFirstChild(itemName) or LocalPlayer.Backpack:FindFirstChild(itemName)
    end
    local function extractPadlockCode()
        local Paper = HasItem('LibraryHintPaper')

        if not Paper then
            for _, Player in Players:GetPlayers()do
                if ((Player ~= LocalPlayer) and (Player.Character:FindFirstChild('LibraryHintPaper') or Player.Backpack:FindFirstChild('LibraryHintPaper'))) then
                    Paper = Player.Character:FindFirstChild('LibraryHintPaper') or Player.Backpack:FindFirstChild('LibraryHintPaper')

                    break
                end
            end
        end
        if not Paper then
            return nil, 'No LibraryHintPaper found'
        end
        if not Paper:FindFirstChild('UI') then
            return nil, 'LibraryHintPaper has no UI'
        end

        local Code = ''
        local symbolsFound = 0

        for _, x in pairs(Paper.UI:GetChildren())do
            if tonumber(x.Name) then
                symbolsFound = symbolsFound + 1

                for _, y in pairs(LocalPlayer.PlayerGui.PermUI.Hints:GetChildren())do
                    if (y.Name == 'Icon') then
                        if (y.ImageRectOffset == x.ImageRectOffset) then
                            Code = Code .. y.TextLabel.Text
                        end
                    end
                end
            end
        end

        if (#Code == 5) then
            return Code, 'success'
        elseif (symbolsFound > 0) then
            return nil, '丢失的书籍-仅找到 ' .. symbolsFound .. ' 共5个符号'
        else
            return nil, '纸张上找不到符号'
        end
    end

    AutomationGroup:AddButton('solvecode', {
        Text = '自动破解图书馆代码',
        Visible = getsenv ~= nil,
        Tooltip = '解决库代码',
        Func = function()
            local code, status = extractPadlockCode()

            if code then
                Library:Notify('Library Code: ' .. code, 3)
                print('[库求解器]挂锁代码为: ' .. code)

                local padlock = workspace:FindFirstChild('Padlock', true)

                if padlock then
                    local padlockPart = padlock.PrimaryPart or padlock:FindFirstChildWhichIsA('BasePart')

                    if (padlockPart and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')) then
                        local distance = (LocalPlayer.Character.HumanoidRootPart.Position - padlockPart.Position).Magnitude

                        if ((distance <= 20) and tonumber(code)) then
                            local ReplicatedStorage = game:GetService('ReplicatedStorage')
                            local RemotesFolder = ReplicatedStorage:WaitForChild('RemotesFolder')
                            local remote = RemotesFolder:FindFirstChild('PL')

                            if remote then
                                remote:FireServer(tonumber(code))
                            end
                        end
                    end
                end
            else
                Library:Notify(status or '找不到代码', 2)
            end
        end,
    })

    local originalRanges = {}
    local rangeConnections = {}

    local function updateProximityPromptRanges(multiplier)
        local function modifyPrompt(prompt)
            if not originalRanges[prompt] then
                originalRanges[prompt] = prompt.MaxActivationDistance
            end

            prompt.MaxActivationDistance = originalRanges[prompt] * multiplier
        end

        for _, descendant in pairs(workspace:GetDescendants())do
            if descendant:IsA('ProximityPrompt') then
                modifyPrompt(descendant)
            end
        end
        for _, player in pairs(game.Players:GetPlayers())do
            if player.PlayerGui then
                for _, descendant in pairs(player.PlayerGui:GetDescendants())do
                    if descendant:IsA('ProximityPrompt') then
                        modifyPrompt(descendant)
                    end
                end
            end
        end
    end
    local function setupRangeConnections(multiplier)
        for _, connection in pairs(rangeConnections)do
            connection:Disconnect()
        end

        rangeConnections = {}

        table.insert(rangeConnections, workspace.DescendantAdded:Connect(function(descendant)
            if descendant:IsA('ProximityPrompt') then
                task.wait(0.1)

                originalRanges[descendant] = descendant.MaxActivationDistance
                descendant.MaxActivationDistance = originalRanges[descendant] * multiplier
            end
        end))

        for _, player in pairs(game.Players:GetPlayers())do
            if player.PlayerGui then
                table.insert(rangeConnections, player.PlayerGui.DescendantAdded:Connect(function(descendant)
                    if descendant:IsA('ProximityPrompt') then
                        task.wait(0.1)

                        originalRanges[descendant] = descendant.MaxActivationDistance
                        descendant.MaxActivationDistance = originalRanges[descendant] * multiplier
                    end
                end))
            end
        end
    end

    AutomationGroup:AddButton({
        Text = '快速通过200门',
        Visible = fireproximityprompt ~= nil,
        Func = function()
            local player = game.Players.LocalPlayer
            local char = player.Character or player.CharacterAdded:Wait()
            local root = char:WaitForChild('HumanoidRootPart')
            local speed = 65

            local function flyTo(target)
                while(root.Position - target.Position).Magnitude > 6 do
                    local dir = (target.Position - root.Position).Unit

                    root.CFrame = root.CFrame + (dir * speed * task.wait())
                end

                char:PivotTo(target.CFrame)
            end

            local startPos = root.CFrame
            local room = workspace.CurrentRooms:FindFirstChild(tostring(game.ReplicatedStorage.GameData.LatestRoom.Value))

            if not room then
                Library:Notify('bud is NOT in room 200', 3)

                return
            end

            local damHandler = room:FindFirstChild('_DamHandler')

            if not damHandler then
                Library:Notify('bud is NOT in room 200', 3)

                return
            end
            if (damHandler:FindFirstChild('PlayerBarriers1') and damHandler:FindFirstChild('Flood1')) then
                for _, pump in pairs(damHandler.Flood1.Pumps:GetChildren())do
                    flyTo(pump.Wheel)
                    task.wait(0.25)
                    fireproximityprompt(pump.Wheel.ValvePrompt)
                    task.wait(0.25)
                end

                task.wait(8)
            end
            if (damHandler:FindFirstChild('PlayerBarriers2') and damHandler:FindFirstChild('Flood2')) then
                for _, pump in pairs(damHandler.Flood2.Pumps:GetChildren())do
                    flyTo(pump.Wheel)
                    task.wait(0.25)
                    fireproximityprompt(pump.Wheel.ValvePrompt)
                    task.wait(0.25)
                end

                task.wait(8)
            end
            if (damHandler:FindFirstChild('PlayerBarriers3') and damHandler:FindFirstChild('Flood3')) then
                for _, pump in pairs(damHandler.Flood3.Pumps:GetChildren())do
                    flyTo(pump.Wheel)
                    task.wait(0.25)
                    fireproximityprompt(pump.Wheel.ValvePrompt)
                    task.wait(0.25)
                end

                task.wait(10)
            end

            local generator = room:FindFirstChild('MinesGenerator', true)

            if generator then
                flyTo(generator.PrimaryPart)
                task.wait(0.25)
                fireproximityprompt(generator.Lever.LeverPrompt)
                task.wait(0.25)
            end

            char:PivotTo(startPos)
        end,
    })

    local ESPSettings = Tabs.Visuals:AddLeftGroupbox('ESP 设置')
    local ESPLibrary = loadstring(game:HttpGet([[https://raw.githubusercontent.com/mstudio45/MSESP/refs/heads/main/source.luau]]))()

    ESPLibrary.GlobalConfig.Distance = false

    local function recreateAllESP()
        local espTypes = {
            'Door',
            'Coin',
            'Key',
            'Fuse',
            'MinesGenerator',
            'Lever',
            'Item',
            'Closet',
            'Anchor',
            'LibraryBook',
            'VineCutter',
            'Chest',
            'Figure',
            'Ambush',
            'Rush',
            'Snare',
            'Giggle',
            'Eyestalk',
            'Mandrake',
            'Groundskeeper',
            'Blitz',
        }

        for _, espType in pairs(espTypes)do
            local elementsVar = espType .. 'ESP_Elements'

            if _G[elementsVar] then
                local AllowedModels = {}

                if (espType == 'Door') then
                    AllowedModels = {Door = true}
                end
                if (espType == 'Coin') then
                    AllowedModels = {GoldPile = true}
                end
                if (espType == 'Key') then
                    AllowedModels = {KeyObtain = true}
                end
                if (espType == 'Fuse') then
                    AllowedModels = {FuseObtain = true}
                end
                if (espType == 'MinesGenerator') then
                    AllowedModels = {MinesGenerator = true}
                end
                if (espType == 'Lever') then
                    AllowedModels = {LeverForGate = true}
                end
                if (espType == 'Item') then
                    AllowedModels = {
                        AlarmClock = true,
                        Aloe = true,
                        BandagePack = true,
                        Battery = true,
                        TimerLever = true,
                        OuterPart = true,
                        BatteryPack = true,
                        Candle = true,
                        LiveBreakerPolePickup = true,
                        Compass = true,
                        Crucifix = true,
                        ElectricalRoomKey = true,
                        Flashlight = true,
                        Glowstick = true,
                        HolyHandGrenade = true,
                        Lantern = true,
                        LaserPointer = true,
                        Lighter = true,
                        Lockpick = true,
                        LotusFlower = true,
                        LotusPetalPickup = true,
                        Multitool = true,
                        NVCS3000 = true,
                        OutdoorsKey = true,
                        Shears = true,
                        SkeletonKey = true,
                        Smoothie = true,
                        SolutionPaper = true,
                        Spotlight = true,
                        StarlightVial = true,
                        StarlightJug = true,
                        StarlightBottle = true,
                        Vitamins = true,
                    }
                end
                if (espType == 'Closet') then
                    AllowedModels = {
                        Wardrobe = true,
                        Toolshed = true,
                        Locker_Large = true,
                        Backdoor_Wardrobe = true,
                    }
                end
                if (espType == 'Anchor') then
                    AllowedModels = {MinesAnchor = true}
                end
                if (espType == 'LibraryBook') then
                    AllowedModels = {LiveHintBook = true}
                end
                if (espType == 'VineCutter') then
                    AllowedModels = {VineGuillotine = true}
                end
                if (espType == 'Chest') then
                    AllowedModels = {
                        ChestBox = true,
                        ChestBoxLocked = true,
                    }
                end
                if (espType == 'Figure') then
                    AllowedModels = {FigureRig = true}
                end
                if (espType == 'Ambush') then
                    AllowedModels = {AmbushMoving = true}
                end
                if (espType == 'Rush') then
                    AllowedModels = {RushMoving = true}
                end
                if (espType == 'Snare') then
                    AllowedModels = {Snare = true}
                end
                if (espType == 'Giggle') then
                    AllowedModels = {GiggleCeiling = true}
                end
                if (espType == 'Eyestalk') then
                    AllowedModels = {EyestalkMoving = true}
                end
                if (espType == 'Mandrake') then
                    AllowedModels = {Mandrake = true}
                end
                if (espType == 'Groundskeeper') then
                    AllowedModels = {Groundskeeper = true}
                end
                if (espType == 'Blitz') then
                    AllowedModels = {BackdoorRush = true}
                end

                local oldElements = _G[elementsVar]

                _G[elementsVar] = {}

                for _, obj in pairs(oldElements or {})do
                    local espElement = oldElements[obj]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                local colorOption = Options[espType .. 'ESP_Color'].Value
                local name = espType

                if (espType == 'Coin') then
                    name = 'Gold'
                end
                if (espType == 'MinesGenerator') then
                    name = 'Mines Generator'
                end
                if (espType == 'LibraryBook') then
                    name = 'Library Book'
                end
                if (espType == 'VineCutter') then
                    name = 'Vine Cutter'
                end
                if ((espType == 'Item') or (espType == 'Closet') or (espType == 'Anchor') or (espType == 'Chest')) then
                    name = v.Name
                end
                if (espType == 'Figure') then
                    name = 'Figure'
                end
                if (espType == 'Ambush') then
                    name = 'Ambush'
                end
                if (espType == 'Rush') then
                    name = 'Rush'
                end
                if (espType == 'Snare') then
                    name = 'Snare'
                end
                if (espType == 'Giggle') then
                    name = 'Giggle'
                end
                if (espType == 'Eyestalk') then
                    name = 'Eyestalk'
                end
                if (espType == 'Mandrake') then
                    name = 'Mandrake'
                end
                if (espType == 'Groundskeeper') then
                    name = 'Groundskeeper'
                end
                if (espType == 'Blitz') then
                    name = 'Blitz'
                end

                for _, v in pairs(workspace:GetDescendants())do
                    if (v:IsA('Model') and AllowedModels[v.Name]) then
                        local target = v

                        if (espType == 'Door') then
                            target = v:FindFirstChild('Door')
                        end
                        if ((espType == 'Ambush') or (espType == 'Rush')) then
                            target = v:FindFirstChild('RushNew')
                        end
                        if (espType == 'Blitz') then
                            target = v:FindFirstChild('Main')
                        end
                        if (espType == 'Chest') then
                            target = v.PrimaryPart or v:FindFirstChildWhichIsA('BasePart')
                        end
                        if (target and not table.find(_G[elementsVar], target)) then
                            local espElement = ESPLibrary:Add({
                                Name = name,
                                Model = target,
                                Color = colorOption,
                                MaxDistance = 1000,
                                TextSize = 17,
                                ESPType = _G.ESPType or 'Highlight',
                                FillColor = colorOption,
                                OutlineColor = colorOption,
                                FillTransparency = 0.6,
                                OutlineTransparency = 0,
                                Tracer = {
                                    Enabled = _G.EnableTracers,
                                    Color = colorOption,
                                    From = 'Bottom',
                                },
                                Arrow = {
                                    Enabled = _G.EnableArrows,
                                    Color = colorOption,
                                },
                            })

                            table.insert(_G[elementsVar], target)

                            _G[elementsVar][target] = espElement
                        end
                    end
                end
            end
        end
    end

    ESPSettings:AddCheckbox('EnableTracers', {
        Text = '启用轨迹线',
        Default = false,
        Disabled = false,
        Tooltip = '启用所有esps的追踪器',
        Callback = function(Value)
            _G.EnableTracers = Value

            recreateAllESP()
        end,
    })
    ESPSettings:AddCheckbox('EnableArrows', {
        Text = '启用箭头',
        Default = false,
        Disabled = false,
        Tooltip = '为所有esps启用箭头',
        Callback = function(Value)
            _G.EnableArrows = Value

            recreateAllESP()
        end,
    })
    ESPSettings:AddDropdown('ESPType', {
        Text = '透视类型',
        Default = 'Highlight',
        Multi = false,
        Values = {
            'Text',
            'SphereAdornment',
            'CylinderAdornment',
            'Adornment',
            'SelectionBox',
            'Highlight',
        },
        Tooltip = '为所有esps选择esp效果',
        Callback = function(Value)
            _G.ESPType = Value

            recreateAllESP()
        end,
    })

    local VisualsGroup = Tabs.Visuals:AddLeftGroupbox('Object ESP')

    VisualsGroup:AddCheckbox('DoorESP', {
        Text = '门透视',
        Default = false,
        Tooltip = '显示带有跟踪符号和箭头的穿过墙的门',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local Workspace = game:GetService('Workspace')
            local Rooms = Workspace:WaitForChild('CurrentRooms')
            local AllowedDoorModels = {Door = true}

            _G.DoorESP_Elements = _G.DoorESP_Elements or {}
            _G.DoorESP_Color = _G.DoorESP_Color or Color3.fromRGB(255, 255, 255)
            _G._LastDoorColor = _G.DoorESP_Color

            local function addESP(model)
                if not AllowedDoorModels[model.Name] then
                    return
                end

                local mesh = model:FindFirstChild('Door')

                if (mesh and mesh:IsA('BasePart') and not _G.DoorESP_Elements[mesh]) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Door',
                        Model = mesh,
                        Color = _G.DoorESP_Color,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = _G.DoorESP_Color,
                        OutlineColor = _G.DoorESP_Color,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = _G.DoorESP_Color,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = _G.DoorESP_Color,
                        },
                    })

                    _G.DoorESP_Elements[mesh] = espElement
                end
            end
            local function removeESP(mesh)
                local espElement = _G.DoorESP_Elements[mesh]

                if espElement then
                    espElement:Destroy()

                    _G.DoorESP_Elements[mesh] = nil
                end
            end

            if Value then
                for _, v in pairs(Rooms:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                _G.DoorESP_Add = Rooms.DescendantAdded:Connect(function(v)
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end)
                _G.DoorESP_Remove = Rooms.DescendantRemoving:Connect(function(v)
                    local mesh = v:FindFirstChild('Door')

                    if mesh then
                        removeESP(mesh)
                    end
                end)

                local lastPos = nil

                _G.DoorESP_Update = RunService.Heartbeat:Connect(function()
                    local player = Players.LocalPlayer

                    if not player.Character then
                        return
                    end

                    local root = player.Character:FindFirstChild('HumanoidRootPart')

                    if not root then
                        return
                    end
                    if (lastPos and ((root.Position - lastPos).Magnitude < 3)) then
                        return
                    end

                    lastPos = root.Position

                    local currentColor = _G.DoorESP_Color
                    local colorChanged = currentColor ~= _G._LastDoorColor

                    for mesh, espElement in pairs(_G.DoorESP_Elements)do
                        if (mesh and mesh.Parent) then
                            local dist = (root.Position - mesh.Position).Magnitude

                            espElement.CurrentSettings.Name = ('Door\n%d studs'):format(dist)

                            if colorChanged then
                                espElement.CurrentSettings.Color = currentColor
                                espElement.CurrentSettings.FillColor = currentColor
                                espElement.CurrentSettings.OutlineColor = currentColor
                                espElement.CurrentSettings.Tracer.Color = currentColor
                                espElement.CurrentSettings.Arrow.Color = currentColor
                            end

                            espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                            espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                        else
                            removeESP(mesh)
                        end
                    end

                    if colorChanged then
                        _G._LastDoorColor = currentColor
                    end
                end)
            else
                if _G.DoorESP_Add then
                    _G.DoorESP_Add:Disconnect()
                end
                if _G.DoorESP_Remove then
                    _G.DoorESP_Remove:Disconnect()
                end
                if _G.DoorESP_Update then
                    _G.DoorESP_Update:Disconnect()
                end

                _G.DoorESP_Add, _G.DoorESP_Remove, _G.DoorESP_Update = nil, nil, nil

                for _, espElement in pairs(_G.DoorESP_Elements or {})do
                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.DoorESP_Elements = {}
            end
        end,
    }):AddColorPicker('DoorESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Door Color',
        Callback = function(Value)
            _G.DoorESP_Color = Value
        end,
    })
    VisualsGroup:AddCheckbox('ObjectiveESP', {
        Text = '任务透视',
        Default = false,
        Tooltip = '突出显示所有目标项',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local Workspace = game:GetService('Workspace')
            local Rooms = Workspace:WaitForChild('CurrentRooms')
            local AllowedModels = {
                KeyObtain = true,
                FuseObtain = true,
                LiveBreakerPolePickup = true,
            }

            _G.ItemESP_Elements = _G.ItemESP_Elements or {}
            _G.ItemESP_Color = _G.ItemESP_Color or Color3.fromRGB(255, 255, 0)
            _G._LastItemColor = _G.ItemESP_Color

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end
                if _G.ItemESP_Elements[model] then
                    return
                end

                local esp = ESPLibrary:Add({
                    Name = model.Name,
                    Model = model,
                    Color = _G.ItemESP_Color,
                    MaxDistance = 1000,
                    TextSize = 17,
                    ESPType = _G.ESPType or 'Highlight',
                    FillColor = _G.ItemESP_Color,
                    OutlineColor = _G.ItemESP_Color,
                    FillTransparency = 0.6,
                    OutlineTransparency = 0,
                    Tracer = {
                        Enabled = _G.EnableTracers,
                        Color = _G.ItemESP_Color,
                        From = 'Bottom',
                    },
                    Arrow = {
                        Enabled = _G.EnableArrows,
                        Color = _G.ItemESP_Color,
                    },
                })

                _G.ItemESP_Elements[model] = esp
            end
            local function removeESP(model)
                local esp = _G.ItemESP_Elements[model]

                if esp then
                    esp:Destroy()

                    _G.ItemESP_Elements[model] = nil
                end
            end

            if Value then
                for _, esp in pairs(_G.ItemESP_Elements)do
                    esp:Destroy()
                end

                _G.ItemESP_Elements = {}

                for _, v in pairs(Rooms:GetDescendants())do
                    if (v:IsA('Model') and AllowedModels[v.Name] and v.PrimaryPart) then
                        addESP(v)
                    end
                end

                _G.ItemESP_Add = Rooms.DescendantAdded:Connect(function(v)
                    if (v:IsA('Model') and AllowedModels[v.Name]) then
                        task.wait(0.05)

                        if v.PrimaryPart then
                            addESP(v)
                        end
                    end
                end)
                _G.ItemESP_Remove = Rooms.DescendantRemoving:Connect(function(v)
                    if (v:IsA('Model') and AllowedModels[v.Name]) then
                        removeESP(v)
                    end
                end)
                _G.ItemESP_Update = RunService.Heartbeat:Connect(function()
                    if not _G.ItemESP_Enabled then
                        return
                    end

                    local plr = Players.LocalPlayer
                    local char = plr and plr.Character
                    local root = char and char:FindFirstChild('HumanoidRootPart')

                    if not root then
                        return
                    end

                    local currentColor = _G.ItemESP_Color
                    local colorChanged = currentColor ~= _G._LastItemColor

                    for model, esp in pairs(_G.ItemESP_Elements)do
                        if (model and model.Parent and model.PrimaryPart) then
                            local dist = (root.Position - model.PrimaryPart.Position).Magnitude

                            esp.CurrentSettings.Name = ('%s\n%d studs'):format(model.Name, dist)

                            if colorChanged then
                                esp.CurrentSettings.Color = currentColor
                                esp.CurrentSettings.FillColor = currentColor
                                esp.CurrentSettings.OutlineColor = currentColor
                                esp.CurrentSettings.Tracer.Color = currentColor
                                esp.CurrentSettings.Arrow.Color = currentColor
                            end

                            esp.CurrentSettings.Tracer.Enabled = _G.EnableTracers and _G.ItemESP_Enabled
                            esp.CurrentSettings.Arrow.Enabled = _G.EnableArrows and _G.ItemESP_Enabled
                        else
                            removeESP(model)
                        end
                    end

                    if colorChanged then
                        _G._LastItemColor = currentColor
                    end
                end)
                _G.ItemESP_Enabled = true
            else
                _G.ItemESP_Enabled = false

                if _G.ItemESP_Add then
                    _G.ItemESP_Add:Disconnect()

                    _G.ItemESP_Add = nil
                end
                if _G.ItemESP_Remove then
                    _G.ItemESP_Remove:Disconnect()

                    _G.ItemESP_Remove = nil
                end
                if _G.ItemESP_Update then
                    _G.ItemESP_Update:Disconnect()

                    _G.ItemESP_Update = nil
                end

                for model, esp in pairs(_G.ItemESP_Elements)do
                    if (esp and (typeof(esp.Destroy) == 'function')) then
                        esp:Destroy()
                    end

                    _G.ItemESP_Elements[model] = nil
                end

                _G.ItemESP_Elements = {}

                collectgarbage('collect')
            end
        end,
    }):AddColorPicker('ItemESP_Color', {
        Default = Color3.fromRGB(255, 255, 0),
        Title = 'Item Color',
        Callback = function(Value)
            _G.ItemESP_Color = Value
        end,
    })
    VisualsGroup:AddCheckbox('CoinESP', {
        Text = '金币透视',
        Default = false,
        Disabled = false,
        Tooltip = '透过墙壁显示硬币',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedCoinModels = {GoldPile = true}

            _G.CoinESP_Elements = _G.CoinESP_Elements or {}

            local function addESP(model)
                if (not AllowedCoinModels[model.Name] or not model.PrimaryPart) then
                    return
                end
                if not table.find(_G.CoinESP_Elements, model) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Gold',
                        Model = model,
                        Color = Options.CoinESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.CoinESP_Color.Value,
                        OutlineColor = Options.CoinESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.CoinESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.CoinESP_Color.Value,
                        },
                    })

                    table.insert(_G.CoinESP_Elements, model)

                    _G.CoinESP_Elements[model] = espElement
                end
            end

            if Value then
                _G.CoinESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.CoinESP_Add then
                    _G.CoinESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.CoinESP_Update then
                    _G.CoinESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.CoinESP_Elements, 1, -1 do
                            local model = _G.CoinESP_Elements[i]

                            if (model and model.Parent and model:IsA('Model') and AllowedCoinModels[model.Name] and model.PrimaryPart) then
                                local espElement = _G.CoinESP_Elements[model]

                                if espElement then
                                    local dist = (plrRoot.Position - model.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Gold\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.CoinESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.CoinESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.CoinESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.CoinESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.CoinESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.CoinESP_Elements, i)

                                _G.CoinESP_Elements[model] = nil
                            end
                        end
                    end)
                end
            else
                if _G.CoinESP_Add then
                    _G.CoinESP_Add:Disconnect()

                    _G.CoinESP_Add = nil
                end
                if _G.CoinESP_Update then
                    _G.CoinESP_Update:Disconnect()

                    _G.CoinESP_Update = nil
                end

                for _, model in pairs(_G.CoinESP_Elements or {})do
                    local espElement = _G.CoinESP_Elements[model]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.CoinESP_Elements = nil
            end
        end,
    }):AddColorPicker('CoinESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Coin Color',
        Callback = function(Value)
            for _, model in pairs(_G.CoinESP_Elements or {})do
                local espElement = _G.CoinESP_Elements[model]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroup:AddCheckbox('MinesGeneratorESP', {
        Text = '矿机透视',
        Default = false,
        Tooltip = '通过墙显示地雷生成器',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local Workspace = game:GetService('Workspace')
            local AllowedModels = {MinesGenerator = true}

            _G.MinesGeneratorESP_Elements = _G.MinesGeneratorESP_Elements or {}
            _G.MinesGeneratorESP_Color = _G.MinesGeneratorESP_Color or Color3.fromRGB(0, 255, 255)
            _G._LastMinesGenColor = _G.MinesGeneratorESP_Color

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end
                if _G.MinesGeneratorESP_Elements[model] then
                    return
                end

                local espElement = ESPLibrary:Add({
                    Name = 'Mines Generator',
                    Model = model,
                    Color = _G.MinesGeneratorESP_Color,
                    MaxDistance = 1000,
                    TextSize = 17,
                    ESPType = _G.ESPType or 'Highlight',
                    FillColor = _G.MinesGeneratorESP_Color,
                    OutlineColor = _G.MinesGeneratorESP_Color,
                    FillTransparency = 0.6,
                    OutlineTransparency = 0,
                    Tracer = {
                        Enabled = _G.EnableTracers,
                        Color = _G.MinesGeneratorESP_Color,
                        From = 'Bottom',
                    },
                    Arrow = {
                        Enabled = _G.EnableArrows,
                        Color = _G.MinesGeneratorESP_Color,
                    },
                })

                _G.MinesGeneratorESP_Elements[model] = espElement
            end
            local function removeESP(model)
                local espElement = _G.MinesGeneratorESP_Elements[model]

                if espElement then
                    espElement:Destroy()

                    _G.MinesGeneratorESP_Elements[model] = nil
                end
            end

            if Value then
                for _, espElement in pairs(_G.MinesGeneratorESP_Elements)do
                    espElement:Destroy()
                end

                _G.MinesGeneratorESP_Elements = {}

                for _, v in pairs(Workspace:GetDescendants())do
                    if (v:IsA('Model') and AllowedModels[v.Name] and v.PrimaryPart) then
                        addESP(v)
                    end
                end

                _G.MinesGeneratorESP_Add = Workspace.DescendantAdded:Connect(function(v)
                    if (v:IsA('Model') and AllowedModels[v.Name]) then
                        task.wait(0.05)

                        if v.PrimaryPart then
                            addESP(v)
                        end
                    end
                end)
                _G.MinesGeneratorESP_Remove = Workspace.DescendantRemoving:Connect(function(v)
                    if (v:IsA('Model') and AllowedModels[v.Name]) then
                        removeESP(v)
                    end
                end)
                _G.MinesGeneratorESP_Update = RunService.RenderStepped:Connect(function()
                    local plr = Players.LocalPlayer
                    local char = plr and plr.Character
                    local root = char and char:FindFirstChild('HumanoidRootPart')

                    if not root then
                        return
                    end

                    local currentColor = _G.MinesGeneratorESP_Color
                    local colorChanged = currentColor ~= _G._LastMinesGenColor

                    for model, espElement in pairs(_G.MinesGeneratorESP_Elements)do
                        if (model and model.Parent and model.PrimaryPart) then
                            local dist = (root.Position - model.PrimaryPart.Position).Magnitude

                            espElement.CurrentSettings.Name = ('Mines Generator\n%d studs'):format(dist)

                            if colorChanged then
                                espElement.CurrentSettings.Color = currentColor
                                espElement.CurrentSettings.FillColor = currentColor
                                espElement.CurrentSettings.OutlineColor = currentColor
                                espElement.CurrentSettings.Tracer.Color = currentColor
                                espElement.CurrentSettings.Arrow.Color = currentColor
                            end

                            espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                            espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                        else
                            removeESP(model)
                        end
                    end

                    if colorChanged then
                        _G._LastMinesGenColor = currentColor
                    end
                end)
            else
                if _G.MinesGeneratorESP_Add then
                    _G.MinesGeneratorESP_Add:Disconnect()
                end
                if _G.MinesGeneratorESP_Remove then
                    _G.MinesGeneratorESP_Remove:Disconnect()
                end
                if _G.MinesGeneratorESP_Update then
                    _G.MinesGeneratorESP_Update:Disconnect()
                end

                _G.MinesGeneratorESP_Add, _G.MinesGeneratorESP_Remove, _G.MinesGeneratorESP_Update = nil, nil, nil

                for _, espElement in pairs(_G.MinesGeneratorESP_Elements or {})do
                    espElement:Destroy()
                end

                _G.MinesGeneratorESP_Elements = {}
            end
        end,
    }):AddColorPicker('MinesGeneratorESP_Color', {
        Default = Color3.fromRGB(0, 255, 255),
        Title = 'Mines Generator Color',
        Callback = function(Value)
            _G.MinesGeneratorESP_Color = Value
        end,
    })
    VisualsGroup:AddCheckbox('LeverESP', {
        Text = '拉杆透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示穿过墙壁的杠杆',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {LeverForGate = true}

            _G.LeverESP_Elements = _G.LeverESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.LeverESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Lever',
                        Model = target,
                        Color = Options.LeverESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.LeverESP_Color.Value,
                        OutlineColor = Options.LeverESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.LeverESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.LeverESP_Color.Value,
                        },
                    })

                    table.insert(_G.LeverESP_Elements, target)

                    _G.LeverESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.LeverESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.LeverESP_Add then
                    _G.LeverESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.LeverESP_Update then
                    _G.LeverESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.LeverESP_Elements, 1, -1 do
                            local target = _G.LeverESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.LeverESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Lever\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.LeverESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.LeverESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.LeverESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.LeverESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.LeverESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.LeverESP_Elements, i)

                                _G.LeverESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.LeverESP_Add then
                    _G.LeverESP_Add:Disconnect()

                    _G.LeverESP_Add = nil
                end
                if _G.LeverESP_Update then
                    _G.LeverESP_Update:Disconnect()

                    _G.LeverESP_Update = nil
                end

                for _, target in pairs(_G.LeverESP_Elements or {})do
                    local espElement = _G.LeverESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.LeverESP_Elements = nil
            end
        end,
    }):AddColorPicker('LeverESP_Color', {
        Default = Color3.fromRGB(255, 165, 0),
        Title = 'Lever Color',
        Callback = function(Value)
            for _, target in pairs(_G.LeverESP_Elements or {})do
                local espElement = _G.LeverESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroup:AddCheckbox('ItemESP', {
        Text = '物品透视',
        Default = false,
        Disabled = false,
        Tooltip = '突出显示所有可交互项目',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {
                AlarmClock = true,
                GlitchCub = true,
                Aloe = true,
                BandagePack = true,
                Battery = true,
                TimerLever = true,
                OuterPart = true,
                BatteryPack = true,
                Candle = true,
                LiveBreakerPolePickup = true,
                Compass = true,
                Crucifix = true,
                ElectricalRoomKey = true,
                Flashlight = true,
                Glowstick = true,
                HolyHandGrenade = true,
                Lantern = true,
                LaserPointer = true,
                Lighter = true,
                Lockpick = true,
                LotusFlower = true,
                LotusPetalPickup = true,
                Multitool = true,
                NVCS3000 = true,
                OutdoorsKey = true,
                Shears = true,
                SkeletonKey = true,
                Smoothie = true,
                SolutionPaper = true,
                Spotlight = true,
                StarlightVial = true,
                StarlightJug = true,
                StarlightBottle = true,
                Vitamins = true,
            }

            _G.ItemESP_Elements = _G.ItemESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.ItemESP_Elements, target) then
                    local name = model.Name
                    local espElement = ESPLibrary:Add({
                        Name = name,
                        Model = target,
                        Color = Options.ItemESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.ItemESP_Color.Value,
                        OutlineColor = Options.ItemESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.ItemESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.ItemESP_Color.Value,
                        },
                    })

                    table.insert(_G.ItemESP_Elements, target)

                    _G.ItemESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.ItemESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.ItemESP_Add then
                    _G.ItemESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.ItemESP_Update then
                    _G.ItemESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.ItemESP_Elements, 1, -1 do
                            local target = _G.ItemESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.ItemESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = target.Name .. '\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.ItemESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.ItemESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.ItemESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.ItemESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.ItemESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.ItemESP_Elements, i)

                                _G.ItemESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.ItemESP_Add then
                    _G.ItemESP_Add:Disconnect()

                    _G.ItemESP_Add = nil
                end
                if _G.ItemESP_Update then
                    _G.ItemESP_Update:Disconnect()

                    _G.ItemESP_Update = nil
                end

                for _, target in pairs(_G.ItemESP_Elements or {})do
                    local espElement = _G.ItemESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.ItemESP_Elements = nil
            end
        end,
    }):AddColorPicker('ItemESP_Color', {
        Default = Color3.fromRGB(255, 255, 0),
        Title = 'Item Color',
        Callback = function(Value)
            for _, target in pairs(_G.ItemESP_Elements or {})do
                local espElement = _G.ItemESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroup:AddCheckbox('ClosetESP', {
        Text = '柜子透视',
        Default = false,
        Disabled = false,
        Tooltip = '通过墙显示壁橱',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {
                Wardrobe = true,
                Toolshed = true,
                Locker_Large = true,
                Backdoor_Wardrobe = true,
            }

            _G.ClosetESP_Elements = _G.ClosetESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.ClosetESP_Elements, target) then
                    local name = model.Name
                    local espElement = ESPLibrary:Add({
                        Name = name,
                        Model = target,
                        Color = Options.ClosetESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.ClosetESP_Color.Value,
                        OutlineColor = Options.ClosetESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.ClosetESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.ClosetESP_Color.Value,
                        },
                    })

                    table.insert(_G.ClosetESP_Elements, target)

                    _G.ClosetESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.ClosetESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.ClosetESP_Add then
                    _G.ClosetESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.ClosetESP_Update then
                    _G.ClosetESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.ClosetESP_Elements, 1, -1 do
                            local target = _G.ClosetESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.ClosetESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = target.Name .. '\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.ClosetESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.ClosetESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.ClosetESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.ClosetESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.ClosetESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.ClosetESP_Elements, i)

                                _G.ClosetESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.ClosetESP_Add then
                    _G.ClosetESP_Add:Disconnect()

                    _G.ClosetESP_Add = nil
                end
                if _G.ClosetESP_Update then
                    _G.ClosetESP_Update:Disconnect()

                    _G.ClosetESP_Update = nil
                end

                for _, target in pairs(_G.ClosetESP_Elements or {})do
                    local espElement = _G.ClosetESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.ClosetESP_Elements = nil
            end
        end,
    }):AddColorPicker('ClosetESP_Color', {
        Default = Color3.fromRGB(255, 0, 255),
        Title = 'Closet Color',
        Callback = function(Value)
            for _, target in pairs(_G.ClosetESP_Elements or {})do
                local espElement = _G.ClosetESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroup:AddCheckbox('AnchorESP', {
        Text = '锚点透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示穿过墙的锚点',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {MinesAnchor = true}

            _G.AnchorESP_Elements = _G.AnchorESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.AnchorESP_Elements, target) then
                    local name = model.Name
                    local espElement = ESPLibrary:Add({
                        Name = name,
                        Model = target,
                        Color = Options.AnchorESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.AnchorESP_Color.Value,
                        OutlineColor = Options.AnchorESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.AnchorESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.AnchorESP_Color.Value,
                        },
                    })

                    table.insert(_G.AnchorESP_Elements, target)

                    _G.AnchorESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.AnchorESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.AnchorESP_Add then
                    _G.AnchorESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.AnchorESP_Update then
                    _G.AnchorESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.AnchorESP_Elements, 1, -1 do
                            local target = _G.AnchorESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.AnchorESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = target.Name .. '\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.AnchorESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.AnchorESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.AnchorESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.AnchorESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.AnchorESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.AnchorESP_Elements, i)

                                _G.AnchorESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.AnchorESP_Add then
                    _G.AnchorESP_Add:Disconnect()

                    _G.AnchorESP_Add = nil
                end
                if _G.AnchorESP_Update then
                    _G.AnchorESP_Update:Disconnect()

                    _G.AnchorESP_Update = nil
                end

                for _, target in pairs(_G.AnchorESP_Elements or {})do
                    local espElement = _G.AnchorESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.AnchorESP_Elements = nil
            end
        end,
    }):AddColorPicker('AnchorESP_Color', {
        Default = Color3.fromRGB(255, 0, 255),
        Title = 'Anchor Color',
        Callback = function(Value)
            for _, target in pairs(_G.AnchorESP_Elements or {})do
                local espElement = _G.AnchorESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroup:AddCheckbox('LibraryBookESP', {
        Text = '图书透视',
        Default = false,
        Disabled = false,
        Tooltip = 'shows library books through walls',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {LiveHintBook = true}

            _G.LibraryBookESP_Elements = _G.LibraryBookESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.LibraryBookESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Library Book',
                        Model = target,
                        Color = Options.LibraryBookESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.LibraryBookESP_Color.Value,
                        OutlineColor = Options.LibraryBookESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.LibraryBookESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.LibraryBookESP_Color.Value,
                        },
                    })

                    table.insert(_G.LibraryBookESP_Elements, target)

                    _G.LibraryBookESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.LibraryBookESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.LibraryBookESP_Add then
                    _G.LibraryBookESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.LibraryBookESP_Update then
                    _G.LibraryBookESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.LibraryBookESP_Elements, 1, -1 do
                            local target = _G.LibraryBookESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.LibraryBookESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Library Book\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.LibraryBookESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.LibraryBookESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.LibraryBookESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.LibraryBookESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.LibraryBookESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.LibraryBookESP_Elements, i)

                                _G.LibraryBookESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.LibraryBookESP_Add then
                    _G.LibraryBookESP_Add:Disconnect()

                    _G.LibraryBookESP_Add = nil
                end
                if _G.LibraryBookESP_Update then
                    _G.LibraryBookESP_Update:Disconnect()

                    _G.LibraryBookESP_Update = nil
                end

                for _, target in pairs(_G.LibraryBookESP_Elements or {})do
                    local espElement = _G.LibraryBookESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.LibraryBookESP_Elements = nil
            end
        end,
    }):AddColorPicker('LibraryBookESP_Color', {
        Default = Color3.fromRGB(0, 255, 255),
        Title = 'Library Book Color',
        Callback = function(Value)
            for _, target in pairs(_G.LibraryBookESP_Elements or {})do
                local espElement = _G.LibraryBookESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroup:AddCheckbox('ChestESP', {
        Text = '宝箱透视',
        Default = false,
        Disabled = false,
        Tooltip = '透过墙壁显示胸部',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {
                ChestBox = true,
                ChestBoxLocked = true,
            }

            _G.ChestESP_Elements = _G.ChestESP_Elements or {}
            _G.ChestESP_Trans = _G.ChestESP_Trans or {}

            local function addESP(model)
                if not AllowedModels[model.Name] then
                    return
                end

                local target = model.PrimaryPart or model:FindFirstChildWhichIsA('BasePart')

                if not target then
                    return
                end
                if not _G.ChestESP_Trans[target] then
                    _G.ChestESP_Trans[target] = target.Transparency
                end

                target.Transparency = 0

                if not table.find(_G.ChestESP_Elements, target) then
                    local name = model.Name
                    local espElement = ESPLibrary:Add({
                        Name = name,
                        Model = target,
                        Color = Options.ChestESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.ChestESP_Color.Value,
                        OutlineColor = Options.ChestESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.ChestESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.ChestESP_Color.Value,
                        },
                    })

                    table.insert(_G.ChestESP_Elements, target)

                    _G.ChestESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.ChestESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.ChestESP_Add then
                    _G.ChestESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.ChestESP_Update then
                    _G.ChestESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.ChestESP_Elements, 1, -1 do
                            local target = _G.ChestESP_Elements[i]

                            if (target and target.Parent and target:IsA('BasePart') and AllowedModels[target.Parent.Name]) then
                                local espElement = _G.ChestESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.Position).Magnitude

                                    espElement.CurrentSettings.Name = target.Parent.Name .. '\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.ChestESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.ChestESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.ChestESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.ChestESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.ChestESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                if (target and _G.ChestESP_Trans[target]) then
                                    target.Transparency = _G.ChestESP_Trans[target]
                                end

                                table.remove(_G.ChestESP_Elements, i)

                                _G.ChestESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.ChestESP_Add then
                    _G.ChestESP_Add:Disconnect()

                    _G.ChestESP_Add = nil
                end
                if _G.ChestESP_Update then
                    _G.ChestESP_Update:Disconnect()

                    _G.ChestESP_Update = nil
                end

                for _, target in pairs(_G.ChestESP_Elements or {})do
                    if (target and _G.ChestESP_Trans[target]) then
                        target.Transparency = _G.ChestESP_Trans[target]
                    end

                    local espElement = _G.ChestESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.ChestESP_Elements = nil
                _G.ChestESP_Trans = nil
            end
        end,
    }):AddColorPicker('ChestESP_Color', {
        Default = Color3.fromRGB(0, 255, 0),
        Title = 'Chest Color',
        Callback = function(Value)
            for _, target in pairs(_G.ChestESP_Elements or {})do
                local espElement = _G.ChestESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })

    local VisualsGroupZ = Tabs.Visuals:AddRightGroupbox('Entity ESP')

    VisualsGroupZ:AddCheckbox('SeekESP', {
        Text = 'seek透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示通过墙进行搜索',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {SeekMoving = true}

            _G.SeekESP_Elements = _G.SeekESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.SeekESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Seek',
                        Model = target,
                        Color = Options.SeekESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.SeekESP_Color.Value,
                        OutlineColor = Options.SeekESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.SeekESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.SeekESP_Color.Value,
                        },
                    })

                    table.insert(_G.SeekESP_Elements, target)

                    _G.SeekESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.SeekESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.SeekESP_Add then
                    _G.SeekESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.SeekESP_Update then
                    _G.SeekESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.SeekESP_Elements, 1, -1 do
                            local target = _G.SeekESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.SeekESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Seek\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.SeekESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.SeekESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.SeekESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.SeekESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.SeekESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.SeekESP_Elements, i)

                                _G.SeekESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.SeekESP_Add then
                    _G.SeekESP_Add:Disconnect()

                    _G.SeekESP_Add = nil
                end
                if _G.SeekESP_Update then
                    _G.SeekESP_Update:Disconnect()

                    _G.SeekESP_Update = nil
                end

                for _, target in pairs(_G.SeekESP_Elements or {})do
                    local espElement = _G.SeekESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.SeekESP_Elements = nil
            end
        end,
    }):AddColorPicker('SeekESP_Color', {
        Default = Color3.fromRGB(255, 0, 0),
        Title = 'Seek Color',
        Callback = function(Value)
            for _, target in pairs(_G.SeekESP_Elements or {})do
                local espElement = _G.SeekESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('FigureESP', {
        Text = 'Figure透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示穿过墙的地物',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {FigureRig = true}

            _G.FigureESP_Elements = _G.FigureESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.FigureESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Figure',
                        Model = target,
                        Color = Options.FigureESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.FigureESP_Color.Value,
                        OutlineColor = Options.FigureESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.FigureESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.FigureESP_Color.Value,
                        },
                    })

                    table.insert(_G.FigureESP_Elements, target)

                    _G.FigureESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.FigureESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.FigureESP_Add then
                    _G.FigureESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.FigureESP_Update then
                    _G.FigureESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.FigureESP_Elements, 1, -1 do
                            local target = _G.FigureESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.FigureESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Figure\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.FigureESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.FigureESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.FigureESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.FigureESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.FigureESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.FigureESP_Elements, i)

                                _G.FigureESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.FigureESP_Add then
                    _G.FigureESP_Add:Disconnect()

                    _G.FigureESP_Add = nil
                end
                if _G.FigureESP_Update then
                    _G.FigureESP_Update:Disconnect()

                    _G.FigureESP_Update = nil
                end

                for _, target in pairs(_G.FigureESP_Elements or {})do
                    local espElement = _G.FigureESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.FigureESP_Elements = nil
            end
        end,
    }):AddColorPicker('FigureESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Figure Color',
        Callback = function(Value)
            for _, target in pairs(_G.FigureESP_Elements or {})do
                local espElement = _G.FigureESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('AmbushESP', {
        Text = 'Ambush透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示了穿过墙壁的埋伏',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {AmbushMoving = true}

            _G.AmbushESP_Elements = _G.AmbushESP_Elements or {}
            _G.AmbushESP_Trans = _G.AmbushESP_Trans or {}

            local function addESP(model)
                if not AllowedModels[model.Name] then
                    return
                end

                local target = model:FindFirstChild('RushNew')

                if (not target or not target:IsA('BasePart')) then
                    return
                end
                if not _G.AmbushESP_Trans[target] then
                    _G.AmbushESP_Trans[target] = target.Transparency
                end

                target.Transparency = 0

                if not table.find(_G.AmbushESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Ambush',
                        Model = target,
                        Color = Options.AmbushESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.AmbushESP_Color.Value,
                        OutlineColor = Options.AmbushESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.AmbushESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.AmbushESP_Color.Value,
                        },
                    })

                    table.insert(_G.AmbushESP_Elements, target)

                    _G.AmbushESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.AmbushESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.AmbushESP_Add then
                    _G.AmbushESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.AmbushESP_Update then
                    _G.AmbushESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.AmbushESP_Elements, 1, -1 do
                            local target = _G.AmbushESP_Elements[i]

                            if (target and target.Parent and target:IsA('BasePart') and AllowedModels[target.Parent.Name]) then
                                local espElement = _G.AmbushESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Ambush\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.AmbushESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.AmbushESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.AmbushESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.AmbushESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.AmbushESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                if (target and _G.AmbushESP_Trans[target]) then
                                    target.Transparency = _G.AmbushESP_Trans[target]
                                end

                                table.remove(_G.AmbushESP_Elements, i)

                                _G.AmbushESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.AmbushESP_Add then
                    _G.AmbushESP_Add:Disconnect()

                    _G.AmbushESP_Add = nil
                end
                if _G.AmbushESP_Update then
                    _G.AmbushESP_Update:Disconnect()

                    _G.AmbushESP_Update = nil
                end

                for _, target in pairs(_G.AmbushESP_Elements or {})do
                    if (target and _G.AmbushESP_Trans[target]) then
                        target.Transparency = _G.AmbushESP_Trans[target]
                    end

                    local espElement = _G.AmbushESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.AmbushESP_Elements = nil
                _G.AmbushESP_Trans = nil
            end
        end,
    }):AddColorPicker('AmbushESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Ambush Color',
        Callback = function(Value)
            for _, target in pairs(_G.AmbushESP_Elements or {})do
                local espElement = _G.AmbushESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('RushESP', {
        Text = 'Rush透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示冲过墙壁',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {RushMoving = true}

            _G.RushESP_Elements = _G.RushESP_Elements or {}
            _G.RushESP_Trans = _G.RushESP_Trans or {}

            local function addESP(model)
                if not AllowedModels[model.Name] then
                    return
                end

                local target = model:FindFirstChild('RushNew')

                if (not target or not target:IsA('BasePart')) then
                    return
                end
                if not _G.RushESP_Trans[target] then
                    _G.RushESP_Trans[target] = target.Transparency
                end

                target.Transparency = 0

                if not table.find(_G.RushESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Rush',
                        Model = target,
                        Color = Options.RushESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.RushESP_Color.Value,
                        OutlineColor = Options.RushESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.RushESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.RushESP_Color.Value,
                        },
                    })

                    table.insert(_G.RushESP_Elements, target)

                    _G.RushESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.RushESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.RushESP_Add then
                    _G.RushESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.RushESP_Update then
                    _G.RushESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.RushESP_Elements, 1, -1 do
                            local target = _G.RushESP_Elements[i]

                            if (target and target.Parent and target:IsA('BasePart') and AllowedModels[target.Parent.Name]) then
                                local espElement = _G.RushESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Rush\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.RushESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.RushESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.RushESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.RushESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.RushESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                if (target and _G.RushESP_Trans[target]) then
                                    target.Transparency = _G.RushESP_Trans[target]
                                end

                                table.remove(_G.RushESP_Elements, i)

                                _G.RushESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.RushESP_Add then
                    _G.RushESP_Add:Disconnect()

                    _G.RushESP_Add = nil
                end
                if _G.RushESP_Update then
                    _G.RushESP_Update:Disconnect()

                    _G.RushESP_Update = nil
                end

                for _, target in pairs(_G.RushESP_Elements or {})do
                    if (target and _G.RushESP_Trans[target]) then
                        target.Transparency = _G.RushESP_Trans[target]
                    end

                    local espElement = _G.RushESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.RushESP_Elements = nil
                _G.RushESP_Trans = nil
            end
        end,
    }):AddColorPicker('RushESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Rush Color',
        Callback = function(Value)
            for _, target in pairs(_G.RushESP_Elements or {})do
                local espElement = _G.RushESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('SnareESP', {
        Text = 'Snare透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示穿过墙壁的圈套器',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {Snare = true}

            _G.SnareESP_Elements = _G.SnareESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.SnareESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Snare',
                        Model = target,
                        Color = Options.SnareESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.SnareESP_Color.Value,
                        OutlineColor = Options.SnareESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.SnareESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.SnareESP_Color.Value,
                        },
                    })

                    table.insert(_G.SnareESP_Elements, target)

                    _G.SnareESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.SnareESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.SnareESP_Add then
                    _G.SnareESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.SnareESP_Update then
                    _G.SnareESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.SnareESP_Elements, 1, -1 do
                            local target = _G.SnareESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.SnareESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Snare\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.SnareESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.SnareESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.SnareESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.SnareESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.SnareESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.SnareESP_Elements, i)

                                _G.SnareESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.SnareESP_Add then
                    _G.SnareESP_Add:Disconnect()

                    _G.SnareESP_Add = nil
                end
                if _G.SnareESP_Update then
                    _G.SnareESP_Update:Disconnect()

                    _G.SnareESP_Update = nil
                end

                for _, target in pairs(_G.SnareESP_Elements or {})do
                    local espElement = _G.SnareESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.SnareESP_Elements = nil
            end
        end,
    }):AddColorPicker('SnareESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Snare Color',
        Callback = function(Value)
            for _, target in pairs(_G.SnareESP_Elements or {})do
                local espElement = _G.SnareESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('GiggleESP', {
        Text = 'Giggle透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示穿墙傻笑',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {GiggleCeiling = true}

            _G.GiggleESP_Elements = _G.GiggleESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.GiggleESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Giggle',
                        Model = target,
                        Color = Options.GiggleESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.GiggleESP_Color.Value,
                        OutlineColor = Options.GiggleESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.GiggleESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.GiggleESP_Color.Value,
                        },
                    })

                    table.insert(_G.GiggleESP_Elements, target)

                    _G.GiggleESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.GiggleESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.GiggleESP_Add then
                    _G.GiggleESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.GiggleESP_Update then
                    _G.GiggleESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.GiggleESP_Elements, 1, -1 do
                            local target = _G.GiggleESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.GiggleESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Giggle\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.GiggleESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.GiggleESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.GiggleESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.GiggleESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.GiggleESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.GiggleESP_Elements, i)

                                _G.GiggleESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.GiggleESP_Add then
                    _G.GiggleESP_Add:Disconnect()

                    _G.GiggleESP_Add = nil
                end
                if _G.GiggleESP_Update then
                    _G.GiggleESP_Update:Disconnect()

                    _G.GiggleESP_Update = nil
                end

                for _, target in pairs(_G.GiggleESP_Elements or {})do
                    local espElement = _G.GiggleESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.GiggleESP_Elements = nil
            end
        end,
    }):AddColorPicker('GiggleESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Giggle Color',
        Callback = function(Value)
            for _, target in pairs(_G.GiggleESP_Elements or {})do
                local espElement = _G.GiggleESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('EyestalkESP', {
        Text = 'Eyes透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示穿过墙壁的眼柄',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {EyestalkMoving = true}

            _G.EyestalkESP_Elements = _G.EyestalkESP_Elements or {}
            _G.EyestalkESP_Trans = _G.EyestalkESP_Trans or {}

            local function addESP(model)
                if not AllowedModels[model.Name] then
                    return
                end

                local target = model

                if not _G.EyestalkESP_Trans[target] then
                    _G.EyestalkESP_Trans[target] = {}

                    for _, part in ipairs(target:GetDescendants())do
                        if part:IsA('BasePart') then
                            _G.EyestalkESP_Trans[target][part] = part.Transparency
                            part.Transparency = 0
                        end
                    end
                end
                if not table.find(_G.EyestalkESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Eyestalk',
                        Model = target,
                        Color = Options.EyestalkESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.EyestalkESP_Color.Value,
                        OutlineColor = Options.EyestalkESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.EyestalkESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.EyestalkESP_Color.Value,
                        },
                    })

                    table.insert(_G.EyestalkESP_Elements, target)

                    _G.EyestalkESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.EyestalkESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.EyestalkESP_Add then
                    _G.EyestalkESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.EyestalkESP_Update then
                    _G.EyestalkESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.EyestalkESP_Elements, 1, -1 do
                            local target = _G.EyestalkESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.EyestalkESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Eyestalk\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.EyestalkESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.EyestalkESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.EyestalkESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.EyestalkESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.EyestalkESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                if (target and _G.EyestalkESP_Trans[target]) then
                                    for part, trans in pairs(_G.EyestalkESP_Trans[target])do
                                        if (part and part.Parent) then
                                            part.Transparency = trans
                                        end
                                    end
                                end

                                table.remove(_G.EyestalkESP_Elements, i)

                                _G.EyestalkESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.EyestalkESP_Add then
                    _G.EyestalkESP_Add:Disconnect()

                    _G.EyestalkESP_Add = nil
                end
                if _G.EyestalkESP_Update then
                    _G.EyestalkESP_Update:Disconnect()

                    _G.EyestalkESP_Update = nil
                end

                for _, target in pairs(_G.EyestalkESP_Elements or {})do
                    if (target and _G.EyestalkESP_Trans[target]) then
                        for part, trans in pairs(_G.EyestalkESP_Trans[target])do
                            if (part and part.Parent) then
                                part.Transparency = trans
                            end
                        end
                    end

                    local espElement = _G.EyestalkESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.EyestalkESP_Elements = nil
                _G.EyestalkESP_Trans = nil
            end
        end,
    }):AddColorPicker('EyestalkESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Eyestalk Color',
        Callback = function(Value)
            for _, target in pairs(_G.EyestalkESP_Elements or {})do
                local espElement = _G.EyestalkESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('MandrakeESP', {
        Text = 'Mandrake透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示曼德拉草穿过墙壁',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {Mandrake = true}

            _G.MandrakeESP_Elements = _G.MandrakeESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.MandrakeESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Mandrake',
                        Model = target,
                        Color = Options.MandrakeESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.MandrakeESP_Color.Value,
                        OutlineColor = Options.MandrakeESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.MandrakeESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.MandrakeESP_Color.Value,
                        },
                    })

                    table.insert(_G.MandrakeESP_Elements, target)

                    _G.MandrakeESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.MandrakeESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.MandrakeESP_Add then
                    _G.MandrakeESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.MandrakeESP_Update then
                    _G.MandrakeESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.MandrakeESP_Elements, 1, -1 do
                            local target = _G.MandrakeESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.MandrakeESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Mandrake\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.MandrakeESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.MandrakeESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.MandrakeESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.MandrakeESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.MandrakeESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.MandrakeESP_Elements, i)

                                _G.MandrakeESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.MandrakeESP_Add then
                    _G.MandrakeESP_Add:Disconnect()

                    _G.MandrakeESP_Add = nil
                end
                if _G.MandrakeESP_Update then
                    _G.MandrakeESP_Update:Disconnect()

                    _G.MandrakeESP_Update = nil
                end

                for _, target in pairs(_G.MandrakeESP_Elements or {})do
                    local espElement = _G.MandrakeESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.MandrakeESP_Elements = nil
            end
        end,
    }):AddColorPicker('MandrakeESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Mandrake Color',
        Callback = function(Value)
            for _, target in pairs(_G.MandrakeESP_Elements or {})do
                local espElement = _G.MandrakeESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('GroundskeeperESP', {
        Text = 'Groundskeeper透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示地勤人员穿过墙壁',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {Groundskeeper = true}

            _G.GroundskeeperESP_Elements = _G.GroundskeeperESP_Elements or {}

            local function addESP(model)
                if (not AllowedModels[model.Name] or not model.PrimaryPart) then
                    return
                end

                local target = model

                if not table.find(_G.GroundskeeperESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Groundskeeper',
                        Model = target,
                        Color = Options.GroundskeeperESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.GroundskeeperESP_Color.Value,
                        OutlineColor = Options.GroundskeeperESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.GroundskeeperESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.GroundskeeperESP_Color.Value,
                        },
                    })

                    table.insert(_G.GroundskeeperESP_Elements, target)

                    _G.GroundskeeperESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.GroundskeeperESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.GroundskeeperESP_Add then
                    _G.GroundskeeperESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.GroundskeeperESP_Update then
                    _G.GroundskeeperESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.GroundskeeperESP_Elements, 1, -1 do
                            local target = _G.GroundskeeperESP_Elements[i]

                            if (target and target.Parent and target:IsA('Model') and AllowedModels[target.Name] and target.PrimaryPart) then
                                local espElement = _G.GroundskeeperESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.PrimaryPart.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Groundskeeper\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.GroundskeeperESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.GroundskeeperESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.GroundskeeperESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.GroundskeeperESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.GroundskeeperESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                table.remove(_G.GroundskeeperESP_Elements, i)

                                _G.GroundskeeperESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.GroundskeeperESP_Add then
                    _G.GroundskeeperESP_Add:Disconnect()

                    _G.GroundskeeperESP_Add = nil
                end
                if _G.GroundskeeperESP_Update then
                    _G.GroundskeeperESP_Update:Disconnect()

                    _G.GroundskeeperESP_Update = nil
                end

                for _, target in pairs(_G.GroundskeeperESP_Elements or {})do
                    local espElement = _G.GroundskeeperESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.GroundskeeperESP_Elements = nil
            end
        end,
    }):AddColorPicker('GroundskeeperESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = 'Groundskeeper Color',
        Callback = function(Value)
            for _, target in pairs(_G.GroundskeeperESP_Elements or {})do
                local espElement = _G.GroundskeeperESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    VisualsGroupZ:AddCheckbox('BlitzESP', {
        Text = 'Blitz透视',
        Default = false,
        Disabled = false,
        Tooltip = '显示闪击穿墙',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local AllowedModels = {BackdoorRush = true}

            _G.BlitzESP_Elements = _G.BlitzESP_Elements or {}
            _G.BlitzESP_Trans = _G.BlitzESP_Trans or {}

            local function addESP(model)
                if not AllowedModels[model.Name] then
                    return
                end

                local target = model:FindFirstChild('Main')

                if (not target or not target:IsA('BasePart')) then
                    return
                end
                if not _G.BlitzESP_Trans[target] then
                    _G.BlitzESP_Trans[target] = target.Transparency
                end

                target.Transparency = 0

                if not table.find(_G.BlitzESP_Elements, target) then
                    local espElement = ESPLibrary:Add({
                        Name = 'Blitz',
                        Model = target,
                        Color = Options.BlitzESP_Color.Value,
                        MaxDistance = 1000,
                        TextSize = 17,
                        ESPType = _G.ESPType or 'Highlight',
                        FillColor = Options.BlitzESP_Color.Value,
                        OutlineColor = Options.BlitzESP_Color.Value,
                        FillTransparency = 0.6,
                        OutlineTransparency = 0,
                        Tracer = {
                            Enabled = _G.EnableTracers,
                            Color = Options.BlitzESP_Color.Value,
                            From = 'Bottom',
                        },
                        Arrow = {
                            Enabled = _G.EnableArrows,
                            Color = Options.BlitzESP_Color.Value,
                        },
                    })

                    table.insert(_G.BlitzESP_Elements, target)

                    _G.BlitzESP_Elements[target] = espElement
                end
            end

            if Value then
                _G.BlitzESP_Elements = {}

                for _, v in pairs(workspace:GetDescendants())do
                    if v:IsA('Model') then
                        addESP(v)
                    end
                end

                if not _G.BlitzESP_Add then
                    _G.BlitzESP_Add = workspace.DescendantAdded:Connect(function(v)
                        if v:IsA('Model') then
                            addESP(v)
                        end
                    end)
                end
                if not _G.BlitzESP_Update then
                    _G.BlitzESP_Update = RunService.RenderStepped:Connect(function()
                        local plrRoot = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

                        if not plrRoot then
                            return
                        end

                        for i = #_G.BlitzESP_Elements, 1, -1 do
                            local target = _G.BlitzESP_Elements[i]

                            if (target and target.Parent and target:IsA('BasePart') and AllowedModels[target.Parent.Name]) then
                                local espElement = _G.BlitzESP_Elements[target]

                                if espElement then
                                    local dist = (plrRoot.Position - target.Position).Magnitude

                                    espElement.CurrentSettings.Name = 'Blitz\n' .. math.floor(dist) .. ' studs'
                                    espElement.CurrentSettings.Color = Options.BlitzESP_Color.Value
                                    espElement.CurrentSettings.FillColor = Options.BlitzESP_Color.Value
                                    espElement.CurrentSettings.OutlineColor = Options.BlitzESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Color = Options.BlitzESP_Color.Value
                                    espElement.CurrentSettings.Tracer.Enabled = _G.EnableTracers
                                    espElement.CurrentSettings.Arrow.Color = Options.BlitzESP_Color.Value
                                    espElement.CurrentSettings.Arrow.Enabled = _G.EnableArrows
                                end
                            else
                                if (target and _G.BlitzESP_Trans[target]) then
                                    target.Transparency = _G.BlitzESP_Trans[target]
                                end

                                table.remove(_G.BlitzESP_Elements, i)

                                _G.BlitzESP_Elements[target] = nil
                            end
                        end
                    end)
                end
            else
                if _G.BlitzESP_Add then
                    _G.BlitzESP_Add:Disconnect()

                    _G.BlitzESP_Add = nil
                end
                if _G.BlitzESP_Update then
                    _G.BlitzESP_Update:Disconnect()

                    _G.BlitzESP_Update = nil
                end

                for _, target in pairs(_G.BlitzESP_Elements or {})do
                    if (target and _G.BlitzESP_Trans[target]) then
                        target.Transparency = _G.BlitzESP_Trans[target]
                    end

                    local espElement = _G.BlitzESP_Elements[target]

                    if espElement then
                        espElement:Destroy()
                    end
                end

                _G.BlitzESP_Elements = nil
                _G.BlitzESP_Trans = nil
            end
        end,
    }):AddColorPicker('BlitzESP_Color', {
        Default = Color3.fromRGB(255, 255, 255),
        Title = '闪电颜色',
        Callback = function(Value)
            for _, target in pairs(_G.BlitzESP_Elements or {})do
                local espElement = _G.BlitzESP_Elements[target]

                if espElement then
                    espElement.CurrentSettings.Color = Value
                    espElement.CurrentSettings.FillColor = Value
                    espElement.CurrentSettings.OutlineColor = Value
                    espElement.CurrentSettings.Tracer.Color = Value
                    espElement.CurrentSettings.Arrow.Color = Value
                end
            end
        end,
    })
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1.5)

        if Toggles.AlwaysJump.Value then
            LocalPlayer.Character:SetAttribute('CanJump', true)
        end
        if Toggles.NoAcceleration.Value then
            hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

            if hrp then
                hrp.CustomPhysicalProperties = PhysicalProperties.new(100, 0, 0, 0, 0)
            end
        end
    end)

    local LeftTabBox = Tabs.Visuals:AddRightTabbox('Left Tabbox')
    local VisualsTab = LeftTabBox:AddTab('Visuals')
    local runService = game:GetService('RunService')
    local RequiredMainGame = nil

    pcall(function()
        RequiredMainGame = require(game:GetService('Players').LocalPlayer:WaitForChild('PlayerGui'):WaitForChild('MainUI'):WaitForChild('Initiator'):WaitForChild('Main_Game'))
    end)
    VisualsTab:AddCheckbox('NoCameraShake', {
        Text = '禁用镜头震动',
        Default = false,
        Visible = (checkcaller ~= nil) and (getloadedmodules ~= nil),
        Callback = function(Value)
            task.spawn(function()
                while Value and RequiredMainGame do
                    task.wait()

                    if (typeof(RequiredMainGame.csgo) == 'CFrame') then
                        RequiredMainGame.csgo = CFrame.new()
                    end
                end
            end)
        end,
    })
    VisualsTab:AddCheckbox('NoHeadBob', {
        Text = '禁用头部晃动',
        Default = false,
        Visible = (checkcaller ~= nil) and (cloneref ~= nil),
        Callback = function(Value)
            if Value then
                if not _G.HeadBobDisabler then
                    _G.HeadBobDisabler = runService.RenderStepped:Connect(function()
                        if (RequiredMainGame and RequiredMainGame.spring) then
                            if (typeof(RequiredMainGame.spring.Target) == 'Vector3') then
                                RequiredMainGame.spring.Target = Vector3.zero
                                RequiredMainGame.spring.Position = Vector3.zero
                            end
                        end
                    end)
                end
            elseif _G.HeadBobDisabler then
                _G.HeadBobDisabler:Disconnect()

                _G.HeadBobDisabler = nil
            end
        end,
    })
    VisualsTab:AddCheckbox('NoFog', {
        Text = '禁用雾效',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local lighting = game:GetService('Lighting')
            local cave = lighting:FindFirstChild('CaveAtmosphere')

            if Value then
                if (cave and cave:IsA('Atmosphere')) then
                    cave.Density = 0
                else
                    lighting.FogStart = 1000000
                    lighting.FogEnd = 1000000
                end
            elseif (cave and cave:IsA('Atmosphere')) then
                cave.Density = 0.15
            else
                lighting.FogStart = 150
                lighting.FogEnd = 150
            end
        end,
    })

    local Players = game:GetService('Players')
    local RunService = game:GetService('RunService')
    local LocalPlayer = Players.LocalPlayer
    local Camera = workspace.CurrentCamera
    local Lighting = game:GetService('Lighting')
    local RunService = game:GetService('RunService')
    local fullbrightEnabled = false
    local ambienceColor = Color3.new(1, 1, 1)

    VisualsTab:AddCheckbox('Ambience', {
        Text = '全亮模式',
        Default = false,
        Disabled = false,
        Tooltip = "更改贴图的颜色色调",
        Callback = function(Value)
            fullbrightEnabled = Value
            Lighting.GlobalShadows = not Value
            Lighting.OutdoorAmbient = (Value and ambienceColor) or Color3.new(0, 0, 0)
        end,
    }):AddColorPicker('AmbienceColor', {
        Default = Color3.new(1, 1, 1),
        Title = '颜色色调',
        Callback = function(Value)
            ambienceColor = Value

            if fullbrightEnabled then
                Lighting.OutdoorAmbient = Value
            end
        end,
    })
    coroutine.wrap(function()
        while true do
            if fullbrightEnabled then
                Lighting.GlobalShadows = false
                Lighting.OutdoorAmbient = ambienceColor
            end

            wait(1)
        end
    end)()
    VisualsTab:AddCheckbox('TransparentCloset', {
        Text = '透明柜子',
        Default = false,
        Disabled = false,
        Callback = function(value)
            local rooms = workspace:WaitForChild('CurrentRooms')
            local player = game.Players.LocalPlayer
            local playerModel = workspace:WaitForChild(player.Name)

            if getgenv().TransparentClosetConn then
                getgenv().TransparentClosetConn:Disconnect()

                getgenv().TransparentClosetConn = nil
            end
            if getgenv().HidingAttrConn then
                getgenv().HidingAttrConn:Disconnect()

                getgenv().HidingAttrConn = nil
            end

            local function updateClosetsTransparency(isHiding)
                for _, v in ipairs(rooms:GetDescendants())do
                    if v:FindFirstChild('HidePrompt') then
                        for _, part in ipairs(v:GetChildren())do
                            if (part:IsA('BasePart') and not ((part.Name == 'PlayerCollision') or (part.Name == 'Collision'))) then
                                part.Transparency = (value and isHiding and 0.6) or 0
                            end
                        end
                    end
                end
            end

            if value then
                getgenv().HidingAttrConn = playerModel:GetAttributeChangedSignal('Hiding'):Connect(function()
                    local isHiding = playerModel:GetAttribute('Hiding')

                    updateClosetsTransparency(isHiding)
                end)
                getgenv().TransparentClosetConn = rooms.DescendantAdded:Connect(function(v)
                    if v:FindFirstChild('HidePrompt') then
                        local isHiding = playerModel:GetAttribute('Hiding')

                        for _, part in ipairs(v:GetChildren())do
                            if (part:IsA('BasePart') and not ((part.Name == 'PlayerCollision') or (part.Name == 'Collision'))) then
                                part.Transparency = (isHiding and value and 0.6) or 0
                            end
                        end
                    end
                end)

                updateClosetsTransparency(playerModel:GetAttribute('Hiding'))
            else
                updateClosetsTransparency(false)
            end
        end,
    })

    local ReplicatedStorage = game:GetService('ReplicatedStorage')
    local Players = game:GetService('Players')
    local player = Players.LocalPlayer
    local FloorReplicated = ReplicatedStorage:FindFirstChild('FloorReplicated')
    local timerValue = FloorReplicated and FloorReplicated:FindFirstChild('DigitalTimer')

    VisualsTab:AddCheckbox('HasteTimer', {
        Text = '加速计时器',
        Default = false,
        Disabled = false,
        Callback = function(value)
            if value then
                local playerGui = player:WaitForChild('PlayerGui')
                local screenGui = playerGui:FindFirstChild('HasteTimerGui')

                if not screenGui then
                    screenGui = Instance.new('ScreenGui')
                    screenGui.Name = 'HasteTimerGui'
                    screenGui.Parent = playerGui
                end

                local textButton = screenGui:FindFirstChild('TimerButton')

                if not textButton then
                    textButton = Instance.new('TextButton')
                    textButton.Name = 'TimerButton'
                    textButton.Size = UDim2.new(0.2, 0, 0.05, 0)
                    textButton.Position = UDim2.new(0.4, 0, 0.9, 0)
                    textButton.Text = '00:00:00.000'
                    textButton.TextSize = 14
                    textButton.BackgroundTransparency = 0.5
                    textButton.BackgroundColor3 = Color3.new(0, 0, 0)
                    textButton.TextColor3 = Color3.new(1, 1, 1)
                    textButton.Parent = screenGui
                end

                local function updateTimer()
                    local total = timerValue.Value
                    local hours = math.floor(total / 3600)
                    local minutes = math.floor((total % 3600) / 60)
                    local seconds = total % 60

                    textButton.Text = string.format('%02d:%02d:%02d', hours, minutes, seconds)
                end

                updateTimer()

                if not textButton:FindFirstChild('Connection') then
                    local conn = timerValue.Changed:Connect(updateTimer)

                    conn.Name = 'Connection'
                    conn.Parent = textButton
                end
            else
                local screenGui = player:FindFirstChild('PlayerGui'):FindFirstChild('HasteTimerGui')

                if screenGui then
                    local button = screenGui:FindFirstChild('TimerButton')

                    if button then
                        local conn = button:FindFirstChild('Connection')

                        if conn then
                            conn:Disconnect()
                        end
                    end

                    screenGui:Destroy()
                end
            end
        end,
    })
    VisualsTab:AddDivider()
    VisualsTab:AddCheckbox('Thirdperson', {
        Text = '第三人称视角',
        Default = false,
        Disabled = false,
        Tooltip = '从后面显示您的角色.',
        Callback = function(Value)
            if Value then
                AntiConnections['Thirdperson'] = RunService.RenderStepped:Connect(function()
                    local Cam = workspace.CurrentCamera

                    Cam.CFrame = Cam.CFrame * CFrame.new(Options.ThirdpersonOffset.Value, Options.ThirdpersonOffsetUp.Value, 3.5 * (Options.ThirdpersonDistance.Value / 7.5))

                    local character = game.Players.LocalPlayer.Character

                    if character then
                        local head = character:FindFirstChild('Head')

                        if head then
                            head.LocalTransparencyModifier = 0
                        end

                        for _, accessory in pairs(character:GetChildren())do
                            if accessory:IsA('Accessory') then
                                local handle = accessory:FindFirstChild('Handle')

                                if handle then
                                    handle.LocalTransparencyModifier = 0
                                end
                            end
                        end
                    end
                end)
            elseif AntiConnections['Thirdperson'] then
                AntiConnections['Thirdperson']:Disconnect()
            end
        end,
    }):AddKeyPicker('ThirdpersonKey', {
        Default = 'V',
        SyncToggleState = true,
        Mode = 'Toggle',
        Text = '第三人称',
        NoUI = false,
        Callback = function(Value) end,
    })
    VisualsTab:AddSlider('ThirdpersonDistance', {
        Text = '第三人称距离',
        Default = 19,
        Min = 5,
        Max = 30,
        Rounding = 0,
        Compact = true,
        Tooltip = '摄像机在第三人称下有多远.',
    })
    VisualsTab:AddSlider('ThirdpersonOffset', {
    Text = '第三人称侧偏移',
    Default = 0,
    Min = -5,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Tooltip = '摄像机在第三人称下有多远', 
})

    VisualsTab:AddSlider('ThirdpersonOffsetUp', {
        Text = '第三人称高度偏移',
        Default = 0,
        Min = -5,
        Max = 5,
        Rounding = 1,
        Compact = true,
        Tooltip = '以第三人称向上/向下移动摄像头.',
    })
    VisualsTab:AddDivider()
    VisualsTab:AddSlider('FOV', {
        Text = '视野范围',
        Default = 70,
        Min = 0,
        Max = 120,
        Rounding = 1,
        Compact = true,
        Tooltip = '每帧平滑地更改摄影机视野.',
        Callback = function(TargetFOV)
            TargetFOV = math.clamp(TargetFOV, 0, 120)

            local CurrentFOV = workspace.CurrentCamera.FieldOfView or 70
            local Smoothing = 15
            local Threshold = 0.05

            if _G.FOVConnection then
                _G.FOVConnection:Disconnect()
            end

            _G.FOVConnection = RunService.RenderStepped:Connect(function(dt)
                CurrentFOV = CurrentFOV + ((TargetFOV - CurrentFOV) * (1 - math.exp(-Smoothing * dt)))

                if (math.abs(TargetFOV - CurrentFOV) < Threshold) then
                    CurrentFOV = TargetFOV
                end

                workspace.CurrentCamera.FieldOfView = CurrentFOV
            end)
        end,
    })

    local EffectsTabe = LeftTabBox:AddTab('Effects')

    EffectsTabe:AddCheckbox('NoVoidEffect', {
        Text = '防坠落虚空效果',
        Default = false,
        Disabled = false,
        Tooltip = '消除落空效果.',
        Callback = function(Value)
            local ReplicatedStorage = game:GetService('ReplicatedStorage')
            local entityModules = ReplicatedStorage:FindFirstChild('ModulesClient') and ReplicatedStorage.ModulesClient:FindFirstChild('EntityModules')

            if not entityModules then
                return
            end

            local voidModule = entityModules:FindFirstChild('Void') or entityModules:FindFirstChild('_Void')

            if not voidModule then
                return
            end
            if Value then
                if (voidModule.Name == 'Void') then
                    voidModule.Name = '_Void'
                end
            elseif (voidModule.Name == '_Void') then
                voidModule.Name = 'Void'
            end
        end,
    })
    EffectsTabe:AddCheckbox('NoHasteEffects', {
        Text = '防加速特效',
        Default = false,
        Disabled = false,
        Tooltip = '当出现“急速”时删除红色边.',
        Callback = function(Value)
            if game.ReplicatedStorage.FloorReplicated.ClientRemote:FindFirstChild('Haste') then
                local HasteChanged = game.ReplicatedStorage.FloorReplicated.ClientRemote.Haste.Ambience:GetPropertyChangedSignal('Playing'):Connect(function()
                    if Value then
                        game.ReplicatedStorage.FloorReplicated.ClientRemote.Haste.Ambience.Playing = false
                    end
                end)

                table.insert(Connections, HasteChanged)
            end

            for _, v in workspace.CurrentCamera:GetChildren()do
                if ((v.Name == 'LiveSanity') and workspace:FindFirstChild('EntityModel')) then
                    v.Enabled = not Value
                end
            end
        end,
    })
    EffectsTabe:AddCheckbox('AntiFiredamp', {
        Text = '防烟雾',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local camera = workspace:WaitForChild('Camera')
            local targets = {
                LiveSantity = true,
                LiveFiredamp = true,
            }

            local function checkAndDelete(obj)
                if targets[obj.Name] then
                    obj:Destroy()
                    print('Deleted object: ' .. obj.Name)
                end
            end

            if _G.AntiFiredampConnection then
                _G.AntiFiredampConnection:Disconnect()

                _G.AntiFiredampConnection = nil
            end
            if Value then
                for _, child in ipairs(camera:GetChildren())do
                    checkAndDelete(child)
                end

                _G.AntiFiredampConnection = camera.ChildAdded:Connect(function(child)
                    checkAndDelete(child)
                end)
            end
        end,
    })
    EffectsTabe:AddCheckbox('CaveAtmosphere', {
        Text = '防矿坑雾效',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if Value then
                local caveAtmosphere = Lighting:FindFirstChild('CaveAtmosphere')

                if caveAtmosphere then
                    caveAtmosphere:Destroy()
                end

                local caves = Lighting:FindFirstChild('Caves')

                if caves then
                    caves:Destroy()
                end
            end
        end,
    })
    EffectsTabe:AddCheckbox('Sanity', {
        Text = '防氧气/理智特效',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if Value then
                local sanity = Lighting:FindFirstChild('Sanity')

                if sanity then
                    sanity:Destroy()
                end

                local oxygenCC = Lighting:FindFirstChild('OxygenCC')

                if oxygenCC then
                    oxygenCC:Destroy()
                end

                local oxygenBlur = Lighting:FindFirstChild('OxygenBlur')

                if oxygenBlur then
                    oxygenBlur:Destroy()
                end
            end
        end,
    })

    local NotifyGroup = Tabs.Entities:AddLeftGroupbox('Entity Notifications')
    local EntityNotifications = {
        Screech = {
            Description = 'Screech 生成了',
            Color = Color3.fromRGB(255, 255, 0),
        },
        Halt = {
            Description = 'Halt 在这',
            Color = Color3.fromRGB(0, 255, 255),
        },
        FigureRig = {
            Description = 'Figure 检测到了',
            Color = Color3.fromRGB(255, 0, 0),
        },
        Eyes = {
            Description = 'Eyes 生成了',
            Color = Color3.fromRGB(127, 30, 220),
        },
        SeekMoving = {
            Description = 'Seek 追逐战祝你好运',
            Color = Color3.fromRGB(255, 100, 100),
        },
        RushMoving = {
            Description = 'Rush 来了',
            Color = Color3.fromRGB(0, 255, 0),
        },
        AmbushMoving = {
            Description = 'Ambush 生成了',
            Color = Color3.fromRGB(80, 255, 110),
        },
        A60 = {
            Description = 'A-60 在冲刺',
            Color = Color3.fromRGB(200, 50, 50),
        },
        A120 = {
            Description = 'A-120 在附近',
            Color = Color3.fromRGB(55, 55, 55),
        },
        GiggleCeiling = {
            Description = 'Giggle 在天花板上',
            Color = Color3.fromRGB(200, 200, 200),
        },
        GrumbleRig = {
            Description = 'Grumble 正在巡逻',
            Color = Color3.fromRGB(150, 150, 150),
        },
        GloombatSwarm = {
            Description = 'Gloombat 蜂群传入',
            Color = Color3.fromRGB(100, 100, 100),
        },
        Dread = {
            Description = 'Dread 生成了',
            Color = Color3.fromRGB(80, 80, 80),
        },
        BackdoorLookman = {
            Description = 'Lookman 在看',
            Color = Color3.fromRGB(110, 15, 15),
        },
        Snare = {
            Description = 'Snare 生成了',
            Color = Color3.fromRGB(100, 100, 100),
        },
        WorldLotus = {
            Description = 'World Lotus 检测到了',
            Color = Color3.fromRGB(200, 230, 50),
        },
        Bramble = {
            Description = 'Bramble 生成了',
            Color = Color3.fromRGB(50, 150, 30),
        },
        Caws = {
            Description = 'Caws 飞起来了',
            Color = Color3.fromRGB(30, 30, 30),
        },
        Eyestalk = {
            Description = 'Eyestalk 会追着你',
            Color = Color3.fromRGB(150, 80, 200),
        },
        Grampy = {
            Description = 'Grampy 在这',
            Color = Color3.fromRGB(180, 180, 180),
        },
        Groundskeeper = {
            Description = 'Groundskeeper 在附近',
            Color = Color3.fromRGB(100, 150, 50),
        },
        Mandrake = {
            Description = 'Mandrake 在尖叫',
            Color = Color3.fromRGB(130, 80, 30),
        },
        Monument = {
            Description = 'Monument 出现了',
            Color = Color3.fromRGB(150, 150, 150),
        },
        Surge = {
            Description = 'Surge 生成了',
            Color = Color3.fromRGB(230, 130, 30),
        },
        BackdoorRush = {
            Description = 'BLITZ 来了',
            Color = Color3.fromRGB(230, 130, 30),
        },
    }
    local entityList = {
        'Screech',
        'Halt',
        'FigureRig',
        'Eyes',
        'SeekMoving',
        'RushMoving',
        'AmbushMoving',
        'A60',
        'A120',
        'GiggleCeiling',
        'GrumbleRig',
        'GloombatSwarm',
        'Dread',
        'BackdoorLookman',
        'Snare',
        'WorldLotus',
        'Bramble',
        'Caws',
        'Eyestalk',
        'Grampy',
        'Groundskeeper',
        'Mandrake',
        'Monument',
        'Surge',
        'LiveEntityBramble',
        'BackdoorRush',
    }

    NotifyGroup:AddDropdown('NotifyEntitiesDropdown', {
        Text = '实体出现时通知',
        Default = {},
        Multi = true,
        Values = entityList,
        Callback = function(selectedEntities)
            if AntiConnections['NotifyEntities'] then
                AntiConnections['NotifyEntities']:Disconnect()
                AntiConnections['NotifyEntitiesRooms']:Disconnect()
            end
            if next(selectedEntities) then
                AntiConnections['NotifyEntities'] = workspace.ChildAdded:Connect(function(child)
                    if (child:IsA('Model') and EntityNotifications[child.Name] and selectedEntities[child.Name]) then
                        Library:Notify(EntityNotifications[child.Name].Description, 5)
                    end
                end)
                AntiConnections['NotifyEntitiesRooms'] = Rooms.DescendantAdded:Connect(function(desc)
                    if (desc:IsA('Model') and EntityNotifications[desc.Name] and selectedEntities[desc.Name]) then
                        Library:Notify(EntityNotifications[desc.Name].Description, 5)
                    end
                end)
            end
        end,
    })

    local AntiGroup = Tabs.Entities:AddRightGroupbox('Avoid Entities')

    AntiConnections = AntiConnections or {}

    AntiGroup:AddCheckbox('AntiScreech', {
        Text = '防Screech',
        Default = false,
        Disabled = false,
        Callback = function(on)
            if on then
                for _, inst in ipairs(workspace:GetDescendants())do
                    if (inst.Name == 'Screech') then
                        pcall(function()
                            inst:Destroy()
                        end)
                    end
                end

                AntiConnections.Screech = workspace.DescendantAdded:Connect(function(inst)
                    if (inst.Name == 'Screech') then
                        task.defer(function()
                            if (inst and inst.Parent) then
                                pcall(function()
                                    inst:Destroy()
                                end)
                            end
                        end)
                    end
                end)
            elseif AntiConnections.Screech then
                AntiConnections.Screech:Disconnect()

                AntiConnections.Screech = nil
            end
        end,
    })

    local connection

    AntiGroup:AddCheckbox('AntiGloomPile', {
        Text = '防GloomPile',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if getgenv().AntiGloomConn then
                getgenv().AntiGloomConn:Disconnect()

                getgenv().AntiGloomConn = nil
            end

            local rooms = workspace:WaitForChild('CurrentRooms')

            if Value then
                for _, v in ipairs(rooms:GetDescendants())do
                    if (v.Name == 'GloomEgg') then
                        local egg = v:FindFirstChild('Egg')

                        if egg then
                            egg.CanTouch = false
                        end
                    end
                end

                getgenv().AntiGloomConn = rooms.DescendantAdded:Connect(function(v)
                    if (v.Name == 'GloomEgg') then
                        local egg = v:WaitForChild('Egg', 8999999488)

                        egg.CanTouch = false
                    elseif ((v.Name == 'Egg') and v.Parent and (v.Parent.Name == 'GloomEgg')) then
                        v.CanTouch = false
                    end
                end)
            else
                for _, v in ipairs(rooms:GetDescendants())do
                    if (v.Name == 'GloomEgg') then
                        local egg = v:FindFirstChild('Egg')

                        if egg then
                            egg.CanTouch = true
                        end
                    end
                end
            end
        end,
    })
    AntiGroup:AddCheckbox('AntiDread', {
        Text = '防Dread',
        Default = false,
        Disabled = false,
        Callback = function(isEnabled)
            local player = game:GetService('Players').LocalPlayer
            local modules = player.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener.Modules
            local dreadModule = modules:FindFirstChild('Dread') or modules:FindFirstChild('_Dread')

            if dreadModule then
                dreadModule.Name = (isEnabled and '_Dread') or 'Dread'
            end
        end,
    })
    AntiGroup:AddCheckbox('AntiGiggle', {
        Text = '防Giggle',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if getgenv().AntiGiggleConn then
                getgenv().AntiGiggleConn:Disconnect()

                getgenv().AntiGiggleConn = nil
            end

            local rooms = workspace:WaitForChild('CurrentRooms')

            if Value then
                for _, v in ipairs(rooms:GetDescendants())do
                    if (v.Name == 'GiggleCeiling') then
                        local hitbox = v:FindFirstChild('Hitbox')

                        if hitbox then
                            hitbox.CanTouch = false
                        end
                    end
                end

                getgenv().AntiGiggleConn = rooms.DescendantAdded:Connect(function(v)
                    if (v.Name == 'GiggleCeiling') then
                        local hitbox = v:WaitForChild('Hitbox', 8999999488)

                        hitbox.CanTouch = false
                    elseif ((v.Name == 'Hitbox') and v.Parent and (v.Parent.Name == 'GiggleCeiling')) then
                        v.CanTouch = false
                    end
                end)
            else
                for _, v in ipairs(rooms:GetDescendants())do
                    if (v.Name == 'GiggleCeiling') then
                        local hitbox = v:FindFirstChild('Hitbox')

                        if hitbox then
                            hitbox.CanTouch = true
                        end
                    end
                end
            end
        end,
    })
    AntiGroup:AddCheckbox('NoHidingVignette', {
        Text = '防void伤害',
        Default = false,
        Disabled = false,
        Tooltip = '隐藏时删除暗边.',
        Callback = function(Value)
            LocalPlayer.PlayerGui.MainUI.MainFrame.HideVignette.Image = (Value and 'rbxassetid://0') or 'rbxassetid://6100076320'
        end,
    })

    local RunService = game:GetService('RunService')
    local crouchConnection

    AntiGroup:AddCheckbox('AntiFigure', {
        Text = '防Fugure听见',
        Default = false,
        Disabled = false,
        Tooltip = "让游戏以为你在蹲着",
        Callback = function(Value)
            isCrouching = Value

            if crouchConnection then
                crouchConnection:Disconnect()

                crouchConnection = nil
            end
            if Value then
                crouchConnection = RunService.Heartbeat:Connect(function()
                    ReplicatedStorage.RemotesFolder.Crouch:FireServer(true)
                end)
            else
                ReplicatedStorage.RemotesFolder.Crouch:FireServer(false)
            end
        end,
    })
    AntiGroup:AddCheckbox('NoSurge', {
        Text = '防Surge',
        Default = false,
        Disabled = false,
        Tooltip = '线路用千斤顶的信用',
        Callback = function(Value)
            if Value then
                local surgeClient = game.ReplicatedStorage:WaitForChild('FloorReplicated'):WaitForChild('ClientRemote'):FindFirstChild('SurgeClient')

                if surgeClient then
                    surgeClient:Destroy()
                end
            end
        end,
    })

    local ReplicatedStorage = game:GetService('ReplicatedStorage')

    AntiGroup:AddCheckbox('AntiHalt', {
        Text = '防Halt',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local entityModules = game:GetService('ReplicatedStorage'):WaitForChild('ModulesClient'):WaitForChild('EntityModules')

            if Value then
                local shade = entityModules:FindFirstChild('Shade')

                if (shade and shade:IsA('ModuleScript')) then
                    shade.Name = '_Shade'
                end
            else
                local shade = entityModules:FindFirstChild('_Shade')

                if (shade and shade:IsA('ModuleScript')) then
                    shade.Name = 'Shade'
                end
            end
        end,
    })

    local RunService = game:GetService('RunService')

    AntiGroup:AddCheckbox('AntiLookman', {
        Text = '防Lookman',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if Value then
                if alive then
                    if Workspace:FindFirstChild('BackdoorLookman') then
                        RemoteFolder.MotorReplication:FireServer(-890)
                    end
                end
            end
        end,
    })
    AntiGroup:AddCheckbox('AntiSnare', {
        Text = '防snare',
        Default = false,
        Callback = function(Value)
            local currentRooms = workspace:WaitForChild('CurrentRooms')

            local function handleSnare(snare)
                if (snare.Name == 'Snare') then
                    local hitbox = snare:FindFirstChild('Hitbox')

                    if hitbox then
                        hitbox.CanTouch = not Value
                    else
                        snare.ChildAdded:Connect(function(child)
                            if (child.Name == 'Hitbox') then
                                child.CanTouch = not Value
                            end
                        end)
                    end
                end
            end

            for _, v in ipairs(currentRooms:GetDescendants())do
                handleSnare(v)
            end

            currentRooms.DescendantAdded:Connect(handleSnare)
        end,
    })
    AntiGroup:AddCheckbox('AntiSeekArmsChandelier', {
        Text = '防追逐障碍',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if Value then
                AntiConnections['SeekArmsChandelier'] = Rooms.DescendantAdded:Connect(function(desc)
                    if (desc.Name == 'Seek_Arm') then
                        desc:WaitForChild('AnimatorPart', 8999999488)

                        desc.AnimatorPart.CanTouch = false
                        desc.AnimatorPart.Transparency = 1

                        for _, part in desc:GetDescendants()do
                            if part:IsA('BasePart') then
                                part.Transparency = 1
                            end
                        end
                    elseif (desc.Name == 'ChandelierObstruction') then
                        desc:WaitForChild('HurtPart', 8999999488)

                        desc.HurtPart.CanTouch = false
                        desc.HurtPart.Transparency = 1

                        for _, part in desc:GetDescendants()do
                            if part:IsA('BasePart') then
                                part.Transparency = 1
                            end
                        end
                    end
                end)

                for _, v in Rooms:GetDescendants()do
                    if ((v.Name == 'Seek_Arm') and v:IsA('Model')) then
                        v:WaitForChild('AnimatorPart', 8999999488)

                        v.AnimatorPart.CanTouch = false
                        v.AnimatorPart.Transparency = 1

                        for _, part in v:GetDescendants()do
                            if part:IsA('BasePart') then
                                part.Transparency = 1
                            end
                        end
                    elseif ((v.Name == 'ChandelierObstruction') and v:IsA('Model')) then
                        v:WaitForChild('HurtPart', 8999999488)

                        v.HurtPart.CanTouch = false
                        v.HurtPart.Transparency = 1

                        for _, part in v:GetDescendants()do
                            if part:IsA('BasePart') then
                                part.Transparency = 1
                            end
                        end
                    end
                end
            else
                if AntiConnections['SeekArmsChandelier'] then
                    AntiConnections['SeekArmsChandelier']:Disconnect()
                end

                for _, v in Rooms:GetDescendants()do
                    if ((v.Name == 'Seek_Arm') and v:IsA('Model')) then
                        v:WaitForChild('AnimatorPart', 8999999488)

                        v.AnimatorPart.CanTouch = true
                        v.AnimatorPart.Transparency = 0

                        for _, part in v:GetDescendants()do
                            if part:IsA('BasePart') then
                                part.Transparency = 0
                            end
                        end
                    elseif ((v.Name == 'ChandelierObstruction') and v:IsA('Model')) then
                        v:WaitForChild('HurtPart', 8999999488)

                        v.HurtPart.CanTouch = true
                        v.HurtPart.Transparency = 0

                        for _, part in v:GetDescendants()do
                            if part:IsA('BasePart') then
                                part.Transparency = 0
                            end
                        end
                    end
                end
            end
        end,
    })
    AntiGroup:AddCheckbox('AntiDupe', {
        Text = '防重复门',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants())do
                if (v.Name == 'DoorFake') then
                    v:WaitForChild('Hidden').CanTouch = not Value

                    local lock = v:FindFirstChild('Lock')

                    if lock then
                        local prompt = lock:FindFirstChildOfClass('ProximityPrompt')

                        if prompt then
                            prompt.ClickablePrompt = not Value
                        end
                    end
                end
            end
        end,
    })
    AntiGroup:AddCheckbox('AntiVacuum', {
        Text = '防Vacuum',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants())do
                if (v.Name == 'SideroomSpace') then
                    for _, part in ipairs(v:GetChildren())do
                        if part:IsA('BasePart') then
                            part.CanTouch = not Value
                            part.CanCollide = Value
                        end
                    end
                end
            end
        end,
    })
    AntiGroup:AddCheckbox('AntiEyes', {
        Text = '防Eyes',
        Default = false,
        Disabled = false,
        Tooltip = [[Automatically looks down when Eyes spawns to prevent damage.]],
        Callback = function(Value)
            if Value then
                Connections.AntiEyes = game:GetService('RunService').RenderStepped:Connect(function()
                    if (not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart')) then
                        return
                    end
                    if not LocalPlayer.Character:GetAttribute('Hiding') then
                        for _, v in pairs(workspace:GetChildren())do
                            if ((v.Name == 'Eyes') and v:FindFirstChild('Core') and v.Core:FindFirstChild('Ambience') and v.Core.Ambience.Playing) then
                                game.ReplicatedStorage.RemotesFolder.MotorReplication:FireServer(-650)

                                break
                            end
                        end
                    end
                end)
            elseif Connections.AntiEyes then
                Connections.AntiEyes:Disconnect()

                Connections.AntiEyes = nil
            end
        end,
    })

    local BringGroup = Tabs.Misc:AddRightGroupbox('Fun')

    BringGroup:AddButton('EnableStarrift', {
        Text = '启用星裂',
        Visible = true,
        Func = function()
            local lighting = game:GetService('Lighting')
            local currentRooms = workspace:FindFirstChild('CurrentRooms')

            if not currentRooms then
                Library:Notify('Star Rift not found. Go to Room 100 or the Mines', 2)

                return
            end

            local found = false

            for _, room in ipairs(currentRooms:GetChildren())do
                local riftSpawn = room:FindFirstChild('RiftSpawn')

                if riftSpawn then
                    local rift = riftSpawn:FindFirstChild('Rift')

                    if rift then
                        local starCenter = rift:FindFirstChild('StarCenter')

                        if starCenter then
                            found = true

                            local innerRift = starCenter:FindFirstChild('Rift')

                            if (innerRift and innerRift:IsA('BasePart')) then
                                innerRift.Transparency = 0
                            end

                            local prompt = starCenter:FindFirstChild('StarRiftPrompt')

                            if (prompt and prompt:IsA('ProximityPrompt')) then
                                prompt.Enabled = true
                            end

                            local attachment = starCenter:FindFirstChild('Attachment')

                            if attachment then
                                local light = attachment:FindFirstChildOfClass('PointLight')

                                if light then
                                    light.Brightness = 1
                                end
                            end

                            local particles = starCenter:FindFirstChild('ParticlesIn')

                            if particles then
                                for _, name in ipairs({
                                    'Core',
                                    'RainbowShards',
                                    'Triangles',
                                    'ZoomParticle',
                                })do
                                    local emitter = particles:FindFirstChild(name)

                                    if (emitter and emitter:IsA('ParticleEmitter')) then
                                        emitter.Enabled = true
                                    end
                                end
                            end
                        end
                    end
                end
            end

            if not found then
                Library:Notify('Star Rift not found. Go to Room 100 or the Mines', 2)
            end
        end,
    })
    BringGroup:AddButton({
        Text = '获取异常方块',
        Func = function()
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:WaitForChild('HumanoidRootPart')
            local interval = 1
            local studsPerMove = 10
            local downPerMove = 4
            local progress = 0
            local maxProgress = 100
            local progressIncrement = 20
            local ReplicatedStorage = game:GetService('ReplicatedStorage')
            local Players = game:GetService('Players')
            local glitchModule = ReplicatedStorage.ModulesClient.EntityModules.Glitch
            local glitchModel = ReplicatedStorage.Entities.Glitch
            local glitchScreen = player.PlayerGui.MainUI.MainFrame.GlitchScreen
            local isMoving = true
            local glitchActive = false

            local function onGlitchDetected()
                if (not glitchActive and (progress < maxProgress)) then
                    glitchActive = true
                    progress = progress + progressIncrement

                    Library:Notify(progress .. '% done', 2)

                    if (progress >= maxProgress) then
                        isMoving = false

                        Library:Notify('Completed. Movement stopped.', 3)
                    end

                    task.wait(2)

                    glitchActive = false
                end
            end
            local function monitorGlitchScreen()
                glitchScreen:GetPropertyChangedSignal('Visible'):Connect(function()
                    if glitchScreen.Visible then
                        onGlitchDetected()
                    end
                end)
            end
            local function monitorGlitchModel()
                glitchModel.ChildAdded:Connect(function(child)
                    if (child.Name == 'Glitch') then
                        onGlitchDetected()
                    end
                end)
            end

            pcall(monitorGlitchScreen)
            pcall(monitorGlitchModel)
            task.spawn(function()
                while isMoving do
                    if (character and character.Parent and hrp and hrp.Parent) then
                        hrp.CFrame = hrp.CFrame * CFrame.new(-studsPerMove, -downPerMove, 0)
                    else
                        character = player.Character or player.CharacterAdded:Wait()
                        hrp = character:WaitForChild('HumanoidRootPart')
                    end

                    task.wait(interval)
                end
            end)
            player.CharacterAdded:Connect(function(newCharacter)
                character = newCharacter
                hrp = character:WaitForChild('HumanoidRootPart')
            end)
        end,
    })
    BringGroup:AddButton({
        Text = '获取NVCS-3000',
        Func = function()
            _G.scanner_fps = 60
            _G.disable_static = false

            loadstring(game:HttpGet([[https://raw.githubusercontent.com/notpoiu/Scripts/main/Scanner.lua]]))()
        end,
    })

    local WALL_DISTANCE = 7
    local WALL_SIZE = Vector3.new(12, 12, 12)
    local WALL_COLOR = Color3.fromRGB(0, 0, 0)
    local WALL_TRANSPARENCY = 1

    local function createWallInFrontOfDoor()
        local currentRooms = workspace:FindFirstChild('CurrentRooms')

        if not currentRooms then
            return
        end

        local room0 = currentRooms:FindFirstChild('0')

        if not room0 then
            return
        end

        local door = room0:FindFirstChild('Door')

        if not door then
            return
        end

        local doorCFrame

        if door:IsA('Model') then
            if door.PrimaryPart then
                doorCFrame = door.PrimaryPart.CFrame
            else
                local firstPart = door:FindFirstChildOfClass('Part') or door:FindFirstChildOfClass('MeshPart')

                if firstPart then
                    doorCFrame = firstPart.CFrame
                else
                    return
                end
            end
        elseif door:IsA('BasePart') then
            doorCFrame = door.CFrame
        else
            return
        end

        local wallCFrame = doorCFrame * CFrame.new(0, 0, -WALL_DISTANCE) * CFrame.Angles(0, math.rad(90), 0)
        local wall = Instance.new('Part')

        wall.Name = 'SpawnedWall'
        wall.Size = WALL_SIZE
        wall.CFrame = wallCFrame
        wall.Color = WALL_COLOR
        wall.Transparency = WALL_TRANSPARENCY
        wall.Material = Enum.Material.Plastic
        wall.TopSurface = Enum.SurfaceType.Smooth
        wall.BottomSurface = Enum.SurfaceType.Smooth
        wall.CanCollide = false
        wall.Anchored = true
        wall.Parent = room0

        return wall
    end

    local isActive = false
    local connection
    local screenGui
    local runServiceConnection

    BringGroup:AddButton('speedrun', {
        Text = 'spreedrun timer',
        Default = false,
        Func = function()
            if isActive then
                Library:Notify('already enabled bro', 2)

                return
            end

            isActive = true

            local success, wall = pcall(createWallInFrontOfDoor)

            if (not success or not wall) then
                isActive = false

                return
            end

            local hasTriggered = false

            connection = wall.Touched:Connect(function()
                if hasTriggered then
                    return
                end

                hasTriggered = true

                local player = game.Players.LocalPlayer

                if not player then
                    return
                end

                local playerGui = player:WaitForChild('PlayerGui', 5)

                if not playerGui then
                    return
                end

                screenGui = Instance.new('ScreenGui', playerGui)

                local textButton = Instance.new('TextButton', screenGui)

                textButton.Size = UDim2.new(0.2, 0, 0.05, 0)
                textButton.Position = UDim2.new(0.4, 0, 0.02, 0)
                textButton.Text = '00:00:00.000'
                textButton.TextSize = 14
                textButton.BackgroundTransparency = 0.5
                textButton.BackgroundColor3 = Color3.new(0, 0, 0)
                textButton.TextColor3 = Color3.new(1, 1, 1)

                local startTime = tick()

                runServiceConnection = game:GetService('RunService').Heartbeat:Connect(function()
                    if (not textButton or not textButton.Parent) then
                        runServiceConnection:Disconnect()

                        return
                    end

                    local elapsed = tick() - startTime
                    local hours = math.floor(elapsed / 3600)

                    elapsed = elapsed % 3600

                    local minutes = math.floor(elapsed / 60)
                    local seconds = math.floor(elapsed % 60)
                    local milliseconds = math.floor((elapsed % 1) * 1000)

                    textButton.Text = string.format('%02d:%02d:%02d.%03d', hours, minutes, seconds, milliseconds)
                end)

                if connection then
                    connection:Disconnect()

                    connection = nil
                end
                if wall then
                    wall:Destroy()
                end
            end)
        end,
    })
    BringGroup:AddDivider()
    BringGroup:AddLabel([[<font color="rgb(255, 255, 255)"><b>actually not that fun stuff</b></font>]])
    BringGroup:AddButton({
        Text = '复活',
        Func = function()
            game.ReplicatedStorage.RemotesFolder.Revive:FireServer()
        end,
    })
    BringGroup:AddButton({
        Text = '重置角色',
        Func = function()
            local player = game.Players.LocalPlayer

            if (player and player.Character and player.Character:FindFirstChild('Humanoid')) then
                player.Character.Humanoid.Health = 0
            end
        end,
    })
    BringGroup:AddButton({
        Text = '返回大厅',
        Func = function()
            game.ReplicatedStorage.RemotesFolder.Lobby:FireServer()
        end,
    })
    BringGroup:AddButton({
        Text = '再玩一次',
        Func = function()
            game.ReplicatedStorage.RemotesFolder.PlayAgain:FireServer()
        end,
    })

    local CheatStuff = Tabs.Misc:AddLeftGroupbox('功能')
    local EntityDistances = {
        RushMoving = 50,
        BackdoorRush = 50,
        AmbushMoving = 100,
        A60 = 100,
        A120 = 35,
    }
    local Rooms = workspace.CurrentRooms
    local LocalPlayer = game.Players.LocalPlayer

    local function GetHiding()
        local Closest
        local Prompt
        local currRoom = Rooms and Rooms[LocalPlayer:GetAttribute('CurrentRoom')]

        if not currRoom then
            return nil
        end

        local char = LocalPlayer.Character

        if not char then
            return nil
        end

        local hrp = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Collision') or char.PrimaryPart

        if not hrp then
            return nil
        end

        local function distFromPlayer(model)
            if not model then
                return math.huge
            end

            local part = model.PrimaryPart or model:FindFirstChildWhichIsA('BasePart', true)

            if not part then
                return math.huge
            end

            return (part.Position - hrp.Position).Magnitude
        end

        local assets = currRoom:FindFirstChild('Assets')

        if assets then
            for _, v in pairs(assets:GetChildren())do
                if v:IsA('Model') then
                    if (((v.Name == 'Locker_Large') or (v.Name == 'Wardrobe') or (v.Name == 'Toolshed') or (v.Name == 'Bed') or (v.Name == 'Rooms_Locker') or (v.Name == 'Rooms_Locker_Fridge') or (v.Name == 'Backdoor_Wardrobe')) and v:FindFirstChild('HidePrompt') and v:FindFirstChild('HiddenPlayer')) then
                        if (not v.HiddenPlayer.Value and not v:FindFirstChild('HideEntityOnSpot', true)) then
                            if Closest then
                                if (distFromPlayer(v) < distFromPlayer(Closest)) then
                                    Closest = v
                                    Prompt = v.HidePrompt
                                end
                            else
                                Closest = v
                                Prompt = v.HidePrompt
                            end
                        end
                    elseif (v.Name == 'Double_Bed') then
                        for _, x in pairs(v:GetChildren())do
                            if ((x.Name == 'DoubleBed') and x:FindFirstChild('HidePrompt') and x:FindFirstChild('HiddenPlayer')) then
                                if (not x.HiddenPlayer.Value and not x:FindFirstChild('HideEntityOnSpot', true)) then
                                    if Closest then
                                        if (distFromPlayer(x) < distFromPlayer(Closest)) then
                                            Closest = x
                                            Prompt = x.HidePrompt
                                        end
                                    else
                                        Closest = x
                                        Prompt = x.HidePrompt
                                    end
                                end
                            end
                        end
                    elseif (v.Name == 'Dumpster') then
                        for _, x in pairs(v:GetChildren())do
                            if (x:FindFirstChild('HidePrompt') and x:FindFirstChild('HiddenPlayer')) then
                                local dumpsterBaseHasSpot = v:FindFirstChild('DumpsterBase') and v.DumpsterBase:FindFirstChild('HideEntityOnSpot')

                                if (not x.HiddenPlayer.Value and not dumpsterBaseHasSpot) then
                                    if Closest then
                                        if (distFromPlayer(x) < distFromPlayer(Closest)) then
                                            Closest = x
                                            Prompt = x.HidePrompt
                                        end
                                    else
                                        Closest = x
                                        Prompt = x.HidePrompt
                                    end
                                end
                            end
                        end
                    end
                elseif v:IsA('Folder') then
                    if (v.Name == 'Blockage') then
                        for _, x in pairs(v:GetChildren())do
                            if (x:IsA('Model') and (x.Name == 'Wardrobe') and x:FindFirstChild('HiddenPlayer') and x:FindFirstChild('HidePrompt')) then
                                if not x.HiddenPlayer.Value then
                                    if Closest then
                                        if (distFromPlayer(x) < distFromPlayer(Closest)) then
                                            Closest = x
                                            Prompt = x.HidePrompt
                                        end
                                    else
                                        Closest = x
                                        Prompt = x.HidePrompt
                                    end
                                end
                            end
                        end
                    elseif (v.Name == 'Vents') then
                        for _, x in pairs(v:GetChildren())do
                            if ((x.Name == 'CircularVent') and x:FindFirstChild('Grate') and x.Grate:FindFirstChild('HidePrompt') and x:FindFirstChild('HiddenPlayer')) then
                                if (not x.HiddenPlayer.Value and not v:FindFirstChild('HideEntityOnSpot', true)) then
                                    if Closest then
                                        if (distFromPlayer(x) < distFromPlayer(Closest)) then
                                            Closest = x
                                            Prompt = x.Grate.HidePrompt
                                        end
                                    else
                                        Closest = x
                                        Prompt = x.Grate.HidePrompt
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        for _, v in pairs(currRoom:GetChildren())do
            if v:IsA('Model') then
                if ((v.Name == 'CircularVent') and v:FindFirstChild('Grate') and v.Grate:FindFirstChild('HidePrompt') and v:FindFirstChild('HiddenPlayer')) then
                    if (not v.HiddenPlayer.Value and not v:FindFirstChild('HideEntityOnSpot', true)) then
                        if Closest then
                            if (distFromPlayer(v) < distFromPlayer(Closest)) then
                                Closest = v
                                Prompt = v.Grate.HidePrompt
                            end
                        else
                            Closest = v
                            Prompt = v.Grate.HidePrompt
                        end
                    end
                end
            end
        end

        return Prompt
    end

    CheatStuff:AddCheckbox('AutoHide', {
        Text = '自动隐藏V2',
        Default = false,
        Disabled = false,
        Risky = true,
        Tooltip = '给你藏起来了，你猜不出来吗',
        Callback = function(Value) end,
    })
    CheatStuff:AddDropdown('HidingType', {
        Text = '自动隐藏模式',
        Default = 'Safety',
        Multi = false,
        Values = {
            'Safety',
            'Close Call',
        },
        Callback = function(Value) end,
    })
    CheatStuff:AddSlider('PredictionTime', {
        Text = '预测时间',
        Default = 1.5,
        Min = 0.1,
        Max = 1.5,
        Rounding = 2,
        Compact = true,
        Suffix = 's',
        Callback = function(Value) end,
    })
    CheatStuff:AddSlider('DistanceMultiplier', {
        Text = '距离倍率',
        Default = 1,
        Min = 1,
        Max = 1.5,
        Rounding = 1,
        Compact = true,
        Suffix = 'x',
        Callback = function(Value) end,
    })
    task.spawn(function()
        local Connections = {}

        table.insert(Connections, workspace.ChildAdded:Connect(function(v)
            if (v:IsA('Model') and EntityDistances[v.Name]) then
                task.wait(1)

                local Part = v.PrimaryPart or v:FindFirstChildWhichIsA('BasePart', true)

                if not Part then
                    return
                end

                v:SetAttribute('_Prediction', Part.Position)

                while task.wait() and v.Parent do
                    task.spawn(function()
                        local LastPosition = Part.Position

                        task.wait(0.3333333333333333)

                        if (Part and Part.Parent) then
                            v:SetAttribute('_Prediction', Part.Position - LastPosition)
                        end
                    end)

                    if (Toggles and Toggles.AutoHide and Toggles.AutoHide.Value) then
                        local IncludeList = {}

                        for _, Room in pairs(Rooms:GetChildren())do
                            if Room:FindFirstChild('Assets') then
                                table.insert(IncludeList, Room.Assets)
                            end
                            if Room:FindFirstChild('Parts') then
                                table.insert(IncludeList, Room.Parts)
                            end
                        end

                        local RaycastParams = RaycastParams.new()

                        RaycastParams.FilterDescendantsInstances = IncludeList
                        RaycastParams.FilterType = Enum.RaycastFilterType.Include

                        local Count = {
                            0.2,
                            0.4,
                            0.6,
                            0.8,
                            1,
                        }
                        local entityInRange = false

                        for i = 1, #Count do
                            local Number = (Options and Options.PredictionTime and Options.PredictionTime.Value) or 0.5

                            Number = Number * Count[i]

                            local predAttr = v:GetAttribute('_Prediction')
                            local Prediction = (predAttr and (predAttr * 3)) or Vector3.new(0, 0, 0)

                            Prediction = Prediction * Number

                            local char = LocalPlayer.Character

                            if not char then
                                break
                            end

                            local hrp = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Collision') or char.PrimaryPart

                            if not hrp then
                                break
                            end
                            if (Vector3.new(Prediction.X, 0, Prediction.Z).Magnitude > 1) then
                                local PredictionPosition = Part.Position + Prediction
                                local Raycast

                                if (Toggles.GA_AutoHide_VisCheck and Toggles.GA_AutoHide_VisCheck.Value) then
                                    Raycast = workspace:Raycast(hrp.Position, PredictionPosition - hrp.Position, RaycastParams)
                                end

                                local distMultiplier = (Options and Options.DistanceMultiplier and Options.DistanceMultiplier.Value) or 1
                                local mode = (Options and Options.HidingType and Options.HidingType.Value) or 'Safety'
                                local adjust = 0

                                if (mode == 'Safety') then
                                    adjust = 20
                                elseif (mode == 'Close Call') then
                                    adjust = -20
                                end

                                local adjustedDistance = EntityDistances[v.Name] + adjust
                                local distanceToEntity = (PredictionPosition - hrp.Position).Magnitude

                                if (not Raycast and (distanceToEntity <= (adjustedDistance * distMultiplier))) then
                                    entityInRange = true

                                    local Prompt = GetHiding()

                                    if Prompt then
                                        pcall(function()
                                            fireproximityprompt(Prompt)
                                        end)
                                    end

                                    break
                                end
                            end
                        end

                        local char = LocalPlayer.Character

                        if (char and not entityInRange and char:GetAttribute('Hiding')) then
                            char:SetAttribute('Hiding', false)
                        end
                    end
                end
            end
        end))
    end)
    CheatStuff:AddDivider()
    CheatStuff:AddCheckbox('NoCutscenes', {
        Text = '跳过剧情',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local player = game:GetService('Players').LocalPlayer
            local RemoteListener = player.PlayerGui.MainUI.Initiator.Main_Game:WaitForChild('RemoteListener')
            local CutScenes = RemoteListener:FindFirstChild('Cutscenes') or RemoteListener:FindFirstChild('_Cutscenes')

            if not CutScenes then
                CutScenes = RemoteListener:WaitForChild('Cutscenes', 3) or RemoteListener:WaitForChild('_Cutscenes', 3)
            end
            if CutScenes then
                CutScenes.Name = (Value and '_Cutscenes') or 'Cutscenes'
            end
        end,
    })
    CheatStuff:AddDivider()
    CheatStuff:AddCheckbox('InfCrucifix', {
        Text = '无限十字架',
        Default = false,
        Disabled = false,
        Risky = true,
        Callback = function(Value)
            local Replicated = game:GetService('ReplicatedStorage')
            local RemoteFolder = Replicated:FindFirstChild('EntityInfo') or Replicated:FindFirstChild('RemotesFolder') or Replicated:FindFirstChild('Bricks')

            if not RemoteFolder then
                return
            end

            local DropItem = RemoteFolder:FindFirstChild('DropItem')

            if not DropItem then
                return
            end

            local player = game.Players.LocalPlayer
            local Run = game:GetService('RunService')
            local rayparams = RaycastParams.new()

            rayparams.FilterType = Enum.RaycastFilterType.Exclude
            rayparams.FilterDescendantsInstances = {
                player.Character,
                workspace.CurrentRooms,
            }

            local distances = {
                RushMoving = 54,
                AmbushMoving = 67,
                A60 = 70,
            }
            local conn
            local lastCheck = 0

            local function findCrucifixTool()
                local c = player.Character

                if c then
                    for _, child in ipairs(c:GetChildren())do
                        if (child:IsA('Tool') and child.Name:lower():find('crucifix', 1, true)) then
                            return child
                        end
                    end
                end

                for _, child in ipairs(player.Backpack:GetChildren())do
                    if (child:IsA('Tool') and child.Name:lower():find('crucifix', 1, true)) then
                        return child
                    end
                end

                return nil
            end
            local function fireInteract(p)
                if not p then
                    return
                end

                pcall(fireproximityprompt, p)
            end

            if not Value then
                if conn then
                    conn:Disconnect()

                    conn = nil
                end

                return
            end

            conn = Run.Heartbeat:Connect(function(dt)
                if not Value then
                    return
                end

                lastCheck = lastCheck + dt

                if (lastCheck < 0.2) then
                    return
                end

                lastCheck = 0

                local char = player.Character
                local root = char and (char:FindFirstChild('CollisionPart') or char:FindFirstChild('HumanoidRootPart'))

                if not root then
                    return
                end

                for _, v in ipairs(workspace:GetChildren())do
                    local d = distances[v.Name]

                    if (d and v.PrimaryPart) then
                        local pt = root.Position
                        local dir = v.PrimaryPart.Position - pt
                        local hit = workspace:Raycast(pt, dir, rayparams)

                        if (hit and hit.Instance:IsDescendantOf(v)) then
                            if ((pt - v.PrimaryPart.Position).Magnitude < d) then
                                local tool = findCrucifixTool()

                                if tool then
                                    DropItem:FireServer(tool)
                                    task.defer(function()
                                        task.wait(0.54)

                                        local drops = workspace:FindFirstChild('Drops')

                                        if (drops and drops:FindFirstChild('Crucifix')) then
                                            local p = drops.Crucifix:FindFirstChildOfClass('ProximityPrompt')

                                            if p then
                                                fireInteract(p)
                                            end
                                        end
                                    end)
                                end
                            end
                        end
                    end
                end
            end)
        end,
    })
    CheatStuff:AddCheckbox('InfItems', {
        Text = '无限物品',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local Replicated = game:GetService('ReplicatedStorage')
            local RemoteFolder = Replicated:FindFirstChild('EntityInfo') or Replicated:FindFirstChild('RemotesFolder') or Replicated:FindFirstChild('Bricks')

            if not RemoteFolder then
                return
            end

            local DropItem = RemoteFolder:FindFirstChild('DropItem')

            if not DropItem then
                return
            end

            local player = game.Players.LocalPlayer
            local Run = game:GetService('RunService')
            local roomFolder = workspace:FindFirstChild('CurrentRooms')

            if not roomFolder then
                return
            end

            local function fireInteract(p)
                if p then
                    pcall(fireproximityprompt, p)
                end
            end
            local function findToolByName(search)
                search = search:lower()

                local c = player.Character

                if c then
                    for _, child in ipairs(c:GetChildren())do
                        if (child:IsA('Tool') and child.Name:lower():find(search, 1, true)) then
                            return child
                        end
                    end
                end

                for _, child in ipairs(player.Backpack:GetChildren())do
                    if (child:IsA('Tool') and child.Name:lower():find(search, 1, true)) then
                        return child
                    end
                end

                return nil
            end
            local function addFake(O, aK)
                if (not O or not O:IsA('ProximityPrompt') or O:GetAttribute('HasFake')) then
                    return
                end

                O:SetAttribute('HasFake', true)

                local aL = O:Clone()

                aL.Name = 'FakePrompt'
                aL.Parent = O.Parent
                aL.Enabled = true
                aL.ClickablePrompt = true
                O.Enabled = false
                O.ClickablePrompt = false

                aL.Triggered:Connect(function()
                    local toolSearch = aK:lower()
                    local toolInst = findToolByName(toolSearch)

                    if not toolInst then
                        return
                    end

                    DropItem:FireServer(toolInst)

                    local con
                    local timedOut = false

                    task.delay(1, function()
                        timedOut = true
                    end)

                    con = workspace.Drops.ChildAdded:Connect(function(v)
                        if timedOut then
                            con:Disconnect()

                            return
                        end

                        local newPrompt = v:FindFirstChildOfClass('ProximityPrompt')

                        if newPrompt then
                            if (aK == 'Lockpick') then
                                fireInteract(newPrompt)
                                fireInteract(O)
                            elseif (aK == 'Shears') then
                                fireInteract(O)
                                fireInteract(newPrompt)
                            else
                                fireInteract(newPrompt)
                                fireInteract(O)
                            end

                            task.wait(0.25)
                            con:Disconnect()
                        end
                    end)
                end)
            end
            local function scanPrompts(parentsMap, namesMap)
                local found = {}

                for _, v in ipairs(roomFolder:GetDescendants())do
                    if (v:IsA('ProximityPrompt') and (parentsMap[v.Parent.Name] or namesMap[v.Name])) then
                        table.insert(found, v)
                    end
                end

                return found
            end
            local function cleanupEnableReal()
                for _, v in ipairs(roomFolder:GetDescendants())do
                    if ((v.Name == 'FakePrompt') and v.Parent) then
                        v:Destroy()
                    elseif (v:IsA('ProximityPrompt') and (v.Name ~= 'FakePrompt')) then
                        pcall(function()
                            v.Enabled = true
                            v.ClickablePrompt = true

                            if (v:GetAttribute('HasFake') == true) then
                                v:SetAttribute('HasFake', nil)
                            end
                        end)
                    end
                end
            end

            local LockpickParents = {
                ChestBoxLocked = true,
                Locker_Small_Locked = true,
                Toolbox_Locked = true,
            }
            local LockpickNames = {
                UnlockPrompt = true,
                ThingToEnable = true,
                LockPrompt = true,
                SkullPrompt = true,
                FusesPrompt = true,
            }
            local ShearsParents = {
                Chest_Vine = true,
                CuttableVines = true,
                Cellar = true,
            }
            local ShearsNames = {SkullPrompt = true}
            local KeyParents = {
                Keyhole = true,
                LockedDoor = true,
            }
            local KeyNames = {KeyPrompt = true}
            local CrowbarParents = {
                SealedCrate = true,
                Boarded = true,
            }
            local CrowbarNames = {PryPrompt = true}
            local InfStore, InfSStore, InfKStore, InfCStore = {}, {}, {}, {}
            local attachConn, roomConn, lastCheck = nil, nil, 0

            if not Value then
                cleanupEnableReal()

                InfStore, InfSStore, InfKStore, InfCStore = {}, {}, {}, {}

                if attachConn then
                    attachConn:Disconnect()

                    attachConn = nil
                end
                if roomConn then
                    roomConn:Disconnect()

                    roomConn = nil
                end

                return
            end

            local function tryAttachAll()
                local char = player.Character

                if not char then
                    return
                end

                local function attachIfHas(toolName, store)
                    local hasTool = char:FindFirstChild(toolName) or player.Backpack:FindFirstChild(toolName)

                    if hasTool then
                        for _, prompt in ipairs(store)do
                            if (prompt and prompt.Parent and not prompt:GetAttribute('HasFake')) then
                                addFake(prompt, toolName)
                            end
                        end
                    end
                end

                attachIfHas('Lockpick', InfStore)
                attachIfHas('Shears', InfSStore)
                attachIfHas('Key', InfKStore)
                attachIfHas('Crowbar', InfCStore)
            end
            local function rescanAll()
                InfStore = scanPrompts(LockpickParents, LockpickNames)
                InfSStore = scanPrompts(ShearsParents, ShearsNames)
                InfKStore = scanPrompts(KeyParents, KeyNames)
                InfCStore = scanPrompts(CrowbarParents, CrowbarNames)

                tryAttachAll()
            end

            rescanAll()

            roomConn = roomFolder.ChildAdded:Connect(rescanAll)
            attachConn = Run.Heartbeat:Connect(function(dt)
                if not Value then
                    return
                end

                lastCheck = lastCheck + dt

                if (lastCheck < 0.2) then
                    return
                end

                lastCheck = 0

                tryAttachAll()
            end)

            local function hookChildChanges(container)
                container.ChildAdded:Connect(function(child)
                    local name = child.Name:lower()

                    if (name:find('lockpick', 1, true) or name:find('skeleton', 1, true)) then
                        InfStore = scanPrompts(LockpickParents, LockpickNames)

                        tryAttachAll()
                    elseif name:find('shears', 1, true) then
                        InfSStore = scanPrompts(ShearsParents, ShearsNames)

                        tryAttachAll()
                    elseif name:find('key', 1, true) then
                        InfKStore = scanPrompts(KeyParents, KeyNames)

                        tryAttachAll()
                    elseif name:find('crowbar', 1, true) then
                        InfCStore = scanPrompts(CrowbarParents, CrowbarNames)

                        tryAttachAll()
                    end
                end)
                container.ChildRemoved:Connect(function(child)
                    local name = child.Name:lower()

                    if (name:find('lockpick', 1, true) or name:find('skeleton', 1, true)) then
                        InfStore = scanPrompts(LockpickParents, LockpickNames)

                        tryAttachAll()
                    elseif name:find('shears', 1, true) then
                        InfSStore = scanPrompts(ShearsParents, ShearsNames)

                        tryAttachAll()
                    elseif name:find('key', 1, true) then
                        InfKStore = scanPrompts(KeyParents, KeyNames)

                        tryAttachAll()
                    elseif name:find('crowbar', 1, true) then
                        InfCStore = scanPrompts(CrowbarParents, CrowbarNames)

                        tryAttachAll()
                    end
                end)
            end

            player.CharacterAdded:Connect(function(char)
                hookChildChanges(char)
            end)
            hookChildChanges(player.Backpack)
        end,
    })
    CheatStuff:AddDivider()

    local doorReachLoop

    CheatStuff:AddCheckbox('DoorReach', {
        Text = '开门距离',
        Default = false,
        Disabled = false,
        Tooltip = '增加车门可达开度',
        Callback = function(Value)
            if Value then
                local Rooms = workspace:FindFirstChild('CurrentRooms')

                if not Rooms then
                    return
                end

                doorReachLoop = task.spawn(function()
                    while Toggles.DoorReach and Toggles.DoorReach.Value do
                        for _, room in pairs(Rooms:GetChildren())do
                            local door = room:FindFirstChild('Door')

                            if (door and door:FindFirstChild('ClientOpen')) then
                                door.ClientOpen:FireServer()
                            end
                        end

                        task.wait(0.5)
                    end
                end)
            else
                doorReachLoop = nil
            end
        end,
    })
    CheatStuff:AddCheckbox('AutoMinecartPush', {
        Text = '自动推矿车',
        Default = false,
        Disabled = false,
        Tooltip = '增加车门可达开度',
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local LocalPlayer = Players.LocalPlayer
            local Workspace = game:GetService('Workspace')
            local Rooms = Workspace:WaitForChild('CurrentRooms')

            if _G.AutoMinecartConn then
                _G.AutoMinecartConn:Disconnect()

                _G.AutoMinecartConn = nil
            end
            if _G.AutoMinecartLoop then
                _G.AutoMinecartLoop:Disconnect()

                _G.AutoMinecartLoop = nil
            end
            if Value then
                local function tryPush(cartModel)
                    local cart = cartModel:FindFirstChild('Cart')

                    if not cart then
                        return
                    end

                    local prompt = cart:FindFirstChild('PushPrompt')

                    if not prompt then
                        return
                    end

                    local character = LocalPlayer.Character
                    local root = character and character:FindFirstChild('HumanoidRootPart')

                    if not root then
                        return
                    end
                    if ((root.Position - prompt.Parent.Position).Magnitude <= (prompt.MaxActivationDistance or 10)) then
                        fireproximityprompt(prompt)
                    end
                end

                _G.AutoMinecartConn = Rooms.DescendantAdded:Connect(function(obj)
                    if (obj.Name == 'MinecartMoving') then
                        task.defer(function()
                            tryPush(obj)
                        end)
                    end
                end)
                _G.AutoMinecartLoop = RunService.Heartbeat:Connect(function()
                    local character = LocalPlayer.Character
                    local root = character and character:FindFirstChild('HumanoidRootPart')

                    if not root then
                        return
                    end

                    for _, obj in ipairs(Rooms:GetDescendants())do
                        if (obj.Name == 'MinecartMoving') then
                            tryPush(obj)
                        end
                    end
                end)
            else
                if _G.AutoMinecartConn then
                    _G.AutoMinecartConn:Disconnect()
                end
                if _G.AutoMinecartLoop then
                    _G.AutoMinecartLoop:Disconnect()
                end

                _G.AutoMinecartConn = nil
                _G.AutoMinecartLoop = nil
            end
        end,
    })
    CheatStuff:AddCheckbox('InstantInteract', {
        Text = '即时交互',
        Default = false,
        Disabled = false,
        Tooltip = '删除接近提示的小等待时间',
        Callback = function(Value)
            if getgenv().ProximityConnection then
                getgenv().ProximityConnection:Disconnect()

                getgenv().ProximityConnection = nil
            end

            local function modifyPrompt(prompt, instant)
                if not prompt:IsA('ProximityPrompt') then
                    return
                end
                if instant then
                    if not prompt:GetAttribute('OriginalHoldDuration') then
                        prompt:SetAttribute('OriginalHoldDuration', prompt.HoldDuration)
                        prompt:SetAttribute('OriginalLineOfSight', prompt.RequiresLineOfSight)
                    end

                    prompt.HoldDuration = 0
                    prompt.RequiresLineOfSight = false
                else
                    prompt.HoldDuration = prompt:GetAttribute('OriginalHoldDuration') or 1
                    prompt.RequiresLineOfSight = prompt:GetAttribute('OriginalLineOfSight') or true
                end
            end

            local currentRooms = workspace:FindFirstChild('CurrentRooms')

            if currentRooms then
                for _, prompt in ipairs(currentRooms:GetDescendants())do
                    if prompt:IsA('ProximityPrompt') then
                        modifyPrompt(prompt, Value)
                    end
                end
            end
            if (Value and currentRooms) then
                getgenv().ProximityConnection = currentRooms.DescendantAdded:Connect(function(descendant)
                    if descendant:IsA('ProximityPrompt') then
                        modifyPrompt(descendant, true)
                    end
                end)
            end
        end,
    })
    CheatStuff:AddCheckbox('AutoInteract', {
        Text = '自动交互',
        Default = false,
        Risky = false,
        Disabled = false,
        Callback = function(Value)
            if Value then
                local RunService = game:GetService('RunService')
                local LocalPlayer = game.Players.LocalPlayer

                AutoInteractDistance = AutoInteractDistance or 10

                local AutoInteractConnection
                local CachedInteractables = {}
                local PromptSeen = {}
                local InteractableModels = {
                    AlarmClock = true,
                    GlitchCub = true,
                    Aloe = true,
                    BandagePack = true,
                    Battery = true,
                    TimerLever = true,
                    OuterPart = true,
                    BatteryPack = true,
                    Candle = true,
                    LiveBreakerPolePickup = true,
                    Compass = true,
                    Crucifix = true,
                    ElectricalRoomKey = true,
                    Flashlight = true,
                    Glowstick = true,
                    HolyHandGrenade = true,
                    Lantern = true,
                    LaserPointer = true,
                    Lighter = true,
                    Lockpick = true,
                    LotusFlower = true,
                    LotusPetalPickup = true,
                    Multitool = true,
                    NVCS3000 = true,
                    OutdoorsKey = true,
                    Shears = true,
                    SkeletonKey = true,
                    Smoothie = true,
                    SolutionPaper = true,
                    Spotlight = true,
                    StarlightVial = true,
                    StarlightJug = true,
                    StarlightBottle = true,
                    Vitamins = true,
                }

                local function PickRootPart(obj, prompt)
                    if (prompt and prompt.Parent and prompt.Parent:IsA('BasePart')) then
                        return prompt.Parent
                    end
                    if obj:IsA('Model') then
                        if (obj.PrimaryPart and obj.PrimaryPart:IsA('BasePart')) then
                            return obj.PrimaryPart
                        end

                        local common = obj:FindFirstChild('Main', true) or obj:FindFirstChild('Handle', true) or obj:FindFirstChild('Door', true)

                        if (common and common:IsA('BasePart')) then
                            return common
                        end
                    end

                    return obj:FindFirstChildWhichIsA('BasePart', true)
                end
                local function AddPromptsFromObject(obj)
                    for _, desc in ipairs(obj:GetDescendants())do
                        if (desc:IsA('ProximityPrompt') and not PromptSeen[desc]) then
                            local root = PickRootPart(obj, desc)

                            if root then
                                PromptSeen[desc] = true

                                table.insert(CachedInteractables, {
                                    prompt = desc,
                                    part = root,
                                    last = 0,
                                })
                            end
                        end
                    end
                end
                local function CollectTargets(folder)
                    for _, v in ipairs(folder:GetChildren())do
                        if (v:IsA('Model') or v:IsA('Folder')) then
                            if ((v.Name == 'DrawerContainer') or InteractableModels[v.Name] or (v.Name == 'RoomsLootItem') or (v.Name == 'Locker_Small') or (v.Name == 'Toolbox') or (v.Name == 'ChestBox') or (v.Name == 'Toolshed_Small') or (v.Name == 'CrucifixOnTheWall')) then
                                AddPromptsFromObject(v)
                            end

                            CollectTargets(v)
                        end
                    end
                end
                local function RefreshTargets()
                    CachedInteractables = {}
                    PromptSeen = {}

                    local CurrentRoom = workspace.CurrentRooms[LocalPlayer:GetAttribute('CurrentRoom')]

                    if not CurrentRoom then
                        return
                    end

                    CollectTargets(CurrentRoom)
                end

                local lastCheck = 0
                local interval = 0.2

                local function AutoInteractStep(dt)
                    lastCheck = lastCheck + dt

                    if (lastCheck < interval) then
                        return
                    end

                    lastCheck = 0

                    if (not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('Collision')) then
                        return
                    end

                    local charPos = LocalPlayer.Character.Collision.Position
                    local now = tick()

                    for i = #CachedInteractables, 1, -1 do
                        local entry = CachedInteractables[i]
                        local prompt, part = entry.prompt, entry.part

                        if (not prompt or not prompt.Parent or not part or not part:IsDescendantOf(workspace)) then
                            table.remove(CachedInteractables, i)
                        else
                            local dist = (part.Position - charPos).Magnitude

                            if ((dist <= AutoInteractDistance) and ((now - (entry.last or 0)) >= 0.35)) then
                                entry.last = now

                                task.spawn(function()
                                    pcall(function()
                                        fireproximityprompt(prompt)
                                    end)
                                end)
                            end
                        end
                    end
                end

                RefreshTargets()

                AutoInteractConnection = RunService.Heartbeat:Connect(AutoInteractStep)

                local attributeConn
                local roomDescConn

                attributeConn = LocalPlayer:GetAttributeChangedSignal('CurrentRoom'):Connect(function()
                    RefreshTargets()

                    if roomDescConn then
                        roomDescConn:Disconnect()

                        roomDescConn = nil
                    end

                    local cr = workspace.CurrentRooms[LocalPlayer:GetAttribute('CurrentRoom')]

                    if cr then
                        roomDescConn = cr.DescendantAdded:Connect(function()
                            task.defer(RefreshTargets)
                        end)
                    end
                end)

                local cr = workspace.CurrentRooms[LocalPlayer:GetAttribute('CurrentRoom')]

                if cr then
                    roomDescConn = cr.DescendantAdded:Connect(function()
                        task.defer(RefreshTargets)
                    end)
                end

                _G.StopAutoInteract = function()
                    if AutoInteractConnection then
                        AutoInteractConnection:Disconnect()

                        AutoInteractConnection = nil
                    end
                    if attributeConn then
                        attributeConn:Disconnect()

                        attributeConn = nil
                    end
                    if roomDescConn then
                        roomDescConn:Disconnect()

                        roomDescConn = nil
                    end

                    CachedInteractables, PromptSeen = {}, {}
                end
            elseif _G.StopAutoInteract then
                _G.StopAutoInteract()

                _G.StopAutoInteract = nil
            end
        end,
    })
    CheatStuff:AddSlider('AutoInteractDistance', {
        Text = '自动交互距离',
        Default = 10,
        Min = 1,
        Max = 2,
        Rounding = 1,
        Compact = true,
        Suffix = ' studs',
        Callback = function(Value)
            AutoInteractDistance = Value
        end,
    })
    CheatStuff:AddSlider('RangeBoost', {
        Text = '交互强化',
        Default = 1,
        Min = 1,
        Max = 2,
        Rounding = 1,
        Compact = true,
        Callback = function(multiplier)
            if (multiplier == 1) then
                for prompt, originalRange in pairs(originalRanges)do
                    if (prompt and prompt.Parent) then
                        prompt.MaxActivationDistance = originalRange
                    end
                end
                for _, connection in pairs(rangeConnections)do
                    connection:Disconnect()
                end

                rangeConnections = {}
            else
                updateProximityPromptRanges(multiplier)
                setupRangeConnections(multiplier)
            end
        end,
    })

    local RandomStuff = Tabs.Misc:AddLeftGroupbox('The Hotel')

    RandomStuff:AddCheckbox('AntiJam', {
        Text = '防卡死',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if (Modifiers and not Modifiers:FindFirstChild('Jammin')) then
                return
            end

            local mainTrack = game['SoundService']:FindFirstChild('Main')

            if mainTrack then
                local jamming = mainTrack:FindFirstChild('Jamming')

                if jamming then
                    jamming.Enabled = not Value
                end
            end

            local mainUI = LocalPlayer:FindFirstChild('PlayerGui') and LocalPlayer.PlayerGui:FindFirstChild('MainUI')

            if mainUI then
                local healthGui = mainUI:FindFirstChild('Initiator') and mainUI.Initiator:FindFirstChild('Main_Game') and mainUI.Initiator.Main_Game:FindFirstChild('Health')

                if healthGui then
                    local jamSound = healthGui:FindFirstChild('Jam')

                    if jamSound then
                        jamSound.Playing = not Value
                    end
                end
            end
        end,
    })

    local clones = {}
    local bridgeConns = {}

    local function makeBarrier(barrier)
        if barrier.Parent:FindFirstChild('AntiBridge') then
            return
        end

        local clone = barrier:Clone()

        clone.Name = 'AntiBridge'
        clone.Size = Vector3.new(barrier.Size.X, barrier.Size.Y, 30)
        clone.Color = Color3.new(0, 0, 0.5)
        clone.CFrame = barrier.CFrame * CFrame.new(0, 0, -5)
        clone.Transparency = 0
        clone.Anchored = true
        clone.CanCollide = true
        clone.CanTouch = true
        clone.Parent = barrier.Parent

        table.insert(clones, clone)
    end
    local function processBridge(bridge)
        if bridge:FindFirstChild('AntiBridge') then
            return
        end

        for _, part in ipairs(bridge:GetChildren())do
            if ((part.Name == 'PlayerBarrier') and (part.Size.Y == 2.75) and ((part.Rotation.X % 180) == 0)) then
                makeBarrier(part)
            end
        end

        local conn = bridge.ChildAdded:Connect(function(c)
            if (c.Name == 'PlayerBarrier') then
                makeBarrier(c)
            end
        end)

        table.insert(bridgeConns, conn)
    end

    local clones = {}
    local bridgeConns = {}

    local function makeBarrier(barrier)
        if barrier.Parent:FindFirstChild('AntiBridge') then
            return
        end

        local clone = barrier:Clone()

        clone.Name = 'AntiBridge'
        clone.Size = Vector3.new(barrier.Size.X, barrier.Size.Y, 30)
        clone.Color = Color3.new(0, 0, 0.5)
        clone.CFrame = barrier.CFrame * CFrame.new(0, 0, -5)
        clone.Transparency = 0
        clone.Anchored = true
        clone.CanCollide = true
        clone.CanTouch = true
        clone.Parent = barrier.Parent

        table.insert(clones, clone)
    end
    local function processBridge(bridge)
        if bridge:FindFirstChild('AntiBridge') then
            return
        end

        for _, part in ipairs(bridge:GetChildren())do
            if ((part.Name == 'PlayerBarrier') and (part.Size.Y == 2.75) and ((part.Rotation.X % 180) == 0)) then
                makeBarrier(part)
            end
        end

        local conn = bridge.ChildAdded:Connect(function(c)
            if (c.Name == 'PlayerBarrier') then
                makeBarrier(c)
            end
        end)

        table.insert(bridgeConns, conn)
    end

    RandomStuff:AddDivider()
    RandomStuff:AddButton({
        Text = '死亡农场V2',
        Disabled = false,
        Func = function()
            if not (replicatesignal or queue_on_teleport) then
                Library:Notify([[Your exec does not support replicatesignal or queue_on_teleport.]], 4)

                return
            end

            local Players = game:GetService('Players')
            local ReplicatedStorage = game:GetService('ReplicatedStorage')
            local lp = Players.LocalPlayer

            if not lp then
                Library:Notify('LocalPlayer not found.', 4)

                return
            end

            local REPEAT_DELAY = 1
            local stopFlag = false

            local function tryFirePlayAgain()
                pcall(function()
                    if (ReplicatedStorage and ReplicatedStorage:FindFirstChild('RemotesFolder')) then
                        local rf = ReplicatedStorage.RemotesFolder

                        if (rf and rf:FindFirstChild('PlayAgain') and (type(rf.PlayAgain.FireServer) == 'function')) then
                            rf.PlayAgain:FireServer()
                            Library:Notify('PlayAgaiNNNNNNNNNNNNNNNNNNNN', 2)
                        end
                    end
                end)
            end
            local function runPayload(fireAfter)
                local ok, err = pcall(function()
                    loadstring(game:HttpGet([[https://raw.githubusercontent.com/TheHunterSolo1/Op-Ninja-Simulator-/Main/M1reset]]))()
                end)

                if not ok then
                    Library:Notify('Death Farm exec failed: ' .. tostring(err), 4)

                    return
                end
                if fireAfter then
                    task.delay(4, tryFirePlayAgain)
                end
            end

            task.spawn(function()
                while not stopFlag and lp and lp.Parent do
                    runPayload(false)
                    task.wait(REPEAT_DELAY)
                end
            end)
            runPayload(false)

            local charConn, humanoidConn

            local function onCharacterAdded(char)
                if (humanoidConn and humanoidConn.Disconnect) then
                    humanoidConn:Disconnect()

                    humanoidConn = nil
                end

                local humanoid = char:FindFirstChildOfClass('Humanoid')

                if not humanoid then
                    humanoidConn = char.ChildAdded:Connect(function(child)
                        if child:IsA('Humanoid') then
                            if humanoidConn then
                                humanoidConn:Disconnect()
                            end

                            humanoid = child

                            humanoid.Died:Connect(function()
                                pcall(function()
                                    runPayload(true)
                                end)
                            end)
                        end
                    end)
                else
                    humanoid.Died:Connect(function()
                        pcall(function()
                            runPayload(true)
                        end)
                    end)
                end
            end

            if lp.Character then
                onCharacterAdded(lp.Character)
            end

            charConn = lp.CharacterAdded:Connect(onCharacterAdded)

            if queue_on_teleport then
                pcall(function()
                    queue_on_teleport([[loadstring(game:HttpGet("https://raw.githubusercontent.com/TheHunterSolo1/Op-Ninja-Simulator-/Main/M1reset"))()]])
                end)
            end

            Library:Notify('Death Farm started', 10)
        end,
    })
    RandomStuff:AddButton({
        Text = 'knob农场',
        Disabled = true,
        Func = function()
            if getgenv().AutoKnobWrapperStarted then
                print('AutoKnob already running.')

                return
            end

            getgenv().AutoKnobWrapperStarted = true

            local Players = game:GetService('Players')
            local ReplicatedStorage = game:GetService('ReplicatedStorage')
            local RunService = game:GetService('RunService')
            local lp = Players.LocalPlayer

            if not lp then
                print('LocalPlayer not found.')

                return
            end

            local KNOBS_URL = [[https://raw.githubusercontent.com/DasVelocity/knobfarm/refs/heads/main/knobs.lua]]
            local PLAYAGAIN_DEBOUNCE = 2
            local HEARTBEAT_CHECK = true
            local lastPlayAgain = 0
            local isFiring = false

            local function tryFirePlayAgain()
                local now = tick()

                if ((now - lastPlayAgain) < PLAYAGAIN_DEBOUNCE) then
                    return
                end
                if isFiring then
                    return
                end

                isFiring = true
                lastPlayAgain = now

                pcall(function()
                    local rf = ReplicatedStorage:FindFirstChild('RemotesFolder')

                    if not rf then
                        return
                    end

                    local playAgain = rf:FindFirstChild('PlayAgain')

                    if (playAgain and (type(playAgain.FireServer) == 'function')) then
                        playAgain:FireServer()
                    end
                end)
                task.delay(0.5, function()
                    isFiring = false
                end)
            end

            local knobsLoaded = false

            local function runKnobsOnce()
                if knobsLoaded then
                    return true
                end

                local ok, err = pcall(function()
                    local source = game:HttpGet(KNOBS_URL)
                    local chunk = (loadstring or load)(source)

                    if not chunk then
                        error('load failed')
                    end

                    chunk()
                end)

                if ok then
                    knobsLoaded = true

                    print('AutoKnob started.')

                    return true
                else
                    warn('Failed to load AutoKnob: ' .. tostring(err))

                    return false
                end
            end
            local function queueOnTeleportIfSupported()
                local qfn = queue_on_teleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport)

                if not qfn then
                    print('Your executor does not support queue_on_teleport.')

                    return false
                end

                pcall(function()
                    qfn('loadstring(game:HttpGet("' .. KNOBS_URL .. '"))()')
                end)

                return true
            end

            local charConn, humanoidConn, heartbeatConn

            local function cleanupConns()
                if (humanoidConn and humanoidConn.Disconnect) then
                    humanoidConn:Disconnect()

                    humanoidConn = nil
                end
                if (charConn and charConn.Disconnect) then
                    charConn:Disconnect()

                    charConn = nil
                end
                if (heartbeatConn and heartbeatConn.Disconnect) then
                    heartbeatConn:Disconnect()

                    heartbeatConn = nil
                end
            end
            local function onHumanoid(humanoid)
                if not humanoid then
                    return
                end
                if (humanoidConn and humanoidConn.Disconnect) then
                    humanoidConn:Disconnect()

                    humanoidConn = nil
                end

                humanoidConn = humanoid.Died:Connect(function()
                    tryFirePlayAgain()
                    task.delay(0.6, runKnobsOnce)
                end)

                if HEARTBEAT_CHECK then
                    if (heartbeatConn and heartbeatConn.Disconnect) then
                        heartbeatConn:Disconnect()

                        heartbeatConn = nil
                    end

                    heartbeatConn = RunService.Heartbeat:Connect(function()
                        if (humanoid and humanoid.Parent and (humanoid.Health <= 0)) then
                            tryFirePlayAgain()
                            task.delay(0.6, runKnobsOnce)
                        end
                    end)
                end
            end
            local function onCharacterAdded(char)
                task.wait(0.4)
                pcall(function()
                    local humanoid = char:FindFirstChildOfClass('Humanoid')

                    if humanoid then
                        onHumanoid(humanoid)
                    else
                        local cconn

                        cconn = char.ChildAdded:Connect(function(child)
                            if child:IsA('Humanoid') then
                                if cconn then
                                    cconn:Disconnect()
                                end

                                onHumanoid(child)
                            end
                        end)
                    end
                end)
            end

            pcall(queueOnTeleportIfSupported)
            runKnobsOnce()

            if (charConn and charConn.Disconnect) then
                charConn:Disconnect()

                charConn = nil
            end

            charConn = lp.CharacterAdded:Connect(onCharacterAdded)

            if lp.Character then
                task.spawn(function()
                    onCharacterAdded(lp.Character)
                end)
            end

            task.spawn(function()
                while lp and lp.Parent do
                    task.wait(5)
                end

                cleanupConns()
            end)
        end,
    })

    local SeekGroup = Tabs.Misc:AddLeftGroupbox('Seek')

    SeekGroup:AddCheckbox('AntiFLood', {
        Text = '防sekk洪水伤害',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if Value then
                local runService = game:GetService('RunService')
                local found = false
                local connection

                connection = runService.Heartbeat:Connect(function()
                    if not Value then
                        if connection then
                            connection:Disconnect()
                        end

                        return
                    end
                    if not found then
                        for _, descendant in ipairs(workspace:GetDescendants())do
                            if ((descendant.Name == 'SeekFloodline') and descendant:IsA('BasePart')) then
                                descendant.CanCollide = true
                                found = true

                                Library:Notify('It\u{2019}s safe to walk on the seek ocean thingy', 3)

                                break
                            end
                        end
                    end
                end)
            end
        end,
    })
    SeekGroup:AddCheckbox('SeekBridgeCover', {
        Text = '反seek桥破损',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            if Value then
                local RunService = game:GetService('RunService')
                local Players = game:GetService('Players')
                local Workspace = game:GetService('Workspace')
                local MODEL_NAME = 'Bridge'
                local SCAN_INTERVAL = 1
                local DEFAULTS = {
                    HeightOffset = 30,
                    Thickness = 1,
                    PaddingX = -5,
                    PaddingZ = -5,
                    Color = Color3.fromRGB(36, 16, 0),
                }
                local bridges = {}

                local function getBridgeSettings(bridge)
                    return {
                        HeightOffset = bridge:GetAttribute('HeightOffset') or DEFAULTS.HeightOffset,
                        Thickness = bridge:GetAttribute('Thickness') or DEFAULTS.Thickness,
                        PaddingX = bridge:GetAttribute('PaddingX') or DEFAULTS.PaddingX,
                        PaddingZ = bridge:GetAttribute('PaddingZ') or DEFAULTS.PaddingZ,
                        Color = bridge:GetAttribute('Color') or DEFAULTS.Color,
                    }
                end

                local rootNames = {
                    HumanoidRootPart = true,
                    Torso = true,
                    UpperTorso = true,
                    LowerTorso = true,
                }

                local function findRootPart(character)
                    for name in pairs(rootNames)do
                        local p = character:FindFirstChild(name)

                        if p then
                            return p
                        end
                    end

                    return character:FindFirstChild('HumanoidRootPart') or character:FindFirstChildWhichIsA('BasePart')
                end
                local function createPlatform(bridge)
                    if bridges[bridge] then
                        if (bridges[bridge].platform and bridges[bridge].platform.Parent) then
                            bridges[bridge].platform:Destroy()
                        end

                        bridges[bridge] = nil
                    end

                    local settings = getBridgeSettings(bridge)
                    local modelCFrame, modelSize = bridge:GetBoundingBox()
                    local part = Instance.new('Part')

                    part.Name = 'BridgePlatform'
                    part.Anchored = true
                    part.CanCollide = false
                    part.Material = Enum.Material.Wood
                    part.Color = settings.Color
                    part.Size = Vector3.new(math.max(0.1, modelSize.X - (settings.PaddingX * 2)), settings.Thickness, math.max(0.1, modelSize.Z - (settings.PaddingZ * 2)))
                    part.CFrame = modelCFrame * CFrame.new(0, (-modelSize.Y / 2) + settings.HeightOffset, 0)
                    part.Parent = bridge
                    bridges[bridge] = {
                        platform = part,
                        settings = settings,
                        touchingPlayers = {},
                        debounces = {},
                    }

                    local function snapPlayerToPlatform(player, character)
                        local record = bridges[bridge]

                        if (not record or not record.platform or not record.platform.Parent) then
                            return
                        end

                        local humanoid = character:FindFirstChildOfClass('Humanoid')
                        local root = findRootPart(character)

                        if (not humanoid or not root) then
                            return
                        end

                        local now = tick()

                        if (record.debounces[player] and ((now - record.debounces[player]) < 0.12)) then
                            return
                        end

                        record.debounces[player] = now

                        local platformTop = record.platform.Position.Y + (record.platform.Size.Y / 2)
                        local vy = 0

                        if (root:IsA('BasePart') and (root:FindFirstChildWhichIsA('Vector3Value') == nil)) then
                            local ok, vel = pcall(function()
                                return root.Velocity
                            end)

                            if (ok and vel) then
                                vy = vel.Y
                            end
                        end
                        if ((vy <= 0) and (root.Position.Y < (platformTop + 3))) then
                            local hip = humanoid.HipHeight or 2
                            local targetY = platformTop + hip + 0.5

                            root.CFrame = CFrame.new(root.Position.X, targetY, root.Position.Z) * CFrame.Angles(root.CFrame:ToEulerAnglesXYZ())
                        end
                    end
                    local function onTouched(hit)
                        local char = hit.Parent
                        local player = Players:GetPlayerFromCharacter(char)

                        if not player then
                            return
                        end

                        bridges[bridge].touchingPlayers[player] = true

                        snapPlayerToPlatform(player, char)
                    end
                    local function onTouchEnded(hit)
                        local char = hit.Parent
                        local player = Players:GetPlayerFromCharacter(char)

                        if not player then
                            return
                        end

                        bridges[bridge].touchingPlayers[player] = nil
                        bridges[bridge].debounces[player] = nil
                    end

                    local tconn = part.Touched:Connect(onTouched)
                    local teconn = part.TouchEnded:Connect(onTouchEnded)

                    bridges[bridge].connections = {tconn, teconn}
                end
                local function cleanupPlatform(bridge)
                    if bridges[bridge] then
                        local record = bridges[bridge]

                        if record.connections then
                            for _, c in ipairs(record.connections)do
                                if (c and c.Connected) then
                                    pcall(function()
                                        c:Disconnect()
                                    end)
                                end
                            end
                        end
                        if (record.platform and record.platform.Parent) then
                            record.platform:Destroy()
                        end

                        bridges[bridge] = nil
                    end
                end
                local function updateBridges()
                    local found = {}

                    for _, desc in ipairs(Workspace:GetDescendants())do
                        if (desc:IsA('Model') and (desc.Name == MODEL_NAME)) then
                            found[desc] = true

                            if not bridges[desc] then
                                createPlatform(desc)
                            end
                        end
                    end
                    for b in pairs(bridges)do
                        if (not found[b] or not b.Parent) then
                            cleanupPlatform(b)
                        end
                    end
                end

                local hbConn = RunService.Heartbeat:Connect(function()
                    for bridge, data in pairs(bridges)do
                        if (bridge and bridge.Parent and data.platform and data.platform.Parent) then
                            local modelCFrame, modelSize = bridge:GetBoundingBox()
                            local s = data.settings

                            data.platform.CFrame = modelCFrame * CFrame.new(0, (-modelSize.Y / 2) + s.HeightOffset, 0)
                        end
                    end
                end)
                local scanning = true

                task.spawn(function()
                    while scanning do
                        updateBridges()
                        task.wait(SCAN_INTERVAL)
                    end
                end)

                _G.SeekBridgeCover = {
                    Bridges = bridges,
                    HeartbeatConn = hbConn,
                    Stop = function()
                        scanning = false

                        if (hbConn and hbConn.Connected) then
                            hbConn:Disconnect()
                        end

                        for b in pairs(bridges)do
                            if bridges[b] then
                                if (bridges[b].platform and bridges[b].platform.Parent) then
                                    bridges[b].platform:Destroy()
                                end
                            end
                        end

                        table.clear(bridges)
                    end,
                }
            elseif _G.SeekBridgeCover then
                _G.SeekBridgeCover.Stop()

                _G.SeekBridgeCover = nil
            end
        end,
    })
    SeekGroup:AddCheckbox('SeekPathESP', {
        Text = '追逐路径',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            Script.Temp = Script.Temp or {}
            Script.Temp.SeekPathConns = Script.Temp.SeekPathConns or {}

            local pathFolder

            local function ensureFolder()
                if (not pathFolder or not pathFolder.Parent) then
                    pathFolder = Instance.new('Folder')
                    pathFolder.Name = 'Path Node'
                    pathFolder.Parent = workspace
                end

                return pathFolder
            end
            local function clearFolder()
                if pathFolder then
                    for _, v in pairs(pathFolder:GetChildren())do
                        v:Destroy()
                    end
                end
            end
            local function createSphere(pos)
                local part = Instance.new('Part')

                part.Size = Vector3.new(1, 1, 1)
                part.Shape = Enum.PartType.Ball
                part.Material = Enum.Material.Neon
                part.Color = Color3.fromRGB(0, 255, 0)
                part.Anchored = true
                part.CanCollide = false
                part.Transparency = 0.3
                part.CFrame = CFrame.new(pos)
                part.Parent = ensureFolder()

                task.spawn(function()
                    local player = game.Players.LocalPlayer

                    if (not player or not player.Character) then
                        return
                    end

                    local root = player.Character:WaitForChild('HumanoidRootPart', 5)

                    if not root then
                        return
                    end

                    while part.Parent do
                        if ((root.Position - part.Position).Magnitude < 5) then
                            part:Destroy()

                            break
                        end

                        task.wait(0.1)
                    end
                end)

                return part
            end
            local function redraw()
                clearFolder()

                local lights = Script.Temp.Lights or {}

                if (#lights == 0) then
                    return
                end

                local positions = {}

                for _, light in ipairs(lights)do
                    if (light and light.Parent) then
                        table.insert(positions, light.Position)
                    end
                end

                if (#positions == 0) then
                    return
                end

                table.sort(positions, function(a, b)
                    return (a.X + a.Y + a.Z) < (b.X + b.Y + b.Z)
                end)

                for _, pos in ipairs(positions)do
                    createSphere(pos)
                end
            end

            if Value then
                ensureFolder()

                Script.Temp.Lights = {}

                local function addLight(light)
                    if (not light or not light.Parent) then
                        return
                    end

                    table.insert(Script.Temp.Lights, light)
                    redraw()
                end

                for _, v in ipairs(workspace:GetDescendants())do
                    if (v.Name == 'SeekGuidingLight') then
                        pcall(addLight, v)
                    end
                end

                Script.Temp.SeekPathAddedConn = workspace.DescendantAdded:Connect(function(obj)
                    if not Value then
                        return
                    end
                    if (obj.Name == 'SeekGuidingLight') then
                        pcall(addLight, obj)
                    end
                end)
                Script.Temp.SeekPathRemovedConn = workspace.DescendantRemoving:Connect(function(obj)
                    if not Value then
                        return
                    end
                    if (obj.Name == 'SeekGuidingLight') then
                        for i, l in ipairs(Script.Temp.Lights)do
                            if (l == obj) then
                                table.remove(Script.Temp.Lights, i)

                                break
                            end
                        end

                        redraw()
                    end
                end)
            else
                if Script.Temp.SeekPathAddedConn then
                    Script.Temp.SeekPathAddedConn:Disconnect()

                    Script.Temp.SeekPathAddedConn = nil
                end
                if Script.Temp.SeekPathRemovedConn then
                    Script.Temp.SeekPathRemovedConn:Disconnect()

                    Script.Temp.SeekPathRemovedConn = nil
                end

                Script.Temp.Lights = nil
                Script.Temp.SeekPathConns = {}

                clearFolder()
            end
        end,
    })

    local BattleGroup = Tabs.Misc:AddRightGroupbox('物品')

    BattleGroup:AddCheckbox('AutoPickupThrowables', {
        Text = '自动拾取可投掷物',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local targetProps = {
                'WoodenCrate',
                'OilBarrel',
                'GarbageBag',
                'Trashcan',
                'CardboardBox_Normal',
                'Hat_Stand',
                'CardboardBox_Wide',
                'Office_Chair',
            }
            local running = true

            if Value then
                task.spawn(function()
                    while running and Value do
                        local bigProps = workspace:FindFirstChild('BigProps')

                        if bigProps then
                            for _, name in ipairs(targetProps)do
                                local prop = bigProps:FindFirstChild(name)

                                if prop then
                                    for _, d in ipairs(prop:GetDescendants())do
                                        if d:IsA('ProximityPrompt') then
                                            d.MaxActivationDistance = 20

                                            if d.Enabled then
                                                pcall(fireproximityprompt, d)
                                            end
                                        end
                                    end
                                end
                            end
                        end

                        task.wait(0.5)
                    end
                end)
            else
                running = false
            end
        end,
    })
    BattleGroup:AddCheckbox('Auto Break Door', {
        Text = '自动破门',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local connections = {}
            local running = false
            local targetNames = {
                'DoorPieceBottom',
                'DoorPieceTop',
            }

            local function safeDisconnect()
                for _, c in ipairs(connections)do
                    if (c and c.Disconnect) then
                        pcall(function()
                            c:Disconnect()
                        end)
                    elseif (c and c.disconnect) then
                        pcall(function()
                            c:disconnect()
                        end)
                    end
                end

                connections = {}
            end
            local function handlePrompt(p)
                pcall(function()
                    p.MaxActivationDistance = 40
                end)

                if p.Enabled then
                    pcall(fireproximityprompt, p)
                end
            end
            local function processModel(m)
                for _, n in ipairs(targetNames)do
                    local part = m:FindFirstChild(n, true)

                    if part then
                        for _, d in ipairs(part:GetDescendants())do
                            if d:IsA('ProximityPrompt') then
                                pcall(handlePrompt, d)
                            end
                        end

                        local con = part.DescendantAdded:Connect(function(desc)
                            if desc:IsA('ProximityPrompt') then
                                pcall(function()
                                    task.defer(handlePrompt, desc)
                                end)
                            end
                        end)

                        table.insert(connections, con)
                    end
                end
            end
            local function scanAll()
                local cr = workspace:FindFirstChild('CurrentRooms')

                if not cr then
                    return
                end

                for _, room in ipairs(cr:GetDescendants())do
                    if (room:IsA('Model') or room:IsA('Folder')) then
                        processModel(room)
                    end
                end
            end

            if Value then
                running = true

                safeDisconnect()
                task.spawn(function()
                    scanAll()

                    local cr = workspace:FindFirstChild('CurrentRooms')

                    if cr then
                        local con = cr.DescendantAdded:Connect(function(d)
                            if not running then
                                return
                            end

                            local model = d

                            while model and not (model:IsA('Model') or model:IsA('Folder')) do
                                model = model.Parent
                            end

                            if model then
                                task.defer(processModel, model)
                            end
                        end)

                        table.insert(connections, con)
                    end

                    while running and Value do
                        scanAll()
                        task.wait(0.8)
                    end
                end)
            else
                running = false

                safeDisconnect()
            end
        end,
    })
    BattleGroup:AddCheckbox('Auto Pickup', {
        Text = '自动拾取',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local connections = {}
            local running = false

            local function safeDisconnect()
                for _, c in ipairs(connections)do
                    if (c and c.Disconnect) then
                        pcall(function()
                            c:Disconnect()
                        end)
                    elseif (c and c.disconnect) then
                        pcall(function()
                            c:disconnect()
                        end)
                    end
                end

                connections = {}
            end
            local function handlePrompt(p)
                pcall(function()
                    p.MaxActivationDistance = 40
                end)

                if p.Enabled then
                    pcall(fireproximityprompt, p)
                end
            end
            local function processDrop(d)
                for _, desc in ipairs(d:GetDescendants())do
                    if desc:IsA('ProximityPrompt') then
                        pcall(handlePrompt, desc)
                    end
                end

                local con = d.DescendantAdded:Connect(function(desc)
                    if desc:IsA('ProximityPrompt') then
                        pcall(function()
                            task.defer(handlePrompt, desc)
                        end)
                    end
                end)

                table.insert(connections, con)
            end
            local function scanDrops()
                local drops = workspace:FindFirstChild('Drops')

                if not drops then
                    return
                end

                for _, child in ipairs(drops:GetChildren())do
                    if (child:IsA('Model') or child:IsA('Folder')) then
                        processDrop(child)
                    end
                end
            end

            if Value then
                running = true

                safeDisconnect()
                task.spawn(function()
                    scanDrops()

                    local drops = workspace:FindFirstChild('Drops')

                    if drops then
                        local con = drops.ChildAdded:Connect(function(c)
                            if not running then
                                return
                            end
                            if (c:IsA('Model') or c:IsA('Folder')) then
                                task.defer(processDrop, c)
                            end
                        end)

                        table.insert(connections, con)
                    end

                    while running and Value do
                        scanDrops()
                        task.wait(0.8)
                    end
                end)
            else
                running = false

                safeDisconnect()
            end
        end,
    })
    BattleGroup:AddCheckbox('Auto Fire', {
        Text = '自动攻击',
        Default = false,
        Disabled = false,
        Callback = function(Value)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local LocalPlayer = Players.LocalPlayer
            local Camera = workspace.CurrentCamera
            local RAY_DISTANCE = 50
            local con = nil
            local triggered = false

            local function safeMouse1Press()
                pcall(mouse1press)
            end
            local function safeMouse1Release()
                pcall(mouse1release)
            end
            local function isTargetVisible(targetPos)
                local rayParams = RaycastParams.new()

                rayParams.FilterType = Enum.RaycastFilterType.Exclude
                rayParams.FilterDescendantsInstances = {
                    LocalPlayer.Character,
                }

                local origin = Camera.CFrame.Position
                local direction = targetPos - origin
                local result = workspace:Raycast(origin, direction, rayParams)

                if not result then
                    return true
                end

                return (result.Instance.Position - targetPos).Magnitude < 3
            end
            local function update()
                if (not LocalPlayer.Character or not Camera) then
                    if triggered then
                        safeMouse1Release()

                        triggered = false
                    end

                    return
                end

                local myChar = LocalPlayer.Character
                local myHead = myChar:FindFirstChild('Head')

                if not myHead then
                    return
                end

                local lookVector = Camera.CFrame.LookVector
                local origin = Camera.CFrame.Position
                local bestTarget = nil
                local bestDot = 0.995

                for _, plr in pairs(Players:GetPlayers())do
                    if ((plr ~= LocalPlayer) and plr.Character and plr.Character:FindFirstChild('HumanoidRootPart')) then
                        local targetPos = plr.Character.HumanoidRootPart.Position
                        local dirToTarget = (targetPos - origin).Unit
                        local dot = lookVector:Dot(dirToTarget)

                        if (dot > bestDot) then
                            local dist = (targetPos - origin).Magnitude

                            if ((dist < RAY_DISTANCE) and isTargetVisible(targetPos)) then
                                bestDot = dot
                                bestTarget = plr
                            end
                        end
                    end
                end

                if bestTarget then
                    if not triggered then
                        print('Firing at', bestTarget.Name)
                        safeMouse1Press()

                        triggered = true
                    end
                elseif triggered then
                    safeMouse1Release()

                    triggered = false
                end
            end

            if Value then
                if (con and con.Connected) then
                    con:Disconnect()
                end

                con = RunService.RenderStepped:Connect(function()
                    pcall(update)
                end)
            else
                if con then
                    con:Disconnect()

                    con = nil
                end
                if triggered then
                    safeMouse1Release()

                    triggered = false
                end
            end
        end,
    })

    local RoomsGroup = Tabs.Misc:AddRightGroupbox('The Rooms')

    RoomsGroup:AddCheckbox('AutoRooms', {
        Text = '自动rooms',
        Default = false,
        Disabled = false,
        Callback = function(enabled)
            local Players = game:GetService('Players')
            local RunService = game:GetService('RunService')
            local PathfindingService = game:GetService('PathfindingService')
            local ReplicatedStorage = game:GetService('ReplicatedStorage')
            local Workspace = game:GetService('Workspace')
            local player = Players.LocalPlayer
            local rooms = Workspace:WaitForChild('CurrentRooms')
            local gameData = ReplicatedStorage:WaitForChild('GameData')
            local floor = gameData:WaitForChild('Floor')
            local active = false
            local runner
            local clone

            local function stop()
                active = false

                if runner then
                    runner:Disconnect()

                    runner = nil
                end
                if (clone and clone.Parent) then
                    clone:Destroy()
                end

                player:SetAttribute('AutoRoomsActive', false)
            end

            if not enabled then
                stop()

                return
            end

            player:SetAttribute('AutoRoomsActive', true)

            active = true

            if (player.Character and player.Character:FindFirstChild('CollisionPart')) then
                clone = player.Character.CollisionPart:Clone()
                clone.Name = '_AutoRoomsCollision'
                clone.Massless = true
                clone.Anchored = false
                clone.CanCollide = false
                clone.CanQuery = false
                clone.CustomPhysicalProperties = PhysicalProperties.new(0.01, 0.7, 0, 1, 1)
                clone.Parent = player.Character
            end

            local function findClosestLocker()
                local best, bestDist = nil, math.huge

                for _, obj in ipairs(rooms:GetDescendants())do
                    if ((obj.Name == 'Rooms_Locker') or (obj.Name == 'Rooms_Locker_Fridge')) then
                        if obj.PrimaryPart then
                            local dist = (player.Character.HumanoidRootPart.Position - obj.PrimaryPart.Position).Magnitude

                            if (dist < bestDist) then
                                best = obj
                                bestDist = dist
                            end
                        end
                    end
                end

                return best
            end
            local function walkTo(target)
                local char = player.Character

                if not (char and char:FindFirstChild('HumanoidRootPart')) then
                    return
                end

                local path = PathfindingService:CreatePath({
                    AgentRadius = 2,
                    AgentHeight = 1,
                    AgentCanJump = false,
                    WaypointSpacing = 5,
                })

                path:ComputeAsync(char.HumanoidRootPart.Position, target.Position)

                if (path.Status == Enum.PathStatus.Success) then
                    for _, waypoint in ipairs(path:GetWaypoints())do
                        if not active then
                            return
                        end

                        char:FindFirstChildOfClass('Humanoid'):MoveTo(waypoint.Position)
                        char.Humanoid.MoveToFinished:Wait()
                    end
                end
            end

            runner = RunService.Heartbeat:Connect(function()
                if not active then
                    return
                end
                if (floor.Value ~= 'Rooms') then
                    return stop()
                end
                if (gameData.LatestRoom.Value >= 1000) then
                    return stop()
                end

                local entity = Workspace:FindFirstChild('A60') or Workspace:FindFirstChild('A120') or Workspace:FindFirstChild('GlitchRush') or Workspace:FindFirstChild('GlitchAmbush')

                if (entity and entity.PrimaryPart and (entity.PrimaryPart.Position.Y > -6)) then
                    local locker = findClosestLocker()

                    if (locker and locker.PrimaryPart) then
                        local hide = locker:FindFirstChild('HidePoint')

                        if not hide then
                            hide = Instance.new('Part')
                            hide.Name = 'HidePoint'
                            hide.Anchored = true
                            hide.Transparency = 1
                            hide.CanCollide = false
                            hide.Position = locker.PrimaryPart.Position + (locker.PrimaryPart.CFrame.LookVector * 7)
                            hide.Parent = locker
                        end

                        walkTo(hide)
                        task.wait(0.1)

                        local prompt = locker:FindFirstChildOfClass('ProximityPrompt')

                        if prompt then
                            if fireproximityprompt then
                                fireproximityprompt(prompt)
                            else
                                prompt:InputHoldBegin()
                                prompt:InputHoldEnd()
                            end
                        end
                    end
                else
                    local currentRoom = gameData.LatestRoom.Value
                    local door = rooms[currentRoom] and rooms[currentRoom]:FindFirstChild('Door', true)

                    if (door and door:FindFirstChild('Door')) then
                        walkTo(door.Door)
                    end
                end
            end)
        end,
    })

    local A90Hook

    RoomsGroup:AddCheckbox('AvoidA90', {
        Text = '防A-90',
        Default = false,
        Disabled = false,
        Tooltip = '删去 A90',
        Callback = function(ad)
            local modules = LocalPlayer.PlayerGui:FindFirstChild('MainUI') and LocalPlayer.PlayerGui.MainUI:FindFirstChild('Initiator') and LocalPlayer.PlayerGui.MainUI.Initiator:FindFirstChild('Main_Game') and LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game:FindFirstChild('RemoteListener') and LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener:FindFirstChild('Modules')
            local c3 = modules and (modules:FindFirstChild('A90') or modules:FindFirstChild('_A90'))

            if c3 then
                c3.Name = (ad and '_A90') or 'A90'
            end

            local remote = (game:GetService('ReplicatedStorage'):FindFirstChild('RemotesFolder') and game:GetService('ReplicatedStorage').RemotesFolder:FindFirstChild('A90')) or game:GetService('ReplicatedStorage').RemotesFolder:FindFirstChild('_A90')

            if remote then
                remote.Name = (ad and '_A90') or 'A90'
            end
        end,
    })

    local AprilFools = Tabs.Misc:AddRightGroupbox('Frools 2023')
    local currentRooms = workspace:WaitForChild('CurrentRooms')
    local antiBananaConn

    AprilFools:AddCheckbox('AntiBanana', {
        Text = '防香蕉',
        Default = false,
        Callback = function(Value)
            if antiBananaConn then
                antiBananaConn:Disconnect()

                antiBananaConn = nil
            end

            for _, v in pairs(currentRooms:GetDescendants())do
                if ((v.Name == 'BananaPeel') and v:IsA('BasePart')) then
                    v.CanTouch = not Value
                end
            end

            if Value then
                antiBananaConn = currentRooms.DescendantAdded:Connect(function(v)
                    if ((v.Name == 'BananaPeel') and v:IsA('BasePart')) then
                        v.CanTouch = false
                    end
                end)
            end
        end,
    })

    local antiJeffConn

    AprilFools:AddCheckbox('AntiJeff', {
        Text = '防杰夫怪',
        Default = false,
        Callback = function(Value)
            if antiJeffConn then
                antiJeffConn:Disconnect()

                antiJeffConn = nil
            end

            for _, model in pairs(currentRooms:GetDescendants())do
                if ((model.Name == 'JeffTheKiller') and model:IsA('Model')) then
                    for _, part in ipairs(model:GetChildren())do
                        if part:IsA('BasePart') then
                            part.CanTouch = not Value
                        end
                    end
                end
            end

            if Value then
                antiJeffConn = currentRooms.DescendantAdded:Connect(function(v)
                    if ((v.Name == 'JeffTheKiller') and v:IsA('Model')) then
                        for _, part in ipairs(v:GetChildren())do
                            if part:IsA('BasePart') then
                                part.CanTouch = false
                            end
                        end
                    end
                end)
            end
        end,
    })

    UISettings = Window:AddTab('UI Settings', 'user-round-cog')
    SettingsLeftGroup = UISettings:AddLeftGroupbox('Menu Settings')
    MenuVisibility = SettingsLeftGroup:AddCheckbox('MenuVisibility', {
        Text = '显示菜单',
        Default = true,
        Disabled = false,
        Tooltip = '切换菜单可见性',
        Callback = function(Value)
            Library:Toggle(Value)

            if enableNotifications then
                Library:Notify({
                    Title = 'Menu Visibility',
                    Description = (Value and 'Menu shown') or 'Menu hidden',
                    Time = notifyDuration,
                    SoundId = ((notificationSoundId > 0) and notificationSoundId) or nil,
                })
            end
        end,
    })

    MenuVisibility:AddKeyPicker('MenuToggleKey', {
        Default = 'End',
        SyncToggleState = true,
        Mode = 'Toggle',
        Text = '切换菜单',
        NoUI = false,
    })
    SettingsLeftGroup:AddDivider()
    SettingsLeftGroup:AddButton({
        Text = '卸载菜单',
        Func = function()
            if enableNotifications then
                Library:Notify({
                    Title = 'Menu Unload',
                    Description = 'Unloading menu...',
                    Time = notifyDuration,
                    SoundId = ((notificationSoundId > 0) and notificationSoundId) or nil,
                })
            end

            task.wait(0.3)
            Library:Unload()
        end,
        DoubleClick = false,
        Tooltip = '卸载菜单',
    })

    AppearanceGroup = UISettings:AddLeftGroupbox('Appearance')

    AppearanceGroup:AddCheckbox('ShowKeybinds', {
        Text = '显示按键绑定界面',
        Default = false,
        Disabled = false,
        Tooltip = '切换键绑定列表可见性',
        Callback = function(Value)
            Library.KeybindFrame.Visible = Value

            if enableNotifications then
                Library:Notify({
                    Title = 'Keybinds Frame',
                    Description = 'Keybinds frame ' .. ((Value and 'shown') or 'hidden'),
                    Time = notifyDuration,
                    SoundId = ((notificationSoundId > 0) and notificationSoundId) or nil,
                })
            end
        end,
    })
    SaveManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetFolder('VelocityX')
    SaveManager:BuildConfigSection(UISettings)
    ThemeManager:SetLibrary(Library)
    ThemeManager:SetFolder('VelocityX')
    ThemeManager:ApplyToTab(UISettings)

    local NotificationGroup = UISettings:AddRightGroupbox('Notifications')

    notifyDuration = 3
    enableNotifications = true
    notificationSoundId = 0
    soundPresets = {
        {
            Name = 'None',
            Id = 0,
        },
        {
            Name = 'Default Notification',
            Id = 3023237993,
        },
        {
            Name = 'Android Ding',
            Id = 6205430632,
        },
        {
            Name = 'Error Buzz',
            Id = 5188022160,
        },
        {
            Name = 'Alert Alarm',
            Id = 1616678030,
        },
    }

    NotificationGroup:AddCheckbox('EnableNotifications', {
        Text = '启用通知',
        Default = true,
        Disabled = false,
        Tooltip = '切换是否为操作显示通知',
        Callback = function(Value)
            enableNotifications = Value
        end,
    })
    NotificationGroup:AddSlider('NotifyDuration', {
        Text = '通知持续时间（秒）',
        Default = 3,
        Min = 1,
        Max = 10,
        Rounding = 0,
        Compact = true,
        Callback = function(Value)
            notifyDuration = Value

            if enableNotifications then
                Library:Notify({
                    Title = 'Notification Settings',
                    Description = 'Notification duration set to ' .. Value .. ' seconds',
                    Time = Value,
                    SoundId = ((notificationSoundId > 0) and notificationSoundId) or nil,
                })
            end
        end,
    })

    local soundInput = NotificationGroup:AddInput('NotificationSoundId', {
        Text = '通知音效ID',
        Default = '0',
        Numeric = true,
        Finished = true,
        Tooltip = '所有通知的ROBLOX声音ID(0表示无)',
        Callback = function(Value)
            notificationSoundId = tonumber(Value) or 0
        end,
    })

    NotificationGroup:AddDropdown('SoundPreset', {
        Text = '音效预设',
        Default = 'None',
        Values = {
            'None',
            'Default Notification',
            'Android Ding',
            'Error Buzz',
            'Alert Alarm',
        },
        Callback = function(Value)
            for _, preset in ipairs(soundPresets)do
                if (preset.Name == Value) then
                    notificationSoundId = preset.Id

                    soundInput:SetValue(tostring(preset.Id))

                    break
                end
            end
        end,
    })
    NotificationGroup:AddButton({
        Text = '测试通知',
        Func = function()
            Library:Notify({
                Title = 'Test Notification',
                Description = 'This is a test notification!',
                Time = notifyDuration,
                SoundId = ((notificationSoundId > 0) and notificationSoundId) or nil,
            })
        end,
    })
    Library:SetWatermarkVisibility(true)

    local function updateWatermark()
        local fps = 60
        local frameTimer = tick()
        local frameCounter = 0

        game:GetService('RunService').RenderStepped:Connect(function()
            frameCounter = frameCounter + 1

            if ((tick() - frameTimer) >= 1) then
                fps = frameCounter
                frameTimer = tick()
                frameCounter = 0
            end

            Library:SetWatermark(string.format('YG SCRIPT | %d FPS | By YG | %d ping', math.floor(fps), math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())))
        end)
    end

    updateWatermark()
end
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})

local MyButton = LeftGroupBox:AddButton({
    Text = '死铁轨🛤',---服务器名称
    Func = function()
    local originalUI = Library
        
if not game:IsLoaded() then
    game.Loaded:Wait()
end

if game.CoreGui:FindFirstChild("Gun Health Track") == nil then
local gui = Instance.new("ScreenGui", game.CoreGui)
gui.Name = "枪支健康轨迹"
gui.Enabled = false

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0.2, 0, 0.1, 0)
Frame.Position = UDim2.new(0.02, 0, 0.87, 0)
Frame.BackgroundColor3 = Color3.new(1, 1, 1)
Frame.BorderColor3 = Color3.new(0, 0, 0)
Frame.BorderSizePixel = 1
Frame.Active = true
Frame.BackgroundTransparency = 0 
Frame.Parent = gui

local UICorner = Instance.new("UIStroke")
UICorner.Color = Color3.new(0, 0, 0)
UICorner.Thickness = 2.5
UICorner.Parent = Frame

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = Frame

local Frame1 = Instance.new("Frame")
Frame1.Size = UDim2.new(1, 0, 1, 0)
Frame1.Position = UDim2.new(0, 0, 0, 0)
Frame1.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
Frame1.BorderColor3 = Color3.new(0, 0, 0)
Frame1.BorderSizePixel = 1
Frame1.Active = true
Frame1.BackgroundTransparency = 0.3
Frame1.Parent = Frame

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = Frame1

local Frame2 = Instance.new("Frame")
Frame2.Name = "Frame1"
Frame2.Size = UDim2.new(1, 0, 1, 0)
Frame2.Position = UDim2.new(0, 0, 0, 0)
Frame2.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
Frame2.BorderColor3 = Color3.new(0, 0, 0)
Frame2.BorderSizePixel = 1
Frame2.Active = true
Frame2.BackgroundTransparency = 0.15
Frame2.Parent = Frame1

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = Frame2

local TextLabel = Instance.new("TextLabel")
TextLabel.Size = UDim2.new(1, 0, 1, 0)
TextLabel.Position = UDim2.new(0, 0, 0, 0)
TextLabel.BackgroundColor3 = Color3.new(0, 0, 0)
TextLabel.BorderColor3 = Color3.new(0, 0, 0)
TextLabel.BorderSizePixel = 1
TextLabel.Text = ""
TextLabel.TextSize = 15
TextLabel.BackgroundTransparency = 1
TextLabel.TextColor3 = Color3.new(0, 0, 0)
TextLabel.Font = Enum.Font.Code
TextLabel.TextWrapped = true
TextLabel.Parent = Frame
end

---- Weld ----

if game.CoreGui:FindFirstChild("WeldButton") == nil then
local gui = Instance.new("ScreenGui", game.CoreGui)
gui.Name = "WeldButton"
gui.Enabled = false

local Frame1 = Instance.new("Frame")
Frame1.Name = "Frame1"
Frame1.Size = UDim2.new(0, 50, 0, 50)
Frame1.Position = UDim2.new(0.9, 0, 0.3, 0)
Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
Frame1.BorderColor3 = Color3.new(0, 0, 0)
Frame1.BorderSizePixel = 1
Frame1.Active = true
Frame1.BackgroundTransparency = 0.85
Frame1.Draggable = true
Frame1.Parent = gui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = Frame1

local TextButton = Instance.new("TextButton")
TextButton.Size = UDim2.new(1, 0, 1, 0)
TextButton.Position = UDim2.new(0, 0, 0, 0)
TextButton.BackgroundColor3 = Color3.new(0, 0, 0)
TextButton.BorderColor3 = Color3.new(0, 0, 0)
TextButton.BorderSizePixel = 1
TextButton.Text = "焊接"
TextButton.TextSize = 18
TextButton.FontFace = Font.new("rbxassetid://12187372175", Enum.FontWeight.Regular, Enum.FontStyle.Normal)
TextButton.BackgroundTransparency = 0.5
TextButton.TextColor3 = Color3.new(255, 255, 255)
TextButton.Parent = Frame1
TextButton.MouseButton1Click:Connect(function()
if workspace:FindFirstChild("RuntimeItems") then
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.ClassName == "Model" and v.PrimaryPart ~= nil then
if v.PrimaryPart:FindFirstChild("DragAlignPosition") then
for j, x in pairs(workspace:GetChildren()) do
if x:IsA("Model") and x:FindFirstChild("RequiredComponents") and x.RequiredComponents:FindFirstChild("Base") then
if v.PrimaryPart:FindFirstChild("DragWeldConstraint") == nil then
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.RequestWeld:FireServer(v, x.RequiredComponents:FindFirstChild("Base"))
end
end
end
end
end
end
end
end)

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = TextButton

local UICorner = Instance.new("UIStroke")
UICorner.Color = Color3.new(0, 0, 0)
UICorner.Thickness = 2.5
UICorner.Parent = Frame1

local UserInputService = game:GetService("UserInputService")
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
	local delta = input.Position - dragStart
	Frame1.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

TextButton.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = Frame1.Position
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

TextButton.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging then
		update(input)
	end
end)
end

function TweenWalk(Part)
if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid") and game.Players.LocalPlayer.Character.Humanoid.RootPart and game.Players.LocalPlayer.Character.HumanoidRootPart:FindFirstChild("VelocityHandler") == nil then
local bv = Instance.new("BodyVelocity")
bv.Name = "VelocityHandler"
bv.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
bv.MaxForce = Vector3.new(100000, 100000, 100000)
bv.Velocity = Vector3.new(0, 0, 0)
end
local TweenService = game:GetService("TweenService")
local Tween = TweenService:Create(game.Players.LocalPlayer.Character.HumanoidRootPart, TweenInfo.new((game.Players.LocalPlayer.Character.HumanoidRootPart.Position - Part).Magnitude / 16, Enum.EasingStyle.Linear), {CFrame = CFrame.new(Part)})
Tween:Play()
Tween.Completed:Wait()
Tween:Cancel()
if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid") and game.Players.LocalPlayer.Character.Humanoid.RootPart and game.Players.LocalPlayer.Character.HumanoidRootPart:FindFirstChild("VelocityHandler") then
game.Players.LocalPlayer.Character.HumanoidRootPart.VelocityHandler:Destroy()
end
end
end
_G.CharacterToYour = {["Head"] = (game.Players.LocalPlayer.Character:FindFirstChild("Head").Size)}

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Articles-Hub/ROBLOXScript/refs/heads/main/Library/LinoriaLib/Test.lua"))()
local ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Articles-Hub/ROBLOXScript/refs/heads/main/Library/LinoriaLib/addons/ThemeManagerCopy.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Articles-Hub/ROBLOXScript/refs/heads/main/Library/LinoriaLib/addons/SaveManagerCopy.lua"))()
local Options = Library.Options
local Toggles = Library.Toggles

function Notification(Message, Time)
if _G.ChooseNotify == "Obsidian" then
Library:Notify(Message, Time or 5)
elseif _G.ChooseNotify == "Roblox" then
game:GetService("StarterGui"):SetCore("SendNotification",{Title = "Error",Text = Message,Icon = "rbxassetid://7733658504",Duration = Time or 5})
end
if _G.NotificationSound then
        local sound = Instance.new("Sound", workspace)
            sound.SoundId = "rbxassetid://4590662766"
            sound.Volume = _G.VolumeTime or 2
            sound.PlayOnRemove = true
            sound:Destroy()
        end
    end

Library:SetDPIScale(85)

local Window = Library:CreateWindow({
    Title = "YG SCRIPT",
    Center = true,
    AutoShow = true,
    Resizable = true,
    Footer = "YG SCRIPT Version: 1.0.5",
	Icon = 93487642627310,
	AutoLock = true,
    ShowCustomCursor = true,
    NotifySide = "Right",
    TabPadding = 2,
    MenuFadeTime = 0
})

Tabs = {
	Tab = Window:AddTab("Main", "rbxassetid://7734053426"),
	Tab1 = Window:AddTab("Misc", "rbxassetid://4370318685"),
	["UI Settings"] = Window:AddTab("UI Settings", "rbxassetid://7733955511")
}

local Main1Group = Tabs.Tab:AddLeftGroupbox("功能")

DistanceTrain = Main1Group:AddLabel("Distance [ Nah ]", true)
if game:GetService("ReplicatedStorage"):FindFirstChild("TimeHour") then
Time = Main1Group:AddLabel("Time [ "..game:GetService("ReplicatedStorage"):FindFirstChild("TimeHour").Value.." ]", true)
end

Main1Group:AddToggle("Return Check", {
    Text = "返回支票",
    Default = false, 
    Callback = function(Value) 
_G.ReturnCheck = Value
while _G.ReturnCheck do
for i, v in pairs(workspace:GetChildren()) do
if v:IsA("Model") and v:FindFirstChild("RequiredComponents") then
if v.RequiredComponents:FindFirstChild("Controls") and v.RequiredComponents.Controls:FindFirstChild("DistanceDial") and v.RequiredComponents.Controls.DistanceDial:FindFirstChild("SurfaceGui") then
if v.RequiredComponents.Controls.DistanceDial.SurfaceGui:FindFirstChild("TextLabel") then
DistanceTrain:SetText("Distance [ "..v.RequiredComponents.Controls.DistanceDial.SurfaceGui:FindFirstChild("TextLabel").Text.." ]")
else
DistanceTrain:SetText("Distance [ No Train ]")
end
end
end
end
Time:SetText("Time [ "..game:GetService("ReplicatedStorage").TimeHour.Value.." ]")
task.wait()
end
    end
})

Main1Group:AddButton("Teleport To Train", function()
for i, v in pairs(workspace:GetChildren()) do
if v:IsA("Model") and v:FindFirstChild("RequiredComponents") then
if v.RequiredComponents:FindFirstChild("Controls") and v.RequiredComponents.Controls:FindFirstChild("ConductorSeat") and v.RequiredComponents.Controls.ConductorSeat:FindFirstChild("VehicleSeat") then
game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(v.RequiredComponents.Controls.ConductorSeat:FindFirstChild("VehicleSeat").CFrame)
end
end
end
end)

Main1Group:AddButton("Teleport To Castle", function()
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
wait(0.5)
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(57, 3, -9000)
repeat task.wait() until workspace.RuntimeItems:FindFirstChild("MaximGun")
wait(0.3)
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.Name == "MaximGun" and v:FindFirstChild("VehicleSeat") then
v.VehicleSeat.Disabled = false
end
end
wait(0.5)
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.Name == "MaximGun" and v:FindFirstChild("VehicleSeat") and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.VehicleSeat.Position).Magnitude < 400 then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.VehicleSeat.CFrame
end
end
wait(1)
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
end)

Main1Group:AddButton("Teleport To TeslaLab", function()
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
wait(0.5)
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = workspace.TeslaLab.Generator.Generator.CFrame
repeat task.wait() until workspace.RuntimeItems:FindFirstChild("Chair")
wait(0.3)
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.Name == "Chair" and v:FindFirstChild("Seat") then
v.Seat.Disabled = false
end
end
wait(0.5)
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
repeat task.wait()
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.Name == "Chair" and v:FindFirstChild("Seat") and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Seat.Position).Magnitude < 250 then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.Seat.CFrame
end
end
until game.Players.LocalPlayer.Character.Humanoid.Sit == true
wait(0.5)
game.Players.LocalPlayer.Character.Humanoid.Sit = false
end)

Main1Group:AddButton("Teleport To End", function()
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
wait(0.5)
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-424, 30, -49041)
repeat task.wait() until workspace.Baseplates:FindFirstChild("FinalBasePlate")
BasePart = workspace.Baseplates:FindFirstChild("FinalBasePlate")
OurLaw = BasePart:FindFirstChild("OutlawBase") 
Sen = OurLaw:FindFirstChild("Sentries")
if Sen:FindFirstChild("TurretSpot") and Sen.TurretSpot:FindFirstChild("MaximGun") and Sen.TurretSpot.MaximGun:FindFirstChild("VehicleSeat") then
wait(1.5)
for i, v in pairs(Sen:FindFirstChild("TurretSpot"):GetChildren()) do
if v.Name == "MaximGun" and v:FindFirstChild("VehicleSeat") then
v.VehicleSeat.Disabled = false
end
end
wait(0.5)
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
repeat task.wait()
for i, v in pairs(Sen:FindFirstChild("TurretSpot"):GetChildren()) do
if v.Name == "MaximGun" and v:FindFirstChild("VehicleSeat") then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v:FindFirstChild("VehicleSeat").CFrame
end
end
until game.Players.LocalPlayer.Character.Humanoid.Sit == true
wait(0.5)
game.Players.LocalPlayer.Character.Humanoid.Sit = false
end
end)

Main1Group:AddToggle("No Cooldown Proximity", {
    Text = "No Cooldown Proximity",
    Default = false, 
    Callback = function(Value) 
_G.NoCooldownProximity = Value
if _G.NoCooldownProximity == true then
for i, v in pairs(workspace:GetDescendants()) do
if v.ClassName == "ProximityPrompt" then
v.HoldDuration = 0
end
end
else
if CooldownProximity then
CooldownProximity:Disconnect()
CooldownProximity = nil
end
end
CooldownProximity = workspace.DescendantAdded:Connect(function(Cooldown)
if _G.NoCooldownProximity == true then
if Cooldown:IsA("ProximityPrompt") then
Cooldown.HoldDuration = 0
end
end
end)
    end
})

Main1Group:AddToggle("Weld Button", {
    Text = "免费焊接件",
    Default = false, 
    Callback = function(Value) 
if game.CoreGui:FindFirstChild("WeldButton") then
game.CoreGui:FindFirstChild("WeldButton").Enabled = Value
end
    end
})

Main1Group:AddToggle("Unlock Person", {
    Text = "Unlock Person",
    Default = false, 
    Callback = function(Value) 
_G.UnlockPerson = Value
if _G.UnlockPerson then
if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
end
game.Players.LocalPlayer.CameraMode = "Classic"
game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
game.Players.LocalPlayer.CameraMinZoomDistance = 0
else
game.Players.LocalPlayer.CameraMode = "LockFirstPerson"
end
    end
})

Main1Group:AddToggle("Auto Fuel", {
    Text = "Auto Fuel Train",
    Default = false, 
    Callback = function(Value) 
_G.FuelTrain = Value
while _G.FuelTrain do
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.ClassName == "Model" and v:FindFirstChild("ObjectInfo") and v.PrimaryPart ~= nil and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude < 5 then
for h, m in pairs(v.ObjectInfo:GetChildren()) do
if m.Name == "TextLabel" and m.Text == "Fuel" and m.Text ~= "Valuable" and m.Text ~= "Bounty" then
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.RequestStartDrag:FireServer(v)
wait(0.3)
for a, k in pairs(workspace:GetChildren()) do
if k:IsA("Model") and k:FindFirstChild("RequiredComponents") and k.RequiredComponents:FindFirstChild("FuelZone") then
v:SetPrimaryPartCFrame(k.RequiredComponents:FindFirstChild("FuelZone").CFrame)
end
end
wait(0.3)
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.RequestStopDrag:FireServer()
end
end
end
end
task.wait()
end
    end
}):AddKeyPicker("AutoFuel", {
   Default = "J",
   Text = "Auto Fuel",
   Mode = "Toggle",
   SyncToggleState = true
})

Main1Group:AddToggle("Weld Item", {
    Text = "Weld Item",
    Default = false, 
    Callback = function(Value) 
_G.WeldItem = Value
while _G.WeldItem do
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.ClassName == "Model" and v.PrimaryPart ~= nil and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude < 30 then
if v.PrimaryPart:FindFirstChild("DragWeldConstraint") == nil then
for j, x in pairs(workspace:GetChildren()) do
if x:IsA("Model") and x:FindFirstChild("RequiredComponents") and x.RequiredComponents:FindFirstChild("Base") then
if x.RequiredComponents:FindFirstChild("Controls") and x.RequiredComponents.Controls:FindFirstChild("ConductorSeat") and x.RequiredComponents.Controls.ConductorSeat:FindFirstChild("VehicleSeat") then
if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - x.RequiredComponents.Controls.ConductorSeat:FindFirstChild("VehicleSeat").Position).Magnitude < 60 then
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.RequestWeld:FireServer(v, x.RequiredComponents:FindFirstChild("Base"))
end
end
end
end
end
end
end
task.wait(1.8)
end
    end
}):AddKeyPicker("WeldItem", {
   Default = "Z",
   Text = "Weld Item",
   Mode = "Toggle",
   SyncToggleState = true
})

Main1Group:AddToggle("Auto Sell", {
    Text = "Auto Sell",
    Default = false, 
    Callback = function(Value) 
_G.SellItem = Value
while _G.SellItem do
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.Name ~= "Rock" and v:FindFirstChild("ObjectInfo") and v.PrimaryPart ~= nil and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude < 7 then
for h, m in pairs(v.ObjectInfo:GetChildren()) do
if m.Name == "TextLabel" then
if m.Text == "Valuable" or m.Text == "Junk" or m.Text == "Gun" then
if workspace:FindFirstChild("SafeZones") and workspace.SafeZones:FindFirstChild("SafeZone") and workspace.SafeZones.SafeZone:FindFirstChild("Buildings") then
for z, j in pairs(workspace.SafeZones.SafeZone.Buildings:GetChildren()) do
if j.Name:find("Trading") and j:FindFirstChild("BountySquare") then
for k, w in pairs(j.BountySquare:GetChildren()) do
if w.Name == "Part" and w:FindFirstChild("SurfaceGui") and w.SurfaceGui:FindFirstChild("TextLabel") then
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.RequestStartDrag:FireServer(v)
wait(0.3)
spawn(function()
for i = 1, 60 do
if v.PrimaryPart ~= nil then
v:SetPrimaryPartCFrame(w.CFrame)
end
task.wait()
end
end)
task.wait(0.3)
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.RequestStopDrag:FireServer()
end
end
end
end
end
elseif m.Text == "Bounty" then
if workspace:FindFirstChild("SafeZones") and workspace.SafeZones:FindFirstChild("SafeZone") and workspace.SafeZones.SafeZone:FindFirstChild("Buildings") then
for z, j in pairs(workspace.SafeZones.SafeZone.Buildings:GetChildren()) do
if j.Name:find("Sheriffs") and j:FindFirstChild("BountySquare") then
for z, w in pairs(j.BountySquare:GetChildren()) do
if w.Name == "Part" and w:FindFirstChild("SurfaceGui") and w.SurfaceGui:FindFirstChild("TextLabel") then
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.RequestStartDrag:FireServer(v)
wait(0.3)
v:SetPrimaryPartCFrame(w.CFrame)
task.wait(0.3)
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.RequestStopDrag:FireServer()
end
end
end
end
end
end
end
end
end
end
task.wait()
end
    end
}):AddKeyPicker("AutoSell", {
   Default = "L",
   Text = "Auto Sell",
   Mode = "Toggle",
   SyncToggleState = true
})

Main1Group:AddDropdown("ChooseStore", {
    Text = "Choose Store",
    Values = {"Item", "Mods"},
    Default = "",
    Multi = true
})

Main1Group:AddToggle("Auto Store Item", {
    Text = "Auto Store Item",
    Default = false, 
    Callback = function(Value) 
_G.StoreItem = Value
while _G.StoreItem do
for i, v in pairs(workspace.RuntimeItems:GetChildren()) do
if v.Name ~= "Rock" and v.PrimaryPart ~= nil and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude < 20 then
if Options.ChooseStore.Value["Item"] and Options.ChooseStore.Value["Mods"] then
if game.Players.LocalPlayer.Character:FindFirstChild("Sack") and game.Players.LocalPlayer.Character.Sack:FindFirstChild("BillboardGui") and game.Players.LocalPlayer.Character.Sack.BillboardGui:FindFirstChild("TextLabel") then
if game.Players.LocalPlayer.Character.Sack.BillboardGui.TextLabel.Text ~= (game.Players.LocalPlayer.Character.Sack.SackSettings:FindFirstChild("Limit").Value.."/"..game.Players.LocalPlayer.Character.Sack.SackSettings:FindFirstChild("Limit").Value) then
game:GetService("ReplicatedStorage").Remotes.StoreItem:FireServer(v)
end
end
else
if not Options.ChooseStore.Value["Item"] or v:FindFirstChild("HumanoidRootPart") == nil then
if not Options.ChooseStore.Value["Mods"] or v:FindFirstChild("HumanoidRootPart") then
if game.Players.LocalPlayer.Character:FindFirstChild("Sack") and game.Players.LocalPlayer.Character.Sack:FindFirstChild("BillboardGui") and game.Players.LocalPlayer.Character.Sack.BillboardGui:FindFirstChild("TextLabel") then
if game.Players.LocalPlayer.Character.Sack.BillboardGui.TextLabel.Text ~= (game.Players.LocalPlayer.Character.Sack.SackSettings:FindFirstChild("Limit").Value.."/"..game.Players.LocalPlayer.Character.Sack.SackSettings:FindFirstChild("Limit").Value) then
game:GetService("ReplicatedStorage").Remotes.StoreItem:FireServer(v)
end
end
end
end
end
end
end
task.wait()
end
    end
}):AddKeyPicker("AutoStore Item", {
   Default = "Y",
   Text = "Auto Store Item",
   Mode = "Toggle",
   SyncToggleState = true
})

Main1Group:AddButton("Complete Assembly Tesla", function()
if workspace:FindFirstChild("TeslaLab") and workspace.TeslaLab:FindFirstChild("ExperimentTable") then
for n, m in pairs(workspace.RuntimeItems:GetChildren()) do
if (m.Name:find("Werewolf") or m.Name == "BrainJar") and m:FindFirstChild("HumanoidRootPart") == nil and m.PrimaryPart then
repeat task.wait()
TweenWalk(m.PrimaryPart.Position)
until (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - m.PrimaryPart.Position).Magnitude < 10
wait(0.3)
if game.Players.LocalPlayer.Backpack:FindFirstChild("Sack") then
game.Players.LocalPlayer.Backpack:FindFirstChild("Sack").Parent = game.Players.LocalPlayer.Character
end
wait(0.2)
if game.Players.LocalPlayer.Character:FindFirstChild("Sack") and game.Players.LocalPlayer.Character.Sack:FindFirstChild("BillboardGui") and game.Players.LocalPlayer.Character.Sack.BillboardGui:FindFirstChild("TextLabel") then
if game.Players.LocalPlayer.Character.Sack.BillboardGui.TextLabel.Text ~= (game.Players.LocalPlayer.Character.Sack.SackSettings:FindFirstChild("Limit").Value.."/"..game.Players.LocalPlayer.Character.Sack.SackSettings:FindFirstChild("Limit").Value) then
game:GetService("ReplicatedStorage").Remotes.StoreItem:FireServer(m)
end
end
end
end
wait(0.5)
repeat task.wait()
if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
TweenWalk(workspace.TeslaLab.ExperimentTable:FindFirstChild("Hitbox").Position)
end
until (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - workspace.TeslaLab.ExperimentTable:FindFirstChild("Hitbox").Position).Magnitude < 5.6
wait(0.5)
if game.Players.LocalPlayer.Backpack:FindFirstChild("Sack") then
game.Players.LocalPlayer.Backpack:FindFirstChild("Sack").Parent = game.Players.LocalPlayer.Character
end
wait(0.2)
if game.Players.LocalPlayer.Character:FindFirstChild("Sack")  then
for i = 1, game.Players.LocalPlayer.Character.Sack.SackSettings:FindFirstChild("Limit").Value do
game:GetService("ReplicatedStorage").Remotes.DropItem:FireServer()
end
task.wait()
end
end
wait(0.7)
if workspace.TeslaLab:FindFirstChild("Generator") then
for i, v in pairs(workspace.TeslaLab.Generator:GetChildren()) do
if v.Name:find("BasePart") then
repeat task.wait()
TweenWalk(v.Position)
until (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude < 6.5
wait(0.3)
if fireproximityprompt then
fireproximityprompt(v:FindFirstChild("PowerPrompt"))
end
end
end
else
Notification("Testla don't have spawn", 5)
end
end)

local Main2Group = Tabs.Tab:AddRightGroupbox("Esp")

Main2Group:AddToggle("Train", {
    Text = "Esp Train",
    Default = false, 
    Callback = function(Value) 
_G.EspTrain = Value
if _G.EspTrain == false then
for j, v in pairs(workspace:GetChildren()) do
if v:IsA("Model") and v:FindFirstChild("RequiredComponents") then
for z, b in pairs(v:GetChildren()) do
if b.Name:find("Esp_") then
b:Destroy()
end
end
end
end
end
while _G.EspTrain do
for j, v in pairs(workspace:GetChildren()) do
if v:IsA("Model") and v:FindFirstChild("RequiredComponents") and v.RequiredComponents:FindFirstChild("Controls") then
if v:FindFirstChild("Esp_Highlight") then
	v:FindFirstChild("Esp_Highlight").FillColor = _G.ColorLight or Color3.fromRGB(255, 255, 255)
	v:FindFirstChild("Esp_Highlight").OutlineColor = _G.ColorLight or Color3.fromRGB(255, 255, 255)
end
if _G.EspHighlight == true and v:FindFirstChild("Esp_Highlight") == nil then
	local Highlight = Instance.new("Highlight")
	Highlight.Name = "Esp_Highlight"
	Highlight.FillColor = Color3.fromRGB(255, 255, 255) 
	Highlight.OutlineColor = Color3.fromRGB(255, 255, 255) 
	Highlight.FillTransparency = 0.5
	Highlight.OutlineTransparency = 0
	Highlight.Adornee = v
	Highlight.Parent = v
	elseif _G.EspHighlight == false and v:FindFirstChild("Esp_Highlight") then
	v:FindFirstChild("Esp_Highlight"):Destroy()
end
if v:FindFirstChild("Esp_Gui") and v["Esp_Gui"]:FindFirstChild("TextLabel") then
	v["Esp_Gui"]:FindFirstChild("TextLabel").Text = 
	        (_G.EspName == true and "Train" or "")..
            (_G.EspDistance == true and "\nDistance [ "..string.format("%.1f", (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.RequiredComponents.Controls.ConductorSeat:FindFirstChild("VehicleSeat").Position).Magnitude).." ]" or "")..
            (_G.EspDistanceTrain == true and " / [ "..v.RequiredComponents.Controls.DistanceDial.SurfaceGui:FindFirstChild("TextLabel").Text.." ]" or "")..
            (_G.EspTime == true and "\nTime [ "..game:GetService("ReplicatedStorage").TimeHour.Value.." ]" or "")
    v["Esp_Gui"]:FindFirstChild("TextLabel").TextSize = _G.EspGuiTextSize or 15
    v["Esp_Gui"]:FindFirstChild("TextLabel").TextColor3 = _G.EspGuiTextColor or Color3.new(255, 255, 255)
end
if _G.EspGui == true and v:FindFirstChild("Esp_Gui") == nil then
	GuiTrainEsp = Instance.new("BillboardGui", v)
	GuiTrainEsp.Adornee = v.RequiredComponents.Controls.ConductorSeat:FindFirstChild("VehicleSeat")
	GuiTrainEsp.Name = "Esp_Gui"
	GuiTrainEsp.Size = UDim2.new(0, 100, 0, 150)
	GuiTrainEsp.AlwaysOnTop = true
	GuiTrainEsp.StudsOffset = Vector3.new(0, 3, 0)
	GuiTrainEspText = Instance.new("TextLabel", GuiTrainEsp)
	GuiTrainEspText.BackgroundTransparency = 1
	GuiTrainEspText.Font = Enum.Font.Code
	GuiTrainEspText.Size = UDim2.new(0, 100, 0, 100)
	GuiTrainEspText.TextSize = 15
	GuiTrainEspText.Font = Enum.Font.Code
	GuiTrainEspText.TextColor3 = Color3.new(0,0,0) 
	GuiTrainEspText.TextStrokeTransparency = 0.5
	GuiTrainEspText.Text = ""
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.new(0, 0, 0)
	UIStroke.Thickness = 1.5
	UIStroke.Parent = GuiTrainEspText
	elseif _G.EspGui == false and v:FindFirstChild("Esp_Gui") then
	v:FindFirstChild("Esp_Gui"):Destroy()
end
end
end
task.wait()
end
    end
})

_G.EspTime = false
Main2Group:AddToggle("Esp Time", {
    Text = "Esp Time",
    Default = false, 
    Callback = function(Value) 
_G.EspTime = Value
    end
})

_G.EspDistanceTrain = false
Main2Group:AddToggle("Esp Distance Train", {
    Text = "Esp Distance (m)",
    Default = false, 
    Callback = function(Value) 
_G.EspDistanceTrain = Value
    end
})

Main2Group:AddDivider()

Main2Group:AddToggle("Ore", {
    Text = "Esp Ore",
    Default = false, 
    Callback = function(Value) 
_G.EspOrb = Value
if _G.EspOrb == false then
if game.Workspace:FindFirstChild("Ore") then
	for i, v in pairs(game.Workspace.Ore:GetChildren()) do
		if v:IsA("Model") and v.Name:find("Esp_") then
			v:Destroy()
			end
		end
	end
end
while _G.EspOrb do
if game.Workspace:FindFirstChild("Ore") then
for i, v in pairs(game.Workspace.Ore:GetChildren()) do
if v:IsA("Model") and v:FindFirstChild("Health") and v:FindFirstChild("Boulder_a") then
if v["Boulder_a"]:FindFirstChild("Esp_Highlight") then
	v["Boulder_a"]:FindFirstChild("Esp_Highlight").FillColor = _G.ColorLight or Color3.new(255, 255, 255)
	v["Boulder_a"]:FindFirstChild("Esp_Highlight").OutlineColor = _G.ColorLight or Color3.new(255, 255, 255)
end
if _G.EspHighlight == true and v["Boulder_a"]:FindFirstChild("Esp_Highlight") == nil then
	local Highlight = Instance.new("Highlight")
	Highlight.Name = "Esp_Highlight"
	Highlight.FillColor = Color3.fromRGB(255, 255, 255) 
	Highlight.OutlineColor = Color3.fromRGB(255, 255, 255) 
	Highlight.FillTransparency = 0.5
	Highlight.OutlineTransparency = 0
	Highlight.Adornee = v
	Highlight.Parent = v["Boulder_a"]
	elseif _G.EspHighlight == false and v["Boulder_a"]:FindFirstChild("Esp_Highlight") then
	v["Boulder_a"]:FindFirstChild("Esp_Highlight"):Destroy()
end
if v["Boulder_a"]:FindFirstChild("Esp_Gui") and v["Boulder_a"]["Esp_Gui"]:FindFirstChild("TextLabel") then
	v["Boulder_a"]["Esp_Gui"]:FindFirstChild("TextLabel").Text = 
	        (_G.EspName == true and v.Name or "")..
            (_G.EspDistance == true and "\nDistance [ "..string.format("%.1f", (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v["Boulder_a"].Position).Magnitude).." ]" or "")..
            (_G.EspHealth == true and "\nHealth [ "..v.Health.Value.." ]" or "")
    v["Boulder_a"]["Esp_Gui"]:FindFirstChild("TextLabel").TextSize = _G.EspGuiTextSize or 15
    v["Boulder_a"]["Esp_Gui"]:FindFirstChild("TextLabel").TextColor3 = _G.EspGuiTextColor or Color3.new(255, 255, 255)
end
if _G.EspGui == true and v["Boulder_a"]:FindFirstChild("Esp_Gui") == nil then
	GuiOreEsp = Instance.new("BillboardGui", v["Boulder_a"])
	GuiOreEsp.Adornee = v
	GuiOreEsp.Name = "Esp_Gui"
	GuiOreEsp.Size = UDim2.new(0, 100, 0, 150)
	GuiOreEsp.AlwaysOnTop = true
	GuiOreEsp.StudsOffset = Vector3.new(0, 3, 0)
	GuiOreEspText = Instance.new("TextLabel", GuiOreEsp)
	GuiOreEspText.BackgroundTransparency = 1
	GuiOreEspText.Font = Enum.Font.Code
	GuiOreEspText.Size = UDim2.new(0, 100, 0, 100)
	GuiOreEspText.TextSize = 15
	GuiOreEspText.TextColor3 = Color3.new(0,0,0) 
	GuiOreEspText.TextStrokeTransparency = 0.5
	GuiOreEspText.Text = ""
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.new(0, 0, 0)
	UIStroke.Thickness = 1.5
	UIStroke.Parent = GuiOreEspText
	elseif _G.EspGui == false and v["Boulder_a"]:FindFirstChild("Esp_Gui") then
	v["Boulder_a"]:FindFirstChild("Esp_Gui"):Destroy()
end
end
end
end
task.wait()
end
    end
})

Main2Group:AddToggle("Player", {
    Text = "Esp Player",
    Default = false, 
    Callback = function(Value) 
_G.EspPlayer = Value
if _G.EspPlayer == false then
for i, v in pairs(game.Players:GetChildren()) do
	if v.Character then
		if v.Character:FindFirstChild("Esp_Highlight") then
			v.Character:FindFirstChild("Esp_Highlight"):Destroy()
		end
		if v.Character.Head:FindFirstChild("Esp_Gui") then
			v.Character.Head:FindFirstChild("Esp_Gui"):Destroy()
		end
	end
end
end
while _G.EspPlayer do
for i, v in pairs(game.Players:GetChildren()) do
if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Head") and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") then
if v.Character:FindFirstChild("Esp_Highlight") then
	v.Character:FindFirstChild("Esp_Highlight").FillColor = _G.ColorLight or Color3.new(255, 255, 255)
	v.Character:FindFirstChild("Esp_Highlight").OutlineColor = _G.ColorLight or Color3.new(255, 255, 255)
end
if _G.EspHighlight == true and v.Character:FindFirstChild("Esp_Highlight") == nil then
	local Highlight = Instance.new("Highlight")
	Highlight.Name = "Esp_Highlight"
	Highlight.FillColor = Color3.fromRGB(255, 255, 255) 
	Highlight.OutlineColor = Color3.fromRGB(255, 255, 255) 
	Highlight.FillTransparency = 0.5
	Highlight.OutlineTransparency = 0
	Highlight.Adornee = v
	Highlight.Parent = v
	elseif _G.EspHighlight == false and v.Character:FindFirstChild("Esp_Highlight") then
	v.Character:FindFirstChild("Esp_Highlight"):Destroy()
end
if v.Character.Head:FindFirstChild("Esp_Gui") and v.Character.Head["Esp_Gui"]:FindFirstChild("TextLabel") then
	v.Character.Head["Esp_Gui"]:FindFirstChild("TextLabel").Text = 
	        (_G.EspName == true and v.Name or "")..
            (_G.EspDistance == true and "\nDistance [ "..string.format("%.1f", (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).Magnitude).." ]" or "")..
            (_G.EspHealth == true and "\nHealth [ "..(v.Character.Humanoid.Health <= 0 and "Dead" or string.format("%.1f", (v.Character.Humanoid.Health))).." ]" or "")
    v.Character.Head["Esp_Gui"]:FindFirstChild("TextLabel").TextSize = _G.EspGuiTextSize or 15
    v.Character.Head["Esp_Gui"]:FindFirstChild("TextLabel").TextColor3 = _G.EspGuiTextColor or Color3.new(255, 255, 255)
end
if _G.EspGui == true and v.Character.Head:FindFirstChild("Esp_Gui") == nil then
	GuiPlayerEsp = Instance.new("BillboardGui", v.Character.Head)
	GuiPlayerEsp.Adornee = v.Character.Head
	GuiPlayerEsp.Name = "Esp_Gui"
	GuiPlayerEsp.Size = UDim2.new(0, 100, 0, 150)
	GuiPlayerEsp.AlwaysOnTop = true
	GuiPlayerEsp.StudsOffset = Vector3.new(0, 3, 0)
	GuiPlayerEspText = Instance.new("TextLabel", GuiPlayerEsp)
	GuiPlayerEspText.BackgroundTransparency = 1
	GuiPlayerEspText.Font = Enum.Font.Code
	GuiPlayerEspText.Size = UDim2.new(0, 100, 0, 100)
	GuiPlayerEspText.TextSize = 15
	GuiPlayerEspText.TextColor3 = Color3.new(0,0,0) 
	GuiPlayerEspText.TextStrokeTransparency = 0.5
	GuiPlayerEspText.Text = ""
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.new(0, 0, 0)
	UIStroke.Thickness = 1.5
	UIStroke.Parent = GuiPlayerEspText
	elseif _G.EspGui == false and v.Character.Head:FindFirstChild("Esp_Gui") then
	v.Character.Head:FindFirstChild("Esp_Gui"):Destroy()
end
end
end
task.wait()
end
    end
})

Main2Group:AddDropdown("Item Esp", {
    Text = "Item Esp",
    Values = {"Item", "House"},
    Default = "",
    Multi = false,
    Callback = function(Value)
_G.ItemEspChoose = Value
    end
})

Main2Group:AddToggle("Item", {
    Text = "Esp Item",
    Default = false, 
    Callback = function(Value) 
_G.EspItem = Value
if _G.EspItem == false then
for i, v in pairs(workspace:FindFirstChild("RuntimeItems"):GetChildren()) do
	if v.ClassName == "Model" then
		if v:FindFirstChild("Esp_Highlight") then
			v:FindFirstChild("Esp_Highlight"):Destroy()
		end
		if v:FindFirstChild("Esp_Gui") then
			v:FindFirstChild("Esp_Gui"):Destroy()
		end
	end
end
for i, v in pairs(workspace:FindFirstChild("RandomBuildings"):GetChildren()) do
	if v.ClassName == "Model" then
		if v:FindFirstChild("Esp_Gui") then
			v:FindFirstChild("Esp_Gui"):Destroy()
		end
	end
end
end
while _G.EspItem do
for i, v in pairs(workspace:FindFirstChild("RandomBuildings"):GetChildren()) do
if v.ClassName == "Model" then
if _G.ItemEspChoose == "House" then
if v:FindFirstChild("Esp_Gui") and v["Esp_Gui"]:FindFirstChild("TextLabel") then
	v["Esp_Gui"]:FindFirstChild("TextLabel").Text = 
	        (_G.EspName == true and y.Name:gsub("Model_", "") or "")..
	        (_G.EspDistance == true and v.PrimaryPart and "\nDistance [ "..string.format("%.1f", (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude).." ]" or "")
    v["Esp_Gui"]:FindFirstChild("TextLabel").TextSize = _G.EspGuiTextSize or 15
    v["Esp_Gui"]:FindFirstChild("TextLabel").TextColor3 = _G.EspGuiTextColor or Color3.new(255, 255, 255)
end
if _G.EspGui == true and v:FindFirstChild("Esp_Gui") == nil then
	GuiItemEsp = Instance.new("BillboardGui", v)
	GuiItemEsp.Adornee = v
	GuiItemEsp.Name = "Esp_Gui"
	GuiItemEsp.Size = UDim2.new(0, 100, 0, 150)
	GuiItemEsp.AlwaysOnTop = true
	GuiItemEspText = Instance.new("TextLabel", GuiItemEsp)
	GuiItemEspText.BackgroundTransparency = 1
	GuiItemEspText.Font = Enum.Font.Code
	GuiItemEspText.Size = UDim2.new(0, 100, 0, 100)
	GuiItemEspText.TextSize = 15
	GuiItemEspText.TextColor3 = Color3.new(0,0,0) 
	GuiItemEspText.TextStrokeTransparency = 0.5
	GuiItemEspText.Text = ""
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.new(0, 0, 0)
	UIStroke.Thickness = 1.5
	UIStroke.Parent = GuiItemEspText
	elseif _G.EspGui == false and v:FindFirstChild("Esp_Gui") then
	v:FindFirstChild("Esp_Gui"):Destroy()
end
elseif _G.ItemEspChoose ~= "House" then
if v:FindFirstChild("Esp_Gui") then
v:FindFirstChild("Esp_Gui"):Destroy()
end
end
end
end
for i, v in pairs(workspace:FindFirstChild("RuntimeItems"):GetChildren()) do
if v.ClassName == "Model" then
if _G.ItemEspChoose == "Item" then
if v:FindFirstChild("Esp_Highlight") then
	v:FindFirstChild("Esp_Highlight").FillColor = _G.ColorLight or Color3.new(255, 255, 255)
	v:FindFirstChild("Esp_Highlight").OutlineColor = _G.ColorLight or Color3.new(255, 255, 255)
end
if _G.EspHighlight == true and v:FindFirstChild("Esp_Highlight") == nil then
	local Highlight = Instance.new("Highlight")
	Highlight.Name = "Esp_Highlight"
	Highlight.FillColor = Color3.fromRGB(255, 255, 255) 
	Highlight.OutlineColor = Color3.fromRGB(255, 255, 255) 
	Highlight.FillTransparency = 0.5
	Highlight.OutlineTransparency = 0
	Highlight.Adornee = v
	Highlight.Parent = v
	elseif _G.EspHighlight == false and v:FindFirstChild("Esp_Highlight") then
	v:FindFirstChild("Esp_Highlight"):Destroy()
end
if v:FindFirstChild("Esp_Gui") and v["Esp_Gui"]:FindFirstChild("TextLabel") then
	v["Esp_Gui"]:FindFirstChild("TextLabel").Text = 
			(_G.EspFuel == true and v:GetAttribute("Fuel") and "Fuel [ "..v:GetAttribute("Fuel").." ]" or "")..
	        (_G.EspName == true and "\n"..v.Name:gsub("Model_", "")..(_G.EspMoney == true and (v:GetAttribute("Value") or v:GetAttribute("Bounty")) and " ($"..(v:GetAttribute("Value") or v:GetAttribute("Bounty"))..")" or "") or "")..
	        (_G.EspDistance == true and v.PrimaryPart and "\nDistance [ "..string.format("%.1f", (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude).." ]" or "")
    v["Esp_Gui"]:FindFirstChild("TextLabel").TextSize = _G.EspGuiTextSize or 15
    v["Esp_Gui"]:FindFirstChild("TextLabel").TextColor3 = _G.EspGuiTextColor or Color3.new(255, 255, 255)
end
if _G.EspGui == true and v:FindFirstChild("Esp_Gui") == nil then
	GuiItemEsp = Instance.new("BillboardGui", v)
	GuiItemEsp.Adornee = v
	GuiItemEsp.Name = "Esp_Gui"
	GuiItemEsp.Size = UDim2.new(0, 100, 0, 150)
	GuiItemEsp.AlwaysOnTop = true
	GuiItemEsp.StudsOffset = Vector3.new(0, 2, 0)
	GuiItemEspText = Instance.new("TextLabel", GuiItemEsp)
	GuiItemEspText.BackgroundTransparency = 1
	GuiItemEspText.Font = Enum.Font.Code
	GuiItemEspText.Size = UDim2.new(0, 100, 0, 100)
	GuiItemEspText.TextSize = 15
	GuiItemEspText.TextColor3 = Color3.new(0,0,0) 
	GuiItemEspText.TextStrokeTransparency = 0.5
	GuiItemEspText.Text = ""
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.new(0, 0, 0)
	UIStroke.Thickness = 1.5
	UIStroke.Parent = GuiItemEspText
	elseif _G.EspGui == false and v:FindFirstChild("Esp_Gui") then
	v:FindFirstChild("Esp_Gui"):Destroy()
end
elseif _G.ItemEspChoose ~= "Item" then
if v:FindFirstChild("Esp_Highlight") then
v:FindFirstChild("Esp_Highlight"):Destroy()
end
if v:FindFirstChild("Esp_Gui") then
v:FindFirstChild("Esp_Gui"):Destroy()
end
end
end
end
task.wait()
end
    end
})

_G.EspMoney = false
Main2Group:AddToggle("Esp Money", {
    Text = "Esp Money",
    Default = false, 
    Callback = function(Value) 
_G.EspMoney = Value
    end
})

_G.EspFuel = false
Main2Group:AddToggle("Esp Fuel", {
    Text = "Esp Fuel",
    Default = false, 
    Callback = function(Value) 
_G.EspFuel = Value
    end
})

Main2Group:AddDivider()

_G.EspModsAntilag = {}
workspace.DescendantAdded:Connect(function(v)
	if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") and not game.Players:GetPlayerFromCharacter(v) then
	    if v.Humanoid.Health > 0 then
	        table.insert(_G.EspModsAntilag, v)
		end
	end
end)
Main2Group:AddToggle("Mods", {
    Text = "Esp Mods",
    Default = false, 
    Callback = function(Value) 
_G.EspMods = Value
if _G.EspMods == false then
_G.EspModsAntilag = {}
for i, v in pairs(workspace:GetDescendants()) do
    if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") and not game.Players:GetPlayerFromCharacter(v) then
        if v:FindFirstChild("Esp_Highlight") then
              v:FindFirstChild("Esp_Highlight"):Destroy()
           end
			if v:FindFirstChild("HumanoidRootPart") and v.HumanoidRootPart:FindFirstChild("Esp_Gui") then
				v.HumanoidRootPart:FindFirstChild("Esp_Gui"):Destroy()
			end
        end
    end
else
_G.EspModsAntilag = {}
for i, v in pairs(workspace:GetDescendants()) do
    if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") and not game.Players:GetPlayerFromCharacter(v) then
	    if v.Humanoid.Health > 0 then
	        table.insert(_G.EspModsAntilag, v)
		end
	end
end
end
while _G.EspMods do
for i, y in pairs(_G.EspModsAntilag) do
if y:FindFirstChild("HumanoidRootPart") and y:FindFirstChild("Humanoid") then
if y.Humanoid.Health > 0 then
if y:FindFirstChild("Esp_Highlight") then
	y:FindFirstChild("Esp_Highlight").FillColor = _G.ColorLight or Color3.fromRGB(255, 255, 255)
	y:FindFirstChild("Esp_Highlight").OutlineColor = _G.ColorLight or Color3.fromRGB(255, 255, 255)
end
if _G.EspHighlight == true and y:FindFirstChild("Esp_Highlight") == nil then
	local Highlight = Instance.new("Highlight")
	Highlight.Name = "Esp_Highlight"
	Highlight.FillColor = Color3.fromRGB(255, 255, 255) 
	Highlight.OutlineColor = Color3.fromRGB(255, 255, 255) 
	Highlight.FillTransparency = 0.5
	Highlight.OutlineTransparency = 0
	Highlight.Adornee = y
	Highlight.Parent = y
	elseif _G.EspHighlight == false and y:FindFirstChild("Esp_Highlight") then
	y:FindFirstChild("Esp_Highlight"):Destroy()
end
if y.HumanoidRootPart:FindFirstChild("Esp_Gui") and y.HumanoidRootPart["Esp_Gui"]:FindFirstChild("TextLabel") then
	y.HumanoidRootPart["Esp_Gui"]:FindFirstChild("TextLabel").Text = 
	        (_G.EspName == true and y.Name:gsub("Model_", "") or "")..
            (_G.EspDistance == true and "\nDistance [ "..string.format("%.1f", (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - y.HumanoidRootPart.Position).Magnitude).." ]" or "")..
            (_G.EspHealth == true and "\nHealth [ "..string.format("%.0f", (y.Humanoid.Health)).." ]" or "")
    y.HumanoidRootPart["Esp_Gui"]:FindFirstChild("TextLabel").TextSize = _G.EspGuiTextSize or 15
    y.HumanoidRootPart["Esp_Gui"]:FindFirstChild("TextLabel").TextColor3 = _G.EspGuiTextColor or Color3.new(255, 255, 255)
end
if _G.EspGui == true and y.HumanoidRootPart:FindFirstChild("Esp_Gui") == nil then
	GuiModsEsp = Instance.new("BillboardGui", y.HumanoidRootPart)
	GuiModsEsp.Adornee = y.HumanoidRootPart
	GuiModsEsp.Name = "Esp_Gui"
	GuiModsEsp.Size = UDim2.new(0, 100, 0, 150)
	GuiModsEsp.AlwaysOnTop = true
	GuiModsEsp.StudsOffset = Vector3.new(0, 2, 0)
	GuiModsEspText = Instance.new("TextLabel", GuiModsEsp)
	GuiModsEspText.BackgroundTransparency = 1
	GuiModsEspText.Font = Enum.Font.Code
	GuiModsEspText.Size = UDim2.new(0, 100, 0, 100)
	GuiModsEspText.TextSize = 15
	GuiModsEspText.TextColor3 = Color3.new(0,0,0) 
	GuiModsEspText.TextStrokeTransparency = 0.5
	GuiModsEspText.Text = ""
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.new(0, 0, 0)
	UIStroke.Thickness = 1.5
	UIStroke.Parent = GuiModsEspText
	elseif _G.EspGui == false and y.HumanoidRootPart:FindFirstChild("Esp_Gui") then
	y.HumanoidRootPart:FindFirstChild("Esp_Gui"):Destroy()
end
end
end
if y:FindFirstChild("HumanoidRootPart") == nil or y:FindFirstChild("Humanoid") and y.Humanoid.Health <= 0 then
for i, v in pairs(workspace:GetDescendants()) do
    if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") and not game.Players:GetPlayerFromCharacter(v) then
        if v:FindFirstChild("Esp_Highlight") then
              v:FindFirstChild("Esp_Highlight"):Destroy()
           end
			if v:FindFirstChild("HumanoidRootPart") and v.HumanoidRootPart:FindFirstChild("Esp_Gui") then
				v.HumanoidRootPart:FindFirstChild("Esp_Gui"):Destroy()
			end
        end
    end
for i = #_G.EspModsAntilag, 1, -1 do
	if _G.EspModsAntilag[i] == y then
		table.remove(_G.EspModsAntilag, i)
	end
end
end
end
task.wait()
end
    end
})

function BankEsp(a)
if a:FindFirstChild("Vault") and a.Vault:FindFirstChild("Union") then
if a.Vault.Union:FindFirstChild("Esp_Highlight") then
	a.Vault.Union:FindFirstChild("Esp_Highlight").FillColor = _G.ColorLight or Color3.fromRGB(255, 255, 255)
	a.Vault.Union:FindFirstChild("Esp_Highlight").OutlineColor = _G.ColorLight or Color3.fromRGB(255, 255, 255)
end
if _G.EspHighlight == true and a.Vault.Union:FindFirstChild("Esp_Highlight") == nil then
	local Highlight = Instance.new("Highlight")
	Highlight.Name = "Esp_Highlight"
	Highlight.FillColor = Color3.fromRGB(255, 255, 255) 
	Highlight.OutlineColor = Color3.fromRGB(255, 255, 255) 
	Highlight.FillTransparency = 0.5
	Highlight.OutlineTransparency = 0
	Highlight.Adornee = a.Vault.Union
	Highlight.Parent = a.Vault.Union
	elseif _G.EspHighlight == false and a.Vault.Union:FindFirstChild("Esp_Highlight") then
	a.Vault.Union:FindFirstChild("Esp_Highlight"):Destroy()
end
if a.Vault.Union:FindFirstChild("Esp_Gui") and a.Vault.Union["Esp_Gui"]:FindFirstChild("TextLabel") then
	a.Vault.Union["Esp_Gui"]:FindFirstChild("TextLabel").Text = "Bank | "..a.Vault:FindFirstChild("Combination").Value..
            (_G.EspDistance == true and "\nDistance [ "..string.format("%.1f", (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Vault.Union.Position).Magnitude).." ]" or "")
    a.Vault.Union["Esp_Gui"]:FindFirstChild("TextLabel").TextSize = _G.EspGuiTextSize or 15
    a.Vault.Union["Esp_Gui"]:FindFirstChild("TextLabel").TextColor3 = _G.EspGuiTextColor or Color3.new(255, 255, 255)
end
if _G.EspGui == true and a.Vault.Union:FindFirstChild("Esp_Gui") == nil then
	GuiBankEsp = Instance.new("BillboardGui", a.Vault.Union)
	GuiBankEsp.Adornee = a.Vault.Union
	GuiBankEsp.Name = "Esp_Gui"
	GuiBankEsp.Size = UDim2.new(0, 10, 0, 10)
	GuiBankEsp.AlwaysOnTop = true
	GuiBankEsp.StudsOffset = Vector3.new(0, 3, 0)
	GuiBankEspText = Instance.new("TextLabel", GuiBankEsp)
	GuiBankEspText.BackgroundTransparency = 1
	GuiBankEspText.Font = Enum.Font.Code
	GuiBankEspText.Size = UDim2.new(1, 0, 1, 0)
	GuiBankEspText.TextSize = 15
	GuiBankEspText.TextColor3 = Color3.new(0,0,0) 
	GuiBankEspText.TextStrokeTransparency = 0.5
	GuiBankEspText.Text = ""
	local UIStroke = Instance.new("UIStroke")
	UIStroke.Color = Color3.new(0, 0, 0)
	UIStroke.Thickness = 1.5
	UIStroke.Parent = GuiBankEspText
	elseif _G.EspGui == false and a.Vault.Union:FindFirstChild("Esp_Gui") then
	a.Vault.Union:FindFirstChild("Esp_Gui"):Destroy()
end
end
end
Main2Group:AddToggle("Bank", {
    Text = "Esp Bank / Code",
    Default = false, 
    Callback = function(Value) 
_G.EspBank = Value
if _G.EspBank == false then
if game.Workspace:FindFirstChild("Towns") then
	for i, v in pairs(game.Workspace.Towns:GetChildren()) do
		if v:IsA("Model") and v:FindFirstChild("Buildings") then
			for e, a in pairs(v.Buildings:GetChildren()) do
				if a.Name:find("Bank") and a:FindFirstChild("Vault") and a.Vault:FindFirstChild("Union") then
					for x, j in pairs(v.Vault:FindFirstChild("Union"):GetChildren()) do
						if j.Name:find("Esp_") then
							j:Destroy()
						end
					end
				end
			end
		end
	end
end
if game.Workspace:FindFirstChild("Sterling") then
	for i, v in pairs(game.Workspace.Sterling:GetChildren()) do
		if v.Name == "Town" and v:FindFirstChild("Buildings") then
			for e, a in pairs(v.Buildings:GetChildren()) do
				if a.Name:find("Bank") and a:FindFirstChild("Vault") and a.Vault:FindFirstChild("Union") then
					for x, j in pairs(v.Vault:FindFirstChild("Union"):GetChildren()) do
						if j.Name:find("Esp_") then
							j:Destroy()
						end
					end
				end
			end
		end
	end
end
end
while _G.EspBank do
if game.Workspace:FindFirstChild("Towns") then
for i, v in pairs(game.Workspace.Towns:GetChildren()) do
if v:IsA("Model") and v:FindFirstChild("Buildings") then
for e, a in pairs(v.Buildings:GetChildren()) do
if a.Name:find("Bank") and a:FindFirstChild("Vault") and a.Vault:FindFirstChild("Union") then
BankEsp(a)
end
end
end
end
end
if game.Workspace:FindFirstChild("Sterling") then
for i, v in pairs(game.Workspace.Sterling:GetChildren()) do
if v.Name == "Town" and v:FindFirstChild("Buildings") then
for e, a in pairs(v.Buildings:GetChildren()) do
if a.Name:find("Bank") and a:FindFirstChild("Vault") and a.Vault:FindFirstChild("Union") then
BankEsp(a)
end
end
end
end
end
task.wait()
end
    end
})

Main2Group:AddDivider()

_G.EspHighlight = false
Main2Group:AddToggle("Esp Hight Light", {
    Text = "Esp Hight Light",
    Default = false, 
    Callback = function(Value) 
_G.EspHighlight = Value
    end
}):AddColorPicker("Color Esp", {
     Default = Color3.new(255,255,255),
     Callback = function(Value)
_G.ColorLight = Value
     end
})

_G.EspGui = false
Main2Group:AddToggle("Esp Gui", {
    Text = "Esp Gui",
    Default = false, 
    Callback = function(Value) 
_G.EspGui = Value
    end
}):AddColorPicker("Color Esp Text", {
     Default = Color3.new(255,255,255),
     Callback = function(Value)
_G.EspGuiTextColor = Value
     end
})

Main2Group:AddSlider("Text Size", {
    Text = "Text Size [ Gui ]",
    Default = 7,
    Min = 7,
    Max = 50,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
_G.EspGuiTextSize = Value
    end
})

Main2Group:AddDivider()

_G.EspName = false
Main2Group:AddToggle("Esp Name", {
    Text = "Esp Name",
    Default = false, 
    Callback = function(Value) 
_G.EspName = Value
    end
})

_G.EspDistance = false
Main2Group:AddToggle("Esp Distance", {
    Text = "Esp Distance",
    Default = false, 
    Callback = function(Value) 
_G.EspDistance = Value
    end
})

_G.EspHealth = false
Main2Group:AddToggle("Esp Health", {
    Text = "Esp Health",
    Default = false, 
    Callback = function(Value) 
_G.EspHealth = Value
    end
})

local Misc1Group = Tabs.Tab1:AddLeftGroupbox("Misc")

_G.GetOldBright = {
	Brightness = game.Lighting.Brightness,
	ClockTime = game.Lighting.ClockTime,
	FogEnd = game.Lighting.FogEnd,
	GlobalShadows = game.Lighting.GlobalShadows,
	OutdoorAmbient = game.Lighting.OutdoorAmbient
}
Misc1Group:AddToggle("Full Bright", {
    Text = "Full Bright",
    Default = false, 
    Callback = function(Value) 
_G.FullBright = Value
while _G.FullBright do
game.Lighting.Brightness = 2
game.Lighting.ClockTime = 14
game.Lighting.FogEnd = 100000
game.Lighting.GlobalShadows = false
game.Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
task.wait()
end
for i, v in pairs(_G.GetOldBright) do
game.Lighting[i] = v
end
    end
})

Misc1Group:AddToggle("No Fog", {
    Text = "No Fog",
    Default = false, 
    Callback = function(Value) 
_G.Nofog = Value
while _G.Nofog do
game:GetService("Lighting").FogStart = 100000
game:GetService("Lighting").FogEnd = 200000
for i, v in pairs(game:GetService("Lighting"):GetChildren()) do
if v.ClassName == "Atmosphere" then
v.Density = 0
v.Haze = 0
end
end
task.wait()
end
game:GetService("Lighting").FogStart = 0
game:GetService("Lighting").FogEnd = 1000
for i, v in pairs(game:GetService("Lighting"):GetChildren()) do
if v.ClassName == "Atmosphere" then
v.Density = 0.3
v.Haze = 1
end
end
    end
})

Misc1Group:AddToggle("Noclip", {
    Text = "Noclip",
    Default = false, 
    Callback = function(Value) 
_G.NoclipCharacter = Value
if _G.NoclipCharacter == false then
	if game.Players.LocalPlayer.Character ~= nil then
		for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
			if v:IsA("BasePart") and v.CanCollide == false then
				v.CanCollide = true
			end
		end
	end
end
while _G.NoclipCharacter do
if game.Players.LocalPlayer.Character ~= nil then
		for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
			if v:IsA("BasePart") and v.CanCollide == true then
				v.CanCollide = false
			end
		end
	end
task.wait()
end
    end
}):AddKeyPicker("NoclipCharacter", {
   Default = "G",
   Text = "Noclip",
   Mode = "Toggle",
   SyncToggleState = true
})

Misc1Group:AddDropdown("ChooseCollect", {
    Text = "Choose Collect",
    Values = {"Money", "Snake Oil", "Bandage", "Bond", "Ammo", "Holy Water", "Gun", "Molotov", "Melee"},
    Default = "",
    Multi = true
})

Misc1Group:AddToggle("Auto Collect", {
    Text = "Auto Collect",
    Default = false, 
    Callback = function(Value) 
_G.CollectAuto = Value
while _G.CollectAuto do
for i, v in pairs(workspace:FindFirstChild("RuntimeItems"):GetChildren()) do
if Options.ChooseCollect.Value["Money"] then
if v.Name == "Moneybag" and v:FindFirstChild("MoneyBag") and v.MoneyBag:FindFirstChild("CollectPrompt") then
if 50 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v:FindFirstChild("MoneyBag").Position).Magnitude then
v.MoneyBag:FindFirstChild("CollectPrompt").HoldDuration = 0
if fireproximityprompt then
fireproximityprompt(v.MoneyBag:FindFirstChild("CollectPrompt"))
end
end
end
end
if Options.ChooseCollect.Value["Snake Oil"] then
if v.Name == "Snake Oil" then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Remotes.Tool.PickUpTool:FireServer(v)
end
end
end
if Options.ChooseCollect.Value["Bandage"] then
if v.Name == "Bandage" then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Remotes.Tool.PickUpTool:FireServer(v)
end
end
end
end
if Options.ChooseCollect.Value["Bond"] then
if v.Name:find("Bond") then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Shared.Network.RemotePromise.Remotes.C_ActivateObject:FireServer(v)
end
end
end
end
if Options.ChooseCollect.Value["Ammo"] then
if v.Name:find("Ammo") or v.Name:find("Shells") then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Shared.Network.RemotePromise.Remotes.C_ActivateObject:FireServer(v)
end
end
end
end
if Options.ChooseCollect.Value["Holy Water"] then
if v.Name == "Holy Water" then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Remotes.Tool.PickUpTool:FireServer(v)
end
end
end
end
if Options.ChooseCollect.Value["Molotov"] then
if v.Name == "Molotov" then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Remotes.Tool.PickUpTool:FireServer(v)
end
end
end
end
if Options.ChooseCollect.Value["Gun"] then
if v:FindFirstChild("ServerWeaponState") then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Remotes.Tool.PickUpTool:FireServer(v)
end
end
elseif v:FindFirstChild("ObjectInfo") then
for h, m in pairs(v.ObjectInfo:GetChildren()) do
if m.Name == "TextLabel" and m.Text == "Gun" then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Remotes.Tool.PickUpTool:FireServer(v)
end
end
end
end
end
end
if Options.ChooseCollect.Value["Melee"] then
if v:FindFirstChild("ObjectInfo") then
for h, m in pairs(v.ObjectInfo:GetChildren()) do
if m.Name == "TextLabel" and m.Text == "Melee" then
for c, a in pairs(v:GetChildren()) do
if a:IsA("BasePart") and 20 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - a.Position).Magnitude then
game:GetService("ReplicatedStorage").Remotes.Tool.PickUpTool:FireServer(v)
end
end
end
end
end
end
end
end
task.wait()
end
    end
})

v2 = require(game:GetService("ReplicatedStorage").Shared.Remotes)
Misc1Group:AddToggle("Banjo", {
    Text = "Auto Banjo Heal",
    Default = false, 
    Tooltip = "Class Music",
    Callback = function(Value) 
_G.BanjoHeal = Value
while _G.BanjoHeal do
for i, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
if v.Name == "Banjo" then
v.Parent = game.Players.LocalPlayer.Character
end
end
for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
if v.Name == "Banjo" then
v2.Events.PlayBanjo:FireServer(v, 1)
end
end
task.wait()
end
    end
})

Misc1Group:AddToggle("NotificationUnicorn", {
    Text = "Notification Unicorn",
    Default = false, 
    Callback = function(Value) 
_G.NotificationUnicorn = Value
if _G.NotificationUnicorn == false then
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") and v.Name == "Unicorn" and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Esp_Unicorn") or v:FindFirstChild("Esp_UnicornGui") and not game.Players:GetPlayerFromCharacter(v) then
v:FindFirstChild("Esp_Unicorn"):Destroy()
v:FindFirstChild("Esp_UnicornGui"):Destroy()
end
end
if NotificationUnicornGet then
NotificationUnicornGet:Disconnect()
NotificationUnicornGet = nil
end
elseif _G.NotificationUnicorn == true then
spawn(function()
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") and v.Name:find("Unicorn") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Esp_Unicorn") and not game.Players:GetPlayerFromCharacter(v) then
if v:FindFirstChild("Esp_Unicorn") == nil or v:FindFirstChild("Esp_UnicornGui") == nil then
if v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 then
Notification("Unicorn Spawn / Health [ "..v.Humanoid.Health.." ]", 7)
else
Notification("Unicorn Spawn [ Dead ]", 7)
end
repeat task.wait() 
if v:FindFirstChild("Esp_UnicornGui") == nil then
GuiItemEsp = Instance.new("BillboardGui", v)
GuiItemEsp.Adornee = v
GuiItemEsp.Name = "Esp_UnicornGui"
GuiItemEsp.Size = UDim2.new(0, 50, 0, 50)
GuiItemEsp.AlwaysOnTop = true
GuiItemEsp.StudsOffset = Vector3.new(0, 3, 0)
GuiItemEspFrame = Instance.new("Frame", GuiItemEsp)
GuiItemEspFrame.BackgroundTransparency = 1
GuiItemEspFrame.Size = UDim2.new(1, 0, 1, 0)
local GuiItemUICorner = Instance.new("UICorner")
GuiItemUICorner.CornerRadius = UDim.new(2, 0)
GuiItemUICorner.Parent = GuiItemEspFrame
local GuiItemUIStroke = Instance.new("UIStroke")
GuiItemUIStroke.Color = Color3.fromRGB(0, 255, 0)
GuiItemUIStroke.Thickness = 2
GuiItemUIStroke.Parent = GuiItemEspFrame
end
if v:FindFirstChild("Esp_Unicorn") == nil then
local Highlight = Instance.new("Highlight")
Highlight.Name = "Esp_Unicorn"
Highlight.FillColor = Color3.fromRGB(0, 255, 0)
Highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
Highlight.FillTransparency = 0.5
Highlight.OutlineTransparency = 0
Highlight.Adornee = v
Highlight.Parent = v
end
until _G.NotificationUnicorn == false or v:FindFirstChild("HumanoidRootPart") == nil or v:FindFirstChild("Humanoid") and v.Humanoid.Health <= 0
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") and v.Name == "Unicorn" and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Esp_Unicorn") and v:FindFirstChild("Esp_UnicornGui") and not game.Players:GetPlayerFromCharacter(v) then
v:FindFirstChild("Esp_Unicorn"):Destroy()
v:FindFirstChild("Esp_UnicornGui"):Destroy()
end
end
end
end
end
end)
NotificationUnicornGet = workspace.DescendantAdded:Connect(function(v)
if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and not game.Players:GetPlayerFromCharacter(v) then
if v.Name:find("Unicorn") then
if v:FindFirstChild("Esp_Unicorn") == nil or v:FindFirstChild("Esp_UnicornGui") == nil then
if v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 then
Notification("Unicorn Spawn / Health [ "..v.Humanoid.Health.." ]", 7)
else
Notification("Unicorn Spawn [ Dead ]", 7)
end
repeat task.wait() 
if v:FindFirstChild("Esp_UnicornGui") == nil then
GuiItemEsp = Instance.new("BillboardGui", v)
GuiItemEsp.Adornee = v
GuiItemEsp.Name = "Esp_UnicornGui"
GuiItemEsp.Size = UDim2.new(0, 50, 0, 50)
GuiItemEsp.AlwaysOnTop = true
GuiItemEspFrame = Instance.new("Frame", GuiItemEsp)
GuiItemEspFrame.BackgroundTransparency = 1
GuiItemEspFrame.Size = UDim2.new(1, 0, 1, 0)
local GuiItemUICorner = Instance.new("UICorner")
GuiItemUICorner.CornerRadius = UDim.new(2, 0)
GuiItemUICorner.Parent = GuiItemEspFrame
local GuiItemUIStroke = Instance.new("UIStroke")
GuiItemUIStroke.Color = Color3.fromRGB(0, 255, 0)
GuiItemUIStroke.Thickness = 2
GuiItemUIStroke.Parent = GuiItemEspFrame
end
if v:FindFirstChild("Esp_Unicorn") == nil then
local Highlight = Instance.new("Highlight")
Highlight.Name = "Esp_Unicorn"
Highlight.FillColor = Color3.fromRGB(0, 255, 0)
Highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
Highlight.FillTransparency = 0.5
Highlight.OutlineTransparency = 0
Highlight.Adornee = v
Highlight.Parent = v
end
until _G.NotificationUnicorn == false or v:FindFirstChild("HumanoidRootPart") == nil or v:FindFirstChild("Humanoid") and v.Humanoid.Health <= 0
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") and v.Name == "Unicorn" and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Esp_Unicorn") and v:FindFirstChild("Esp_UnicornGui") and not game.Players:GetPlayerFromCharacter(v) then
v:FindFirstChild("Esp_Unicorn"):Destroy()
v:FindFirstChild("Esp_UnicornGui"):Destroy()
end
end
end
end
end
end)
end
    end
})

Misc1Group:AddDropdown("Spawn Notification", {
    Text = "Spawn Notification",
    Values = {"Sterling", "Tesla", "Stillwater Prison", "Fort Constitution"},
    Default = "",
    Multi = true
})

function NotifySpawn(v)
if Options["Spawn Notification"].Value["Sterling"] and v.Name == "Sterling" then
Notification("Spawn Sterling", 7)
end
if Options["Spawn Notification"].Value["Tesla"] and v.Name == "TeslaLab" then
if v:FindFirstChild("ExperimentTable") then
Notification("Spawn TeslaLab", 7)
end
end
if Options["Spawn Notification"].Value["Stillwater Prison"] and v.Name == "StillwaterPrison" then
Notification("Spawn Stillwater Prison", 7)
end
if Options["Spawn Notification"].Value["Fort Constitution"] and v.Name == "FortConstitution" then
Notification("Spawn Fort Constitution", 7)
end
end
Misc1Group:AddToggle("NotificationSpawn", {
    Text = "Notification Spawn",
    Default = false, 
    Callback = function(Value) 
_G.NotificationSpawn = Value
if _G.NotificationSpawn == false then
if NotificationSpawnGet then
NotificationSpawnGet:Disconnect()
NotificationSpawnGet = nil
end
elseif _G.NotificationSpawn == true then
for i, v in pairs(workspace:GetChildren()) do
NotifySpawn(v)
end
NotificationSpawnGet = workspace.ChildAdded:Connect(function(v)
NotifySpawn(v)
end)
end
    end
})

Misc1Group:AddToggle("WalkSpeed", {
    Text = "WalkSpeed",
    Default = false, 
    Callback = function(Value) 
_G.WalkSpeed = Value
if _G.WalkSpeed == false then
if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
end
end
while _G.WalkSpeed do
if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16.5
wait(6.5)
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 18.5
end
task.wait(6.7)
end
    end
})

local Misc2Group = Tabs.Tab1:AddRightGroupbox("Combat")

Misc2Group:AddToggle("Show Health Bar Mods", {
    Text = "Show Health Bar Mods",
    Default = false, 
    Callback = function(Value) 
_G.HealthBarMods = Value
if game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Enabled = false
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = "Nah Health: Nil"
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(1, 0, 1, 0)
end
    end
})

Misc2Group:AddDropdown("CharacterMods", {
    Text = "Character Mods",
    Values = {"Head", "HumanoidRootPart"},
    Default = "",
    Multi = false,
    Callback = function(Value)
_G.CharacterMods = Value
    end
})

Misc2Group:AddDropdown("NoMods", {
    Text = "No Mods",
    Values = {"Horse", "Wolf", "Werewolf"},
    Default = "",
    Multi = true
})

Misc2Group:AddDropdown("CharacterMods", {
    Text = "Attack Melee",
    Values = {"Charge", "Attack Fast", "Ustal Kill Lag", "Ustal Kill No Lag"},
    Default = "",
    Multi = false,
    Callback = function(Value)
_G.MeleeAttack = Value
    end
})

Misc2Group:AddToggle("Auto Attack Melee", {
    Text = "Auto Attack Melee",
    Default = false, 
    Callback = function(Value) 
_G.AutoAttackMelee = Value
while _G.AutoAttackMelee do
if _G.MeleeAttack == "Attack Fast" then
for i, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
if v:IsA("Tool") and v:FindFirstChild("Configuration") and v.Configuration:FindFirstChild("Animations") and v.Configuration.Animations:FindFirstChild("SwingAnimation") then
v.Parent = game.Players.LocalPlayer.Character
end
end
end
for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
if v:IsA("Tool") and v:FindFirstChild("Configuration") and v.Configuration:FindFirstChild("Animations") and v.Configuration.Animations:FindFirstChild("SwingAnimation") then
if _G.MeleeAttack == "Attack Fast" then
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.ChargeMelee:FireServer(v, 1747454200.211104)
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.SwingMelee:FireServer(v, 1747454200.211104, Vector3.new(-0.998392641544342, 0.001820647856220603, 0.05664642155170441))
elseif _G.MeleeAttack == "Charge" then
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.ChargeMelee:FireServer(v, 1747454200.211104)
elseif _G.MeleeAttack:find("Ustal Kill") then
for i = 1, 12 do
for u = 1, (_G.MeleeAttack == "Ustal Kill No Lag" and 150 or 300) do
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.ChargeMelee:FireServer(v, 1747454200.211104)
game:GetService("ReplicatedStorage").Shared.Network.RemoteEvent.SwingMelee:FireServer(v, 1747454200.211104, Vector3.new(-0.998392641544342, 0.001820647856220603, 0.05664642155170441))
end
end
end
end
end
task.wait()
end
    end
}):AddKeyPicker("AttackMelee", {
   Default = "U",
   Text = "Auto Attack Melee",
   Mode = "Toggle",
   SyncToggleState = true
})

Misc2Group:AddDropdown("GunFastAura", {
    Text = "Gun Aura",
    Values = {"Fast", "Normal"},
    Default = "",
    Multi = false,
    Callback = function(Value)
_G.GunAuraKillSkib = Value
    end
})

Misc2Group:AddSlider("Delay Shot", {
    Text = "Delay Shot",
    Default = 0.25,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
_G.DelayShot = Value
    end
})

Misc2Group:AddSlider("Reach Shot", {
    Text = "Reach Shot",
    Default = 250,
    Min = 10,
    Max = 300,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
_G.ReachShot = Value
    end
})

_G.ModsAntilag = {
	GunAura = {},
	Aimbot = {},
	Camlock = {},
	Hitbox = {},
	EatHeal = {}
}
function Checkmods(v)
	if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") and v:FindFirstChild("Head") and not game.Players:GetPlayerFromCharacter(v) then
	    if v.Humanoid.Health > 0 then
			for i, v1 in pairs(_G.ModsAntilag) do
				if i ~= "EatHeal" then
			        table.insert(_G.ModsAntilag[i], v)
				end
			end
		elseif v.Humanoid.Health <= 0 then
			table.insert(_G.ModsAntilag["EatHeal"], v)
		end
	end
end
for i, v in ipairs(workspace:GetDescendants()) do
	Checkmods(v)
end
workspace.DescendantAdded:Connect(function(v)
	if v:IsA("Model") then 
		Checkmods(v)
	end
end)

_G.DelayShot = 0.25
_G.ReachShot = 250
Misc2Group:AddToggle("Gun Aura", {
    Text = "Gun Aura",
    Default = false, 
    Callback = function(Value) 
_G.KillAuraGun = Value
while _G.KillAuraGun do
local DistanceGunAura, ModsTargetShotHead, ModsTargetShotHumanoid = math.huge, nil, nil
for i, v in pairs(_G.ModsAntilag.GunAura) do
if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") and v:FindFirstChild("Head") and not game.Players:GetPlayerFromCharacter(v) then
local DistanceGun = (game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position - v.HumanoidRootPart.Position).Magnitude
if DistanceGun < DistanceGunAura and DistanceGun < _G.ReachShot then
if not Options.NoMods.Value["Horse"] or (not v.Name:find("Horse") and not v.Name:find("Unicorn")) then
if not Options.NoMods.Value["Wolf"] or not v.Name:find("Wolf") then
if not Options.NoMods.Value["Werewolf"] or not v.Name:find("Werewolf") then
if not v.Name:find("Soldier") then
if v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 then 
ModsTargetShotHead, ModsTargetShotHumanoid, DistanceGunAura = v:FindFirstChild(_G.CharacterMods or "Head"), v.Humanoid, DistanceGun
if _G.HealthBarMods == true and game.CoreGui:FindFirstChild("Gun Health Track").Enabled == false then
game.CoreGui["Gun Health Track"].Enabled = true
elseif game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = ((#(v.Name:gsub("Model_", "")) > 13) and (string.sub(v.Name:gsub("Model_", ""), 1, 9).."...") or v.Name:gsub("Model_", "")).." Health\n"..string.format("%.0f", v.Humanoid.Health).." / " ..v.Humanoid.MaxHealth
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(v.Humanoid.Health / v.Humanoid.MaxHealth, 0, 1, 0)
end
end
end
end
end
end
end
end
if v:FindFirstChild("HumanoidRootPart") == nil or (v:FindFirstChild("Humanoid") and v.Humanoid.Health <= 0) then
	for i = #_G.ModsAntilag.GunAura, 1, -1 do
		if _G.ModsAntilag.GunAura[i] == v then
			table.remove(_G.ModsAntilag.GunAura, i)
		end
	end
end
end
if ModsTargetShotHead and ModsTargetShotHumanoid then
_G.ModsShotgun = {}
ShotNow = {14, 8, 2, 5, 11, 17}
if _G.GunAuraKillSkib == "Fast" then
for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
        if v:FindFirstChild("ClientWeaponState") and v.ClientWeaponState:FindFirstChild("CurrentAmmo") then
			if v.ClientWeaponState.CurrentAmmo.Value ~= 0 then
				if v.Name == "Shotgun" or v.Name == "Sawed-Off Shotgun" then
					for i, v in pairs(ShotNow) do
					    _G.ModsShotgun[v] = ModsTargetShotHumanoid
					end
				else
					_G.ModsShotgun["2"] = ModsTargetShotHumanoid
				end
				if _G.ModsShotgun ~= nil then
					game.ReplicatedStorage.Remotes.Weapon.Shoot:FireServer(game.Workspace:GetServerTimeNow(), v, ModsTargetShotHead.CFrame, _G.ModsShotgun)
					game.ReplicatedStorage.Remotes.Weapon.Reload:FireServer(game.Workspace:GetServerTimeNow(), v)
				end
			end
        end
    end
elseif _G.GunAuraKillSkib == "Normal" then
for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
        if v:FindFirstChild("ClientWeaponState") and v.ClientWeaponState:FindFirstChild("CurrentAmmo") then
			if v.ClientWeaponState.CurrentAmmo.Value ~= 0 then
				if v.Name == "Shotgun" or v.Name == "Sawed-Off Shotgun" then
					for i, v in pairs(ShotNow) do
					    _G.ModsShotgun[v] = ModsTargetShotHumanoid
					end
				else
					_G.ModsShotgun["2"] = ModsTargetShotHumanoid
				end
				if _G.ModsShotgun ~= nil then
					game.ReplicatedStorage.Remotes.Weapon.Shoot:FireServer(game.Workspace:GetServerTimeNow(), v, ModsTargetShotHead.CFrame, _G.ModsShotgun)
				end
			elseif v.ClientWeaponState.CurrentAmmo.Value == 0 then
				game.ReplicatedStorage.Remotes.Weapon.Reload:FireServer(game.Workspace:GetServerTimeNow(), v)
				repeat task.wait() until v.ClientWeaponState.CurrentAmmo.Value ~= 0
			end
        end
    end
end
else
if game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Enabled = false
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = "Nah Health: Nil"
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(1, 0, 1, 0)
end
end
task.wait(_G.DelayShot)
end
if game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Enabled = false
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = "Nah Health: Nil"
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(1, 0, 1, 0)
end
    end
}):AddKeyPicker("GunAuraKill", {
   Default = "M",
   Text = "Gun Aura",
   Mode = "Toggle",
   SyncToggleState = true
})

Misc2Group:AddToggle("Auto Reload", {
    Text = "Auto Reload Gun",
    Default = false, 
    Callback = function(Value) 
_G.AutoReload = Value
while _G.AutoReload do
for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
    if v:FindFirstChild("ClientWeaponState") and v.ClientWeaponState:FindFirstChild("CurrentAmmo") then
		game.ReplicatedStorage.Remotes.Weapon.Reload:FireServer(game.Workspace:GetServerTimeNow(), v)
    end
end
task.wait()
end
    end
})

Misc2Group:AddToggle("Hitbox Mods", {
    Text = "Hitbox Mods",
    Default = false, 
    Callback = function(Value) 
_G.Hitbox = Value
if _G.Hitbox == false then
for i, v in pairs(workspace:GetDescendants()) do
    if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Head") and v:FindFirstChild("Humanoid") and not game.Players:GetPlayerFromCharacter(v) then
        v:FindFirstChild("Head").Size = _G.CharacterToYour["Head"]
    end
end
end
while _G.Hitbox do
for i, v in pairs(_G.ModsAntilag.Hitbox) do
if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Head") and not game.Players:GetPlayerFromCharacter(v) then
if not Options.NoMods.Value["Horse"] or (not v.Name:find("Horse") and not v.Name:find("Unicorn")) then
if not Options.NoMods.Value["Wolf"] or not v.Name:find("Wolf") then
if not Options.NoMods.Value["Werewolf"] or not v.Name:find("Werewolf") then
if not v.Name:find("Soldier") then
if v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 then 
v:FindFirstChild("Head").Size = Vector3.new(6, 6, 6)
end
end
end
end
end
end
if v:FindFirstChild("HumanoidRootPart") == nil or v:FindFirstChild("Humanoid") and v.Humanoid.Health <= 0 then
for i, v in pairs(workspace:GetDescendants()) do
    if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Head") and v:FindFirstChild("Humanoid") and not game.Players:GetPlayerFromCharacter(v) then
        v:FindFirstChild("Head").Size = _G.CharacterToYour["Head"]
    end
end
for i = #_G.ModsAntilag.Hitbox, 1, -1 do
	if _G.ModsAntilag.Hitbox[i] == v then
		table.remove(_G.ModsAntilag.Hitbox, i)
	end
end
end
end
task.wait()
end
    end
})

Misc2Group:AddToggle("Eat Mods", {
    Text = "Eat Mods",
    Default = false,
    Tooltip = "Class Zombie",
    Callback = function(Value) 
_G.EatMods = Value
while _G.EatMods do
for i, v in pairs(_G.ModsAntilag.EatHeal) do
if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") and not game.Players:GetPlayerFromCharacter(v) then
if v.Humanoid.Health <= 0 and 8 >= (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.HumanoidRootPart.Position).Magnitude then
for i, s in pairs(v.HumanoidRootPart:GetChildren()) do
if s:IsA("ProximityPrompt") then
if fireproximityprompt then
fireproximityprompt(s)
end
end
end
end
end
end
task.wait()
end
    end
})

function CheckWall(Target, Target1)
    local Direction = (Target.Position - game.Workspace.CurrentCamera.CFrame.Position).unit * (Target.Position - game.Workspace.CurrentCamera.CFrame.Position).Magnitude
    local RaycastParams = RaycastParams.new()
    RaycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character, game.Workspace.CurrentCamera}
    RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local Result = game.Workspace:Raycast(game.Workspace.CurrentCamera.CFrame.Position, Direction, RaycastParams)
    return Result == nil or Result.Instance:IsDescendantOf(Target1)
end
Misc2Group:AddToggle("Aimbot Mods", {
    Text = "Aimbot Mods",
    Default = false, 
    Callback = function(Value) 
_G.AimbotMods = Value
while _G.AimbotMods do
local DistanceMath, ModsTarget = math.huge, nil
for i, v in pairs(_G.ModsAntilag.Aimbot) do
if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Head") and not game.Players:GetPlayerFromCharacter(v) then
if not CheckWall(v:FindFirstChild("Head"), v) then 
	continue
end
local Distance = (game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position - v.HumanoidRootPart.Position).Magnitude
if Distance < DistanceMath then
if not Options.NoMods.Value["Horse"] or (not v.Name:find("Horse") and not v.Name:find("Unicorn")) then
if not Options.NoMods.Value["Wolf"] or not v.Name:find("Wolf") then
if not Options.NoMods.Value["Werewolf"] or not v.Name:find("Werewolf") then
if not v.Name:find("Soldier") then
if v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 then 
ModsTarget, DistanceMath = v:FindFirstChild(_G.CharacterMods or "Head"), Distance
if _G.HealthBarMods == true and game.CoreGui:FindFirstChild("Gun Health Track").Enabled == false then
game.CoreGui["Gun Health Track"].Enabled = true
elseif game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = ((#(v.Name:gsub("Model_", "")) > 13) and (string.sub(v.Name:gsub("Model_", ""), 1, 9).."...") or v.Name:gsub("Model_", "")).." Health\n"..string.format("%.0f", v.Humanoid.Health).." / " ..v.Humanoid.MaxHealth
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(v.Humanoid.Health / v.Humanoid.MaxHealth, 0, 1, 0)
end
end
end
end
end
end
end
end
if v:FindFirstChild("HumanoidRootPart") == nil or (v:FindFirstChild("Humanoid") and v.Humanoid.Health <= 0) then
	for i = #_G.ModsAntilag.Aimbot, 1, -1 do
	    if _G.ModsAntilag.Aimbot[i] == v then
	        table.remove(_G.ModsAntilag.Aimbot, i)
	    end
	end
end
end
if ModsTarget then
game.Workspace.CurrentCamera.CFrame = CFrame.lookAt(game.Workspace.CurrentCamera.CFrame.Position, game.Workspace.CurrentCamera.CFrame.Position + (ModsTarget.Position - game.Workspace.CurrentCamera.CFrame.Position).unit)
else
if game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Enabled = false
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = "Nah Health: Nil"
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(1, 0, 1, 0)
end
end
task.wait()
end
if FOVring then
FOVring.Visible = false
end
if game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Enabled = false
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = "Nah Health: Nil"
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(1, 0, 1, 0)
end
    end
}):AddKeyPicker("AimbotMods", {
   Default = "R",
   Text = "Aimbot Mods",
   Mode = "Toggle",
   SyncToggleState = true
})

Misc2Group:AddToggle("Camlock Mods", {
    Text = "Camlock Mods",
    Default = false, 
    Callback = function(Value) 
_G.CamlockMods = Value
while _G.CamlockMods do
local DistanceMathMods = math.huge
local ModsTargetHead
for i, v in pairs(_G.ModsAntilag.Camlock) do
if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Head") and not game.Players:GetPlayerFromCharacter(v) then
local Distance2 = (game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position - v.HumanoidRootPart.Position).Magnitude
if Distance2 < DistanceMathMods then
if not Options.NoMods.Value["Horse"] or (not v.Name:find("Horse") and not v.Name:find("Unicorn")) then
if not Options.NoMods.Value["Wolf"] or not v.Name:find("Wolf") then
if not Options.NoMods.Value["Werewolf"] or not v.Name:find("Werewolf") then
if not v.Name:find("Soldier") then
if v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 then 
if game.Players.LocalPlayer.Character:FindFirstChild("Esp_LocalPlayer") == nil then
	local Highlight = Instance.new("Highlight")
	Highlight.Name = "Esp_LocalPlayer"
	Highlight.FillColor = Color3.fromRGB(0, 255, 0) 
	Highlight.OutlineColor = Color3.fromRGB(255, 255, 255) 
	Highlight.FillTransparency = 0.5
	Highlight.OutlineTransparency = 0
	Highlight.Adornee = game.Players.LocalPlayer.Character
	Highlight.Parent = game.Players.LocalPlayer.Character
end
ModsTargetHead, DistanceMathMods = v:FindFirstChild(_G.CharacterMods or "Head"), Distance2
if _G.HealthBarMods == true and game.CoreGui:FindFirstChild("Gun Health Track").Enabled == false then
game.CoreGui["Gun Health Track"].Enabled = true
elseif game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = ((#(v.Name:gsub("Model_", "")) > 13) and (string.sub(v.Name:gsub("Model_", ""), 1, 9).."...") or v.Name:gsub("Model_", "")).." Health\n"..string.format("%.0f", v.Humanoid.Health).." / " ..v.Humanoid.MaxHealth
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(v.Humanoid.Health / v.Humanoid.MaxHealth, 0, 1, 0)
end
end
end
end
end
end
end
end
if v:FindFirstChild("HumanoidRootPart") == nil or (v:FindFirstChild("Humanoid") and v.Humanoid.Health <= 0) then
	for i = #_G.ModsAntilag.Camlock, 1, -1 do
		if _G.ModsAntilag.Camlock[i] == v then
			table.remove(_G.ModsAntilag.Camlock, i)
		end
	end
end
end
if ModsTargetHead then
if game.Workspace.CurrentCamera.CameraSubject ~= ModsTargetHead then
game.Workspace.CurrentCamera.CameraSubject = ModsTargetHead
end
else
if game.Players.LocalPlayer.Character:FindFirstChild("Esp_LocalPlayer") then
game.Players.LocalPlayer.Character:FindFirstChild("Esp_LocalPlayer"):Destroy()
end
if game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Enabled = false
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = "Nah Health: Nil"
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(1, 0, 1, 0)
end
if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and game.Workspace.CurrentCamera.CameraSubject ~= game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
end
end
task.wait()
end
if game.Players.LocalPlayer.Character:FindFirstChild("Esp_LocalPlayer") then
game.Players.LocalPlayer.Character:FindFirstChild("Esp_LocalPlayer"):Destroy()
end
if game.CoreGui:FindFirstChild("Gun Health Track").Enabled == true then
game.CoreGui["Gun Health Track"].Enabled = false
game.CoreGui["Gun Health Track"].Frame:FindFirstChild("TextLabel").Text = "Nah Health: Nil"
game.CoreGui["Gun Health Track"].Frame.Frame:FindFirstChild("Frame1").Size = UDim2.new(1, 0, 1, 0)
end
if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
end
    end
}):AddKeyPicker("CamlockMods", {
   Default = "K",
   Text = "Camlock Mods",
   Mode = "Toggle",
   SyncToggleState = true
})

Misc2Group:AddSlider("Health Heal", {
    Text = "Health Heal",
    Default = 68,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
_G.HealthyHeal = Value
    end
})

Misc2Group:AddDropdown("HealNowBro", {
    Text = "Auto Heal",
    Values = {"Snake Oil", "Bandage"},
    Default = "",
    Multi = true
})

Misc2Group:AddToggle("Auto Heal", {
    Text = "Auto Heal",
    Default = false, 
    Callback = function(Value) 
_G.AutoHeal = Value
while _G.AutoHeal do
if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid").Health < (_G.HealthyHeal or 68) then
if Options.HealNowBro.Value["Bandage"] then
if game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("Bandage") and game:GetService("Players").LocalPlayer.Backpack["Bandage"]:FindFirstChild("Use") then
game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("Bandage").Use:FireServer()
end
end
if Options.HealNowBro.Value["Snake Oil"] then
if game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("Snake Oil") and game:GetService("Players").LocalPlayer.Backpack["Snake Oil"]:FindFirstChild("Use") then
game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("Snake Oil").Use:FireServer(game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("Snake Oil"))
end
end
end
task.wait()
end
    end
})

------------------------------------------------------------------------
local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")
local CreditsGroup = Tabs["UI Settings"]:AddRightGroupbox("Credits")
local Info = Tabs["UI Settings"]:AddRightGroupbox("Info")

MenuGroup:AddDropdown("NotifySide", {
    Text = "Notification Side",
    Values = {"Left", "Right"},
    Default = "Right",
    Multi = false,
    Callback = function(Value)
Library:SetNotifySide(Value)
    end
})

_G.ChooseNotify = "Obsidian"
MenuGroup:AddDropdown("NotifyChoose", {
    Text = "Notification Choose",
    Values = {"Obsidian", "Roblox"},
    Default = "",
    Multi = false,
    Callback = function(Value)
_G.ChooseNotify = Value
    end
})

_G.NotificationSound = true
MenuGroup:AddToggle("NotifySound", {
    Text = "Notification Sound",
    Default = true, 
    Callback = function(Value) 
_G.NotificationSound = Value 
    end
})

MenuGroup:AddSlider("Volume Notification", {
    Text = "Volume Notification",
    Default = 2,
    Min = 2,
    Max = 10,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
_G.VolumeTime = Value
    end
})

MenuGroup:AddToggle("KeybindMenuOpen", {Default = false, Text = "Open Keybind Menu", Callback = function(Value) Library.KeybindFrame.Visible = Value end})
MenuGroup:AddToggle("ShowCustomCursor", {Text = "Custom Cursor", Default = true, Callback = function(Value) Library.ShowCustomCursor = Value end})
MenuGroup:AddDivider()
MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", {Default = "RightShift", NoUI = true, Text = "Menu keybind"})
_G.LinkJoin = loadstring(game:HttpGet("https://pastefy.app/2LKQlhQM/raw"))()
MenuGroup:AddButton("YG SCRIPT", function()
    if setclipboard then
        setclipboard(_G.LinkJoin["1015718032"])
        Library:Notify("Copied  link to clipboard")
    else
        Library:Notify("".._G.LinkJoin[""], 10)
    end
end):AddButton("Copy Link YG SCRIPT", function()
    if setclipboard then
        setclipboard(_G.LinkJoin["qq1015718032"])
        Library:Notify("Copied  link to clipboard!")
    else
        Library:Notify("YG SCRIPT link: ".._G.LinkJoin["qq1015718032"], 10)
    end
end)
MenuGroup:AddButton("Unload", function() Library:Unload() end)
CreditsGroup:AddLabel("AmongUs - Python / Dex / Script", true)
CreditsGroup:AddLabel("Giang Hub - Script / Dex", true)
CreditsGroup:AddLabel("Cao Mod - Script / Dex", true)

Info:AddLabel("Counter [ "..game:GetService("LocalizationService"):GetCountryRegionForPlayerAsync(game.Players.LocalPlayer).." ]", true)
Info:AddLabel("Executor [ "..identifyexecutor().." ]", true)
Info:AddLabel("Job Id [ "..game.JobId.." ]", true)
Info:AddDivider()
Info:AddButton("Copy JobId", function()
    if setclipboard then
        setclipboard(tostring(game.JobId))
        Library:Notify("Copied Success")
    else
        Library:Notify(tostring(game.JobId), 10)
    end
end)

Info:AddInput("Join YG SCRIPT", {
    Default = "Nah",
    Numeric = false,
    Text = "Join YG SCRIPT",
    Placeholder = "UserJobId",
    Callback = function(Value)
_G.JobIdJoin = Value
    end
})

Info:AddButton("YG_SCRIPT", function()
game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, _G.JobIdJoin, game.Players.LocalPlayer)
end)

Info:AddButton("加入qq1015718032", function()
    if setclipboard then
        setclipboard('game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, '..game.JobId..", game.Players.LocalPlayer)")
        Library:Notify("Copied Success") 
    else
        Library:Notify(tostring(game.JobId), 10)
    end
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])
SaveManager:LoadAutoloadConfig() 
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})

local MyButton = LeftGroupBox:AddButton({
    Text = '战争大亨',---服务器名称
    Func = function()
    local originalUI = Library
        
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()
local Confirmed = false

local gradientColors = {
    "rgb(255, 230, 235)",
    "rgb(255, 210, 220)",
    "rgb(255, 190, 205)",
    "rgb(255, 170, 190)",
    "rgb(255, 150, 175)",
    "rgb(245, 140, 180)",
    "rgb(235, 130, 185)",
    "rgb(225, 120, 190)",
    "rgb(215, 110, 195)",
    "rgb(205, 100, 200)"
}

local username = game.Players.LocalPlayer.Name
local coloredUsername = ""
for i = 1, #username do
    local colorIndex = (i - 1) % #gradientColors + 1
    coloredUsername = coloredUsername .. '<font color="' .. gradientColors[colorIndex] .. '">' .. username:sub(i, i) .. '</font>'
end

local version = "v1.2.4"
local coloredVersion = ""
for i = 1, #version do
    local colorIndex = (i - 1) % #gradientColors + 1
    coloredVersion = coloredVersion .. '<font color="' .. gradientColors[colorIndex] .. '">' .. version:sub(i, i) .. '</font>'
end

WindUI:Popup({
    Title = '<font color="' .. gradientColors[1] .. '">YG</font><font color="' .. gradientColors[5] .. '">SCRIPT</font>',
    IconThemed = true,
    Content = "尊敬的用户 " .. coloredUsername .. " \n您使用的 <font color='" .. gradientColors[1] .. "'>Y</font><font color='" .. gradientColors[5] .. "'>G</font> 当前版本型号是: " .. coloredVersion .. "\n加入qq：1015718032",
    Buttons = {
        {
            Title = "取消",
            Callback = function() end,
            Variant = "Secondary",
        },
        {
            Title = "执行",
            Icon = "arrow-right",
            Callback = function() 
                Confirmed = true
                createUI()
            end,
            Variant = "Primary",
        }
    }
})

function createUI()
    local Window = WindUI:CreateWindow({
        Title = 'YG SCRIPT',
        Icon = "heart",
        IconThemed = true,
        Author = "v1.2.4",
        Folder = "CloudHub",
        Size = UDim2.fromOffset(580, 440),
        Transparent = true,
        Theme = "Dark",
        HideSearchBar = false,
        ScrollBarEnabled = true,
        Resizable = true,
        Background = "https://raw.githubusercontent.com/dohyynd/yg/main/Adobe%20Express%20-%20file.png",
        BackgroundImageTransparency = 0.5,
        User = {
            Enabled = true,
            Callback = function()
                WindUI:Notify({
                    Title = "点击了自己",
                    Content = "没什么", 
                    Duration = 1,
                    Icon = "4483362748"
                })
            end,
            Anonymous = false
        },
        SideBarWidth = 250,
        Search = {
            Enabled = true,
            Placeholder = "搜索...",
            Callback = function(searchText)
                print("搜索内容:", searchText)
            end
        },
        SidePanel = {
            Enabled = true,
            Content = {
                {
                    Type = "Button", 
                    Text = "YG SCRIPT",
                    Style = "Subtle", 
                    Size = UDim2.new(1, -20, 0, 30),
                    Callback = function()
                    end
                }
            }
        }
    })

Window:EditOpenButton({
    Title = "YG SCRIPT",
    Icon = "rbxassetid://105677776902677",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 4,
    Color = ColorSequence.new(Color3.fromHex("FF6B6B")),
    Draggable = true,
})

Window:Tag({
        Title = "战争大亨",
        Color = Color3.fromHex("#00ffff") 
    })

Window:EditOpenButton({
    Title = "YG SCRIPT",
    Icon = "heart",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 4,
    Color = ColorSequence.new(Color3.fromHex("FF6B6B")),
    Draggable = true,
})

spawn(function()
    while true do
        for hue = 0, 1, 0.01 do  
            local color = Color3.fromHSV(hue, 0.8, 1)  
            Window:EditOpenButton({
                Color = ColorSequence.new(color)
            })
            wait(0.04)  
        end
    end
end)

local LockSection = Window:Section({
    Title = "公告",
    Opened = true,
})

local infoTab = Window:Tab({Title = "通知", Icon = "layout-grid", Locked = false})

local LockSection = Window:Section({
    Title = "主功能",
    Opened = true,
})

local function AddTab(section, title, icon)
    return section:Tab({Title = title, Icon = icon})
end

local A = AddTab(LockSection, "玩家", "rbxassetid://4335480896")
local B = AddTab(LockSection, "透视", "eye")
local C = AddTab(LockSection, "传送", "rbxassetid://3944688398")
local D = AddTab(LockSection, "自瞄", "rbxassetid://4483345998")
local E = AddTab(LockSection, "子追", "rbxassetid://4483345998")

local OtherSection = Window:Section({
    Title = "其他功能",
    Opened = true,
})

local infoSection = infoTab:Section({Title = "详情信息",Icon = "info", Opened = true})

local F = AddTab(OtherSection, "攻击", "rbxassetid://4384392464")
local G = AddTab(OtherSection, "修改", "rbxassetid://94831304996747")
local H = AddTab(OtherSection, "内置", "settings")
local I = AddTab(OtherSection, "自动", "rbxassetid://4450736564")
local J = AddTab(OtherSection, "载具", "car")

infoSection:Divider()

infoSection:Paragraph({
    Title = "关于",
    Desc = "半成品\n国内免费最佳\n成品认准xi pro\n加入我们1015718032",
    ThumbnailSize = 190,
})

local infoSection = infoTab:Section({Title = "更新公告", Icon = "bell", Opened = true})

infoSection:Divider()

infoSection:Paragraph({
    Title = "12.6提示",
    Desc = "更新优化\n修复大部分功能",
    ThumbnailSize = 190,
})


infoSection:Paragraph({
    Title = "11.5提示",
    Desc = "更新添加\n+子弹追踪 +自瞄功能 +自动功能",
    ThumbnailSize = 190,
})

infoSection:Paragraph({
    Title = "10.21提示",
    Desc = "更新添加\n+透视功能 +玩家功能 +RPG功能",
    ThumbnailSize = 190,
})

infoTab:Select()

A:Slider({
    Title = "视野",
    Step = 1,
    Value = {Min = 10, Max = 180, Default = workspace.CurrentCamera.FieldOfView},
    Callback = function(FOV)
        getgenv().TargetFOV = FOV
        workspace.CurrentCamera.FieldOfView = FOV
        
        if not getgenv().FOVLoop then
            getgenv().FOVLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if workspace.CurrentCamera then
                    workspace.CurrentCamera.FieldOfView = getgenv().TargetFOV
                end
            end)
            
            game.Players.LocalPlayer.CharacterAdded:Connect(function()
                wait(1)
                if workspace.CurrentCamera then
                    workspace.CurrentCamera.FieldOfView = getgenv().TargetFOV
                end
            end)
        end
    end
})

A:Toggle({
    Title = "穿墙",
    Value = false,
    Callback = function(state)
        if state then
            getgenv().noclipConnection = game:GetService("RunService").Stepped:Connect(function()
                local LocalPlayer = game:GetService("Players").LocalPlayer
                if LocalPlayer.Character then
                    for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if getgenv().noclipConnection then
                getgenv().noclipConnection:Disconnect()
                getgenv().noclipConnection = nil
            end
            
            local LocalPlayer = game:GetService("Players").LocalPlayer
            if LocalPlayer.Character then
                for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
})

A:Toggle({
    Title = "快速互动",
    Value = false,
    Callback = function(state)
        if state then
            local ProximityPromptService = game:GetService("ProximityPromptService")
            
            getgenv().fastInteractionConnection = ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
                prompt.HoldDuration = 0.01
            end)
            
            for _, prompt in pairs(workspace:GetDescendants()) do
                if prompt:IsA("ProximityPrompt") then
                    prompt.HoldDuration = 0.01
                end
            end
        else
            if getgenv().fastInteractionConnection then
                getgenv().fastInteractionConnection:Disconnect()
                getgenv().fastInteractionConnection = nil
            end
            
            for _, prompt in pairs(workspace:GetDescendants()) do
                if prompt:IsA("ProximityPrompt") then
                    prompt.HoldDuration = 0.5
                end
            end
        end
    end
})

A:Toggle({
    Title = "互动动作无延迟",
    Value = false,
    Callback = function(value)
        if value then
            local ContextActions = game:GetService("Workspace")[game.Players.LocalPlayer.Name].ContextActions
            local ContextMain = require(ContextActions.ContextMain)
            
            ContextMain:New({
                RobPlayerLength = 0.01,
                FixWallLength = 0.01,
                CrackSafeLength = 0.01,
                RobSafeLength = 0.01,
                RobRegisterLength = 0.01,
                PickCellLength = 0.01,
                SkinAnimalLength = 0.01
            }, 200, {
                "Get out of my shop! Outlaws are not welcome here!",
                "Hey, scoundrel! Get out before I call the sheriff!",
                "You're an outlaw! We don't serve your type here!"
            }, {
                "This here's a bandit camp! Get out!",
                "Get lost, cowboy!",
                "Are you an outlaw? Didn't think so! Scram!"
            })
        end
    end
})

A:Divider({
    Text = "移动功能"
})

local walkSpeed = 150
local walkMultiplier = 3
A:Toggle({
    Title = "移动开关",
    Value = false,
    Callback = function(state)
        getgenv().WalkEnabled = state
        if state then
            local function updateWalkSpeed()
                local character = game.Players.LocalPlayer.Character
                if character and character:FindFirstChild("Humanoid") then
                    character.Humanoid.WalkSpeed = walkSpeed * walkMultiplier
                end
            end
            
            updateWalkSpeed()
            
            getgenv().WalkConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function(newChar)
                wait(1)
                updateWalkSpeed()
            end)
            
            getgenv().WalkLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if getgenv().WalkEnabled then
                    updateWalkSpeed()
                end
            end)
        else
            if getgenv().WalkConnection then
                getgenv().WalkConnection:Disconnect()
            end
            if getgenv().WalkLoop then
                getgenv().WalkLoop:Disconnect()
            end
            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid.WalkSpeed = 16
            end
        end
    end
})

A:Slider({
    Title = "移动倍率",
    Step = 0.1,
    Value = {Min = 1, Max = 10, Default = 3},
    Callback = function(multiplier)
        walkMultiplier = multiplier
        if getgenv().WalkEnabled and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = walkSpeed * walkMultiplier
        end
    end
})

A:Toggle({
    Title = "跳跃高度开关",
    Value = false,
    Callback = function(state)
        getgenv().JumpHeightEnabled = state
        
        if state then
            local function updateJumpPower()
                local character = game.Players.LocalPlayer.Character
                if character and character:FindFirstChild("Humanoid") then
                    character.Humanoid.JumpPower = getgenv().JumpHeightValue or 50
                end
            end
            
            updateJumpPower()
            
            getgenv().JumpConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function(newChar)
                wait(1)
                updateJumpPower()
            end)
            
            getgenv().JumpLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if getgenv().JumpHeightEnabled then
                    updateJumpPower()
                end
            end)
        else
            if getgenv().JumpConnection then
                getgenv().JumpConnection:Disconnect()
            end
            if getgenv().JumpLoop then
                getgenv().JumpLoop:Disconnect()
            end
            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid.JumpPower = 50
            end
        end
    end
})

A:Slider({
    Title = "跳跃高度",
    Step = 1,
    Value = {Min = 50, Max = 500, Default = 100},
    Callback = function(height)
        getgenv().JumpHeightValue = height
        if getgenv().JumpHeightEnabled and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = height
        end
    end
})

A:Divider({
    Text = "飞行功能"
})

local flySpeed = 150
local flyMultiplier = 5
A:Slider({
    Title = "飞行倍率",
    Step = 0.1,
    Value = {Min = 1, Max = 20, Default = 5},
    Callback = function(multiplier)
        flyMultiplier = multiplier
    end
})

A:Toggle({
    Title = "飞行开关",
    Value = false,
    Callback = function(bak)
        getgenv().fly = bak
        if bak then
            local controlModule = require(game.Players.LocalPlayer.PlayerScripts:WaitForChild('PlayerModule'):WaitForChild("ControlModule"))
            local character = game.Players.LocalPlayer.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then return end
            
            local function setupFlight(character)
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                
                if hrp:FindFirstChild("VelocityHandler") then hrp.VelocityHandler:Destroy() end
                if hrp:FindFirstChild("GyroHandler") then hrp.GyroHandler:Destroy() end
                
                local bv = Instance.new("BodyVelocity")
                bv.Name = "VelocityHandler"
                bv.Parent = hrp
                bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
                bv.Velocity = Vector3.new(0, 0, 0)
                
                local bg = Instance.new("BodyGyro")
                bg.Name = "GyroHandler"
                bg.Parent = hrp
                bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
                bg.P = 1000
                bg.D = 50
                
                return bv, bg
            end
            
            local bv, bg = setupFlight(character)
            
            local camera = game.Workspace.CurrentCamera
            getgenv().FlyLoop = game:GetService("RunService").RenderStepped:Connect(function()
                local currentCharacter = game.Players.LocalPlayer.Character
                local hrp = currentCharacter and currentCharacter:FindFirstChild("HumanoidRootPart")
                if currentCharacter and hrp and hrp:FindFirstChild("VelocityHandler") and hrp:FindFirstChild("GyroHandler") and getgenv().fly then
                    currentCharacter.Humanoid.PlatformStand = true
                    hrp.GyroHandler.CFrame = camera.CFrame
                    
                    local direction = controlModule:GetMoveVector()
                    local actualSpeed = flySpeed * flyMultiplier
                    
                    hrp.VelocityHandler.Velocity = Vector3.new()
                    if direction.X ~= 0 then
                        hrp.VelocityHandler.Velocity = hrp.VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * actualSpeed)
                    end
                    if direction.Z ~= 0 then
                        hrp.VelocityHandler.Velocity = hrp.VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * actualSpeed)
                    end
                    if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space) then
                        hrp.VelocityHandler.Velocity = hrp.VelocityHandler.Velocity + Vector3.new(0, actualSpeed/2, 0)
                    end
                    if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftShift) then
                        hrp.VelocityHandler.Velocity = hrp.VelocityHandler.Velocity - Vector3.new(0, actualSpeed/2, 0)
                    end
                end
            end)
        else
            if getgenv().FlyLoop then
                getgenv().FlyLoop:Disconnect()
            end
            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                if hrp:FindFirstChild("VelocityHandler") then hrp.VelocityHandler:Destroy() end
                if hrp:FindFirstChild("GyroHandler") then hrp.GyroHandler:Destroy() end
                character.Humanoid.PlatformStand = false
            end
        end
    end
})

A:Divider({
    Text = "空中行走"
})

A:Toggle({
    Title = "空中行走开关",
    Value = false,
    Callback = function(state)
        getgenv().AirWalkEnabled = state
        
        if state then
            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                getgenv().BodyPositionInstance = Instance.new("BodyPosition")
                getgenv().BodyPositionInstance.Position = Vector3.new(hrp.Position.X, getgenv().AirWalkHeight or hrp.Position.Y, hrp.Position.Z)
                getgenv().BodyPositionInstance.MaxForce = Vector3.new(0, 40000, 0)
                getgenv().BodyPositionInstance.P = 10000
                getgenv().BodyPositionInstance.Parent = hrp
                
                getgenv().AirWalkConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function(newChar)
                    wait(1)
                    if getgenv().AirWalkEnabled and newChar:FindFirstChild("HumanoidRootPart") then
                        getgenv().BodyPositionInstance = Instance.new("BodyPosition")
                        getgenv().BodyPositionInstance.Position = Vector3.new(newChar.HumanoidRootPart.Position.X, getgenv().AirWalkHeight or newChar.HumanoidRootPart.Position.Y, newChar.HumanoidRootPart.Position.Z)
                        getgenv().BodyPositionInstance.MaxForce = Vector3.new(0, 40000, 0)
                        getgenv().BodyPositionInstance.Parent = newChar.HumanoidRootPart
                    end
                end)
                
                getgenv().AirWalkLoop = game:GetService("RunService").Heartbeat:Connect(function()
                    if getgenv().AirWalkEnabled and character and character:FindFirstChild("HumanoidRootPart") and getgenv().BodyPositionInstance then
                        local hrp = character.HumanoidRootPart
                        getgenv().BodyPositionInstance.Position = Vector3.new(hrp.Position.X, getgenv().AirWalkHeight, hrp.Position.Z)
                    end
                end)
            end
        else
            if getgenv().BodyPositionInstance then
                getgenv().BodyPositionInstance:Destroy()
                getgenv().BodyPositionInstance = nil
            end
            if getgenv().AirWalkConnection then
                getgenv().AirWalkConnection:Disconnect()
            end
            if getgenv().AirWalkLoop then
                getgenv().AirWalkLoop:Disconnect()
            end
        end
    end
})

A:Slider({
    Title = "Y轴高度",
    Step = 1,
    Value = {Min = -100, Max = 500, Default = 50},
    Callback = function(height)
        getgenv().AirWalkHeight = height
        if getgenv().AirWalkEnabled and getgenv().BodyPositionInstance then
            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                getgenv().BodyPositionInstance.Position = Vector3.new(hrp.Position.X, height, hrp.Position.Z)
            end
        end
    end
})

WindUI:Notify({
    Title = "玩家功能",
    Content = "玩家功能已关闭",
    Duration = 3,
})

getgenv().ShowBox = false
getgenv().ShowHealth = false
getgenv().ShowName = false
getgenv().ShowDistance = false
getgenv().ShowTracer = false
getgenv().TeamCheck = false
getgenv().ShowSkeleton = false
getgenv().ShowWeapon = false
getgenv().ShowRadar = false

getgenv().TracerColor = Color3.new(1, 1, 1)
getgenv().SkeletonColor = Color3.new(0.2, 0.8, 1)
getgenv().BoxColor = Color3.new(1, 1, 1)
getgenv().HealthBarColor = Color3.new(0, 1, 0)
getgenv().HealthTextColor = Color3.new(1, 1, 1)
getgenv().NameColor = Color3.new(1, 1, 1)
getgenv().DistanceColor = Color3.new(1, 1, 0)
getgenv().WeaponColor = Color3.new(1, 0.5, 0)

getgenv().BoxThickness = 1
getgenv().TracerThickness = 1
getgenv().SkeletonThickness = 2

local ESPComponents = {}

local function createESP(player)
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = getgenv().BoxColor
    box.Thickness = getgenv().BoxThickness
    box.Filled = false

    local healthBar = Drawing.new("Square")
    healthBar.Visible = false
    healthBar.Color = getgenv().HealthBarColor
    healthBar.Thickness = 1
    healthBar.Filled = true

    local healthBarBackground = Drawing.new("Square")
    healthBarBackground.Visible = false
    healthBarBackground.Color = Color3.new(0, 0, 0)
    healthBarBackground.Transparency = 0.5
    healthBarBackground.Thickness = 1
    healthBarBackground.Filled = true

    local healthBarBorder = Drawing.new("Square")
    healthBarBorder.Visible = false
    healthBarBorder.Color = Color3.new(1, 1, 1)
    healthBarBorder.Thickness = 1
    healthBarBorder.Filled = false

    local healthText = Drawing.new("Text")
    healthText.Visible = false
    healthText.Color = getgenv().HealthTextColor
    healthText.Size = 14
    healthText.Font = Drawing.Fonts.Monospace
    healthText.Outline = true
    healthText.OutlineColor = Color3.new(0, 0, 0)

    local nameText = Drawing.new("Text")
    nameText.Visible = false
    nameText.Color = getgenv().NameColor
    nameText.Size = 16
    nameText.Font = Drawing.Fonts.Monospace
    nameText.Outline = true
    nameText.OutlineColor = Color3.new(0, 0, 0)

    local distanceText = Drawing.new("Text")
    distanceText.Visible = false
    distanceText.Color = getgenv().DistanceColor
    distanceText.Size = 14
    distanceText.Font = Drawing.Fonts.Monospace
    distanceText.Outline = true
    distanceText.OutlineColor = Color3.new(0, 0, 0)

    local weaponText = Drawing.new("Text")
    weaponText.Visible = false
    weaponText.Color = getgenv().WeaponColor
    weaponText.Size = 14
    weaponText.Font = Drawing.Fonts.Monospace
    weaponText.Outline = true
    weaponText.OutlineColor = Color3.new(0, 0, 0)

    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Color = getgenv().TracerColor
    tracer.Thickness = getgenv().TracerThickness

    local skeletonLines = {}
    local skeletonPoints = {}

    local function createSkeleton()
        for i = 1, 15 do
            skeletonLines[i] = Drawing.new("Line")
            skeletonLines[i].Visible = false
            skeletonLines[i].Color = getgenv().SkeletonColor
            skeletonLines[i].Thickness = getgenv().SkeletonThickness
        end

        skeletonPoints["Head"] = Drawing.new("Circle")
        skeletonPoints["Head"].Visible = false
        skeletonPoints["Head"].Color = getgenv().SkeletonColor
        skeletonPoints["Head"].Thickness = 0.1
        skeletonPoints["Head"].Filled = false
        skeletonPoints["Head"].Radius = 4
    end

    createSkeleton()

    ESPComponents[player] = {
        box = box,
        healthBar = healthBar,
        healthBarBackground = healthBarBackground,
        healthBarBorder = healthBarBorder,
        healthText = healthText,
        nameText = nameText,
        distanceText = distanceText,
        weaponText = weaponText,
        tracer = tracer,
        skeletonLines = skeletonLines,
        skeletonPoints = skeletonPoints
    }

    game:GetService("RunService").RenderStepped:Connect(function()
        local espEnabled = getgenv().ShowBox or getgenv().ShowHealth or getgenv().ShowName or 
                          getgenv().ShowDistance or getgenv().ShowTracer or getgenv().ShowSkeleton or 
                          getgenv().ShowWeapon
        
        if not espEnabled or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or not player.Character:FindFirstChild("Humanoid") or player == game.Players.LocalPlayer then
            box.Visible = false
            healthBar.Visible = false
            healthBarBackground.Visible = false
            healthBarBorder.Visible = false
            healthText.Visible = false
            nameText.Visible = false
            distanceText.Visible = false
            weaponText.Visible = false
            tracer.Visible = false
            for _, line in pairs(skeletonLines) do
                line.Visible = false
            end
            for _, point in pairs(skeletonPoints) do
                point.Visible = false
            end
            return
        end

        if getgenv().TeamCheck and player.Team == game.Players.LocalPlayer.Team then
            box.Visible = false
            healthBar.Visible = false
            healthBarBackground.Visible = false
            healthBarBorder.Visible = false
            healthText.Visible = false
            nameText.Visible = false
            distanceText.Visible = false
            weaponText.Visible = false
            tracer.Visible = false
            for _, line in pairs(skeletonLines) do
                line.Visible = false
            end
            for _, point in pairs(skeletonPoints) do
                point.Visible = false
            end
            return
        end

        local character = player.Character
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")

        if rootPart and humanoid and humanoid.Health > 0 then
            local rootPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(rootPart.Position)
            local headPos, _ = workspace.CurrentCamera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 3, 0))
            local legPos, _ = workspace.CurrentCamera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0))

            local weaponName = "无武器"
            for _, tool in ipairs(character:GetChildren()) do
                if tool:IsA("Tool") then
                    weaponName = tool.Name
                    break
                end
            end

            if getgenv().ShowBox and onScreen then
                box.Size = Vector2.new(1000 / rootPos.Z, headPos.Y - legPos.Y)
                box.Position = Vector2.new(rootPos.X - box.Size.X / 2, rootPos.Y - box.Size.Y / 2)
                box.Visible = true
            else
                box.Visible = false
            end

            if getgenv().ShowHealth and onScreen then
                local healthPercentage = humanoid.Health / humanoid.MaxHealth
                local barWidth = 50
                local barHeight = 5
                local barX = headPos.X - barWidth / 2
                local barY = headPos.Y - 20

                healthBarBackground.Size = Vector2.new(barWidth, barHeight)
                healthBarBackground.Position = Vector2.new(barX, barY)
                healthBarBackground.Visible = true

                healthBarBorder.Size = Vector2.new(barWidth, barHeight)
                healthBarBorder.Position = Vector2.new(barX, barY)
                healthBarBorder.Visible = true

                healthBar.Size = Vector2.new(barWidth * healthPercentage, barHeight)
                healthBar.Position = Vector2.new(barX, barY)
                healthBar.Visible = true

                healthText.Position = Vector2.new(barX + barWidth + 5, barY - 5)
                healthText.Text = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
                healthText.Visible = true
            else
                healthBar.Visible = false
                healthBarBackground.Visible = false
                healthBarBorder.Visible = false
                healthText.Visible = false
            end

            if getgenv().ShowName and onScreen then
                nameText.Position = Vector2.new(headPos.X, headPos.Y - 35)
                nameText.Text = player.Name
                nameText.Visible = true
            else
                nameText.Visible = false
            end

            if getgenv().ShowWeapon and onScreen then
                weaponText.Position = Vector2.new(headPos.X, headPos.Y - 50)
                weaponText.Text = weaponName
                weaponText.Visible = true
            else
                weaponText.Visible = false
            end

            if getgenv().ShowDistance and onScreen then
                local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                distanceText.Position = Vector2.new(headPos.X, headPos.Y + 10)
                distanceText.Text = math.floor(distance) .. "m"
                distanceText.Visible = true
            else
                distanceText.Visible = false
            end

            if getgenv().ShowTracer then
                local head = character:FindFirstChild("Head")
                if head then
                    local headPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(head.Position)
                    if onScreen then
                        tracer.From = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y)
                        tracer.To = Vector2.new(headPos.X, headPos.Y)
                        tracer.Visible = true
                    else
                        tracer.Visible = false
                    end
                else
                    tracer.Visible = false
                end
            else
                tracer.Visible = false
            end

            if getgenv().ShowSkeleton and onScreen then
                local head = character:FindFirstChild("Head")
                local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
                local leftArm = character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftUpperArm")
                local rightArm = character:FindFirstChild("Right Arm") or character:FindFirstChild("RightUpperArm")
                local leftLeg = character:FindFirstChild("Left Leg") or character:FindFirstChild("LeftUpperLeg")
                local rightLeg = character:FindFirstChild("Right Leg") or character:FindFirstChild("RightUpperLeg")
                
                if head and torso and leftArm and rightArm and leftLeg and rightLeg then
                    local headPos = workspace.CurrentCamera:WorldToViewportPoint(head.Position)
                    local torsoPos = workspace.CurrentCamera:WorldToViewportPoint(torso.Position)
                    local leftArmPos = workspace.CurrentCamera:WorldToViewportPoint(leftArm.Position)
                    local rightArmPos = workspace.CurrentCamera:WorldToViewportPoint(rightArm.Position)
                    local leftLegPos = workspace.CurrentCamera:WorldToViewportPoint(leftLeg.Position)
                    local rightLegPos = workspace.CurrentCamera:WorldToViewportPoint(rightLeg.Position)

                    skeletonPoints["Head"].Position = Vector2.new(headPos.X, headPos.Y)
                    skeletonPoints["Head"].Visible = true

                    skeletonLines[1].From = Vector2.new(headPos.X, headPos.Y)
                    skeletonLines[1].To = Vector2.new(torsoPos.X, torsoPos.Y)
                    skeletonLines[1].Visible = true

                    skeletonLines[2].From = Vector2.new(torsoPos.X, torsoPos.Y)
                    skeletonLines[2].To = Vector2.new(leftArmPos.X, leftArmPos.Y)
                    skeletonLines[2].Visible = true

                    skeletonLines[3].From = Vector2.new(torsoPos.X, torsoPos.Y)
                    skeletonLines[3].To = Vector2.new(rightArmPos.X, rightArmPos.Y)
                    skeletonLines[3].Visible = true

                    skeletonLines[4].From = Vector2.new(torsoPos.X, torsoPos.Y)
                    skeletonLines[4].To = Vector2.new(leftLegPos.X, leftLegPos.Y)
                    skeletonLines[4].Visible = true

                    skeletonLines[5].From = Vector2.new(torsoPos.X, torsoPos.Y)
                    skeletonLines[5].To = Vector2.new(rightLegPos.X, rightLegPos.Y)
                    skeletonLines[5].Visible = true
                else
                    for _, line in pairs(skeletonLines) do
                        line.Visible = false
                    end
                    for _, point in pairs(skeletonPoints) do
                        point.Visible = false
                    end
                end
            else
                for _, line in pairs(skeletonLines) do
                    line.Visible = false
                end
                for _, point in pairs(skeletonPoints) do
                    point.Visible = false
                end
            end
        else
            box.Visible = false
            healthBar.Visible = false
            healthBarBackground.Visible = false
            healthBarBorder.Visible = false
            healthText.Visible = false
            nameText.Visible = false
            distanceText.Visible = false
            weaponText.Visible = false
            tracer.Visible = false
            for _, line in pairs(skeletonLines) do
                line.Visible = false
            end
            for _, point in pairs(skeletonPoints) do
                point.Visible = false
            end
        end
    end)
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local radar = Drawing.new("Circle")
radar.Visible = false
radar.Color = Color3.new(1, 1, 1)
radar.Thickness = 2
radar.Filled = false
radar.Radius = 100
radar.Position = Vector2.new(Camera.ViewportSize.X - 120, 120)

local radarCenter = Drawing.new("Circle")
radarCenter.Visible = false
radarCenter.Color = Color3.new(1, 1, 1)
radarCenter.Thickness = 2
radarCenter.Filled = true
radarCenter.Radius = 3
radarCenter.Position = radar.Position

local radarDirection = Drawing.new("Line")
radarDirection.Visible = false
radarDirection.Color = Color3.new(1, 1, 1)
radarDirection.Thickness = 2

local radarGridLines = {}
for i = 1, 4 do
    radarGridLines[i] = Drawing.new("Line")
    radarGridLines[i].Visible = false
    radarGridLines[i].Color = Color3.new(0.5, 0.5, 0.5)
    radarGridLines[i].Thickness = 1
end

local radarRangeText = Drawing.new("Text")
radarRangeText.Visible = false
radarRangeText.Color = Color3.new(1, 1, 1)
radarRangeText.Size = 14
radarRangeText.Font = Drawing.Fonts.Monospace
radarRangeText.Outline = true
radarRangeText.OutlineColor = Color3.new(0, 0, 0)
radarRangeText.Text = "100m"

local radarPlayers = {}

local function updateRadar()
    if not getgenv().ShowRadar then
        radar.Visible = false
        radarCenter.Visible = false
        radarDirection.Visible = false
        radarRangeText.Visible = false
        
        for _, line in pairs(radarGridLines) do
            line.Visible = false
        end
        
        for _, player in pairs(radarPlayers) do
            if player.dot then player.dot.Visible = false end
            if player.direction then player.direction.Visible = false end
            if player.name then player.name.Visible = false end
        end
        return
    end

    radar.Visible = true
    radarCenter.Visible = true
    radarDirection.Visible = true
    radarRangeText.Visible = true
    
    radarRangeText.Position = Vector2.new(radar.Position.X, radar.Position.Y + radar.Radius + 5)
    
    for i = 1, 4 do
        local angle = (i-1) * math.pi / 2
        radarGridLines[i].From = radar.Position
        radarGridLines[i].To = Vector2.new(
            radar.Position.X + math.cos(angle) * radar.Radius,
            radar.Position.Y + math.sin(angle) * radar.Radius
        )
        radarGridLines[i].Visible = true
    end
    
    radarDirection.From = radar.Position
    radarDirection.To = Vector2.new(radar.Position.X, radar.Position.Y - radar.Radius)

    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player ~= LocalPlayer then
            local rootPart = player.Character.HumanoidRootPart
            local relativePosition = rootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position
            
            local radarX = radar.Position.X + (relativePosition.X / 10)
            local radarY = radar.Position.Y + (relativePosition.Z / 10)
            
            local distanceFromCenter = math.sqrt((radarX - radar.Position.X)^2 + (radarY - radar.Position.Y)^2)
            
            if distanceFromCenter > radar.Radius then
                local angle = math.atan2(radarY - radar.Position.Y, radarX - radar.Position.X)
                radarX = radar.Position.X + math.cos(angle) * radar.Radius
                radarY = radar.Position.Y + math.sin(angle) * radar.Radius
            end
            
            if not radarPlayers[player] then
                radarPlayers[player] = {
                    dot = Drawing.new("Circle"),
                    direction = Drawing.new("Line"),
                    name = Drawing.new("Text")
                }
                
                radarPlayers[player].dot.Thickness = 1
                radarPlayers[player].dot.Filled = true
                radarPlayers[player].dot.Radius = 4
                
                radarPlayers[player].direction.Thickness = 2
                radarPlayers[player].direction.Visible = true
                
                radarPlayers[player].name.Size = 12
                radarPlayers[player].name.Font = Drawing.Fonts.Monospace
                radarPlayers[player].name.Outline = true
                radarPlayers[player].name.OutlineColor = Color3.new(0, 0, 0)
            end
            
            if player.Team == LocalPlayer.Team then
                radarPlayers[player].dot.Color = Color3.new(0, 1, 0)  
                radarPlayers[player].direction.Color = Color3.new(0, 0.8, 0)
                radarPlayers[player].name.Color = Color3.new(0, 1, 0)
            else
                radarPlayers[player].dot.Color = Color3.new(1, 0, 0) 
                radarPlayers[player].direction.Color = Color3.new(1, 0, 0)
                radarPlayers[player].name.Color = Color3.new(1, 0, 0)
            end
            
            radarPlayers[player].dot.Position = Vector2.new(radarX, radarY)
            radarPlayers[player].dot.Visible = true
            
            local lookVector = rootPart.CFrame.LookVector
            local directionLength = 10
            radarPlayers[player].direction.From = Vector2.new(radarX, radarY)
            radarPlayers[player].direction.To = Vector2.new(
                radarX + lookVector.X * directionLength,
                radarY + lookVector.Z * directionLength
            )
            
            radarPlayers[player].name.Position = Vector2.new(radarX, radarY - 15)
            radarPlayers[player].name.Text = player.Name
            radarPlayers[player].name.Visible = distanceFromCenter <= radar.Radius
        elseif radarPlayers[player] then
            radarPlayers[player].dot.Visible = false
            radarPlayers[player].direction.Visible = false
            radarPlayers[player].name.Visible = false
        end
    end
    
    for player, components in pairs(radarPlayers) do
        if not Players:FindFirstChild(player.Name) then
            components.dot.Visible = false
            components.direction.Visible = false
            components.name.Visible = false
            radarPlayers[player] = nil
        end
    end
end

RunService.RenderStepped:Connect(updateRadar)

for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        createESP(player)
    end
end

game:GetService("Players").PlayerAdded:Connect(function(player)
    if player ~= game.Players.LocalPlayer then
        createESP(player)
    end
end)

game:GetService("Players").PlayerRemoving:Connect(function(player)
    if ESPComponents[player] then
        for _, component in pairs(ESPComponents[player]) do
            if typeof(component) == "table" then
                for _, drawing in pairs(component) do
                    drawing:Remove()
                end
            else
                component:Remove()
            end
        end
        ESPComponents[player] = nil
    end
end)

B:Toggle({
    Title = "方框透视", 
    Value = false, 
    Callback = function(Value)
        getgenv().ShowBox = Value
    end
})

B:Toggle({
    Title = "血量显示", 
    Value = false, 
    Callback = function(Value)
        getgenv().ShowHealth = Value
    end
})

B:Toggle({
    Title = "名字显示", 
    Value = false, 
    Callback = function(Value)
        getgenv().ShowName = Value
    end
})

B:Toggle({
    Title = "距离显示", 
    Value = false, 
    Callback = function(Value)
        getgenv().ShowDistance = Value
    end
})

B:Toggle({
    Title = "武器显示", 
    Value = false, 
    Callback = function(Value)
        getgenv().ShowWeapon = Value
    end
})

B:Toggle({
    Title = "射线显示", 
    Value = false, 
    Callback = function(Value)
        getgenv().ShowTracer = Value
    end
})

B:Toggle({
    Title = "骨架显示", 
    Value = false, 
    Callback = function(Value)
        getgenv().ShowSkeleton = Value
    end
})

B:Toggle({
    Title = "雷达系统", 
    Value = false, 
    Callback = function(Value)
        getgenv().ShowRadar = Value
    end
})

local Positions = {
    ["Alpha"] = CFrame.new(-1197, 65, -4790),
    ["Bravo"] = CFrame.new(-220, 65, -4919),
    ["Charlie"] = CFrame.new(797, 65, -4740),
    ["Delta"] = CFrame.new(2044, 65, -3984),
    ["Echo"] = CFrame.new(2742, 65, -3031),
    ["Foxtrot"] = CFrame.new(3045, 65, -1788),
    ["Golf"] = CFrame.new(3376, 65, -562),
    ["Hotel"] = CFrame.new(3290, 65, 587),
    ["Juliet"] = CFrame.new(2955, 65, 1804),
    ["Kilo"] = CFrame.new(2569, 65, 2926),
    ["Lima"] = CFrame.new(989, 65, 3419),
    ["Omega"] = CFrame.new(-319, 65, 3932),
    ["Romeo"] = CFrame.new(-1479, 65, 3722),
    ["Sierra"] = CFrame.new(-2528, 65, 2549),
    ["Tango"] = CFrame.new(-3018, 65, 1503),
    ["Victor"] = CFrame.new(-3587, 65, 634),
    ["Yankee"] = CFrame.new(-3957, 65, -287),
    ["Zulu"] = CFrame.new(-4049, 65, -1334)
}

local BaseList = {
    "Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", 
    "Juliet", "Kilo", "Lima", "Omega", "Romeo", "Sierra", "Tango", "Victor", 
    "Yankee", "Zulu"
}

local selectedBase = nil

local function TeleportToBase(baseName)
    local position = Positions[baseName]
    if position then
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = position
            WindUI:Notify({
                Title = "传送成功",
                Content = "已传送到 " .. baseName .. " 基地",
                Duration = 3,
            })
        end
    end
end

C:Dropdown({
    Title = "传送列表", 
    Values = BaseList, 
    Value = "", 
    Callback = function(baseName) 
        selectedBase = baseName
    end
})

C:Button({
    Title = "传送到目标基地",
    Callback = function()
        if selectedBase and selectedBase ~= "" then
            TeleportToBase(selectedBase)
        else
            WindUI:Notify({
                Title = "提示",
                Content = "请先选择一个基地",
                Duration = 3,
            })
        end
    end
})

C:Divider({
    Text = "其他传送"
})

C:Button({
    Title = "返回基地",
    Callback = function()
        local player = game.Players.LocalPlayer
        local tycoon = workspace.Tycoon.Tycoons:FindFirstChild(player.leaderstats.Team.Value)
        if tycoon and tycoon:FindFirstChild("Essentials") and tycoon.Essentials:FindFirstChild("Spawn") then
            player.Character.HumanoidRootPart.CFrame = tycoon.Essentials.Spawn.CFrame
            WindUI:Notify({
                Title = "传送成功",
                Content = "已返回基地",
                Duration = 3,
            })
        end
    end
})

C:Button({
    Title = "随机传送",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local randomPos = Vector3.new(math.random(-500, 500),100,math.random(-500, 500))
            player.Character.HumanoidRootPart.CFrame = CFrame.new(randomPos)
            WindUI:Notify({
                Title = "传送成功",
                Content = "已随机传送",
                Duration = 3,
            })
        end
    end
})

C:Button({
    Title = "捕捉点",
    Callback = function()
        local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
        local location = CFrame.new(-652.087158203125, 121.78434753417969, -1259.2510986328125)
        local Humanoid = game.Players.LocalPlayer.Character.Humanoid
        Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        wait(0.2)
        pl.CFrame = location
    end
})

C:Button({
    Title = "捕捉点高楼",
    Callback = function()
        local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
        local location = CFrame.new(-216.8485565185547, 447.56982421875, -1514.64599609375)
        local Humanoid = game.Players.LocalPlayer.Character.Humanoid
        Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        wait(0.2)
        pl.CFrame = location
    end
})

C:Button({
    Title = "传送油桶1",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        local targetPart = workspace:FindFirstChild("Game Systems")
            and workspace["Game Systems"]:FindFirstChild("Warehouses")
            and workspace["Game Systems"].Warehouses:FindFirstChild("Dock Warehouse1")
            and workspace["Game Systems"].Warehouses["Dock Warehouse1"]["Oil Capture"]
            and workspace["Game Systems"].Warehouses["Dock Warehouse1"]["Oil Capture"]["Barrel Template"]
            and workspace["Game Systems"].Warehouses["Dock Warehouse1"]["Oil Capture"]["Barrel Template"].PromptPart

        if rootPart and targetPart then
            rootPart.CFrame = targetPart.CFrame
            WindUI:Notify({
                Title = "传送成功",
                Content = "已传送到油桶1",
                Duration = 3,
            })
        else
            WindUI:Notify({
                Title = "传送失败",
                Content = "未找到油桶1",
                Duration = 3,
            })
        end
    end
})

C:Button({
    Title = "传送油桶2",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        local targetPart = workspace:FindFirstChild("Game Systems")
            and workspace["Game Systems"]:FindFirstChild("Warehouses")
            and workspace["Game Systems"].Warehouses:FindFirstChild("Oil Rig1")
            and workspace["Game Systems"].Warehouses["Oil Rig1"]["Oil Capture"]
            and workspace["Game Systems"].Warehouses["Oil Rig1"]["Oil Capture"]["Barrel Template"]
            and workspace["Game Systems"].Warehouses["Oil Rig1"]["Oil Capture"]["Barrel Template"].PromptPart

        if rootPart and targetPart then
            rootPart.CFrame = targetPart.CFrame
            WindUI:Notify({
                Title = "传送成功",
                Content = "已传送到油桶2",
                Duration = 3,
            })
        else
            WindUI:Notify({
                Title = "传送失败",
                Content = "未找到油桶2",
                Duration = 3,
            })
        end
    end
})

C:Button({
    Title = "传送油桶3",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        local targetPart = workspace:FindFirstChild("Game Systems")
            and workspace["Game Systems"]:FindFirstChild("Warehouses")
            and workspace["Game Systems"].Warehouses:FindFirstChild("Oil Rig2")
            and workspace["Game Systems"].Warehouses["Oil Rig2"]["Oil Capture"]
            and workspace["Game Systems"].Warehouses["Oil Rig2"]["Oil Capture"]["Barrel Template"]
            and workspace["Game Systems"].Warehouses["Oil Rig2"]["Oil Capture"]["Barrel Template"].PromptPart

        if rootPart and targetPart then
            rootPart.CFrame = targetPart.CFrame
            WindUI:Notify({
                Title = "传送成功",
                Content = "已传送到油桶3",
                Duration = 3,
            })
        else
            WindUI:Notify({
                Title = "传送失败",
                Content = "未找到油桶3",
                Duration = 3,
            })
        end
    end
})

C:Button({
    Title = "传送油桶4",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        local targetPart = workspace:FindFirstChild("Game Systems")
            and workspace["Game Systems"]:FindFirstChild("Warehouses")
            and workspace["Game Systems"].Warehouses:FindFirstChild("Oil Rig3")
            and workspace["Game Systems"].Warehouses["Oil Rig3"]["Oil Capture"]
            and workspace["Game Systems"].Warehouses["Oil Rig3"]["Oil Capture"]["Barrel Template"]
            and workspace["Game Systems"].Warehouses["Oil Rig3"]["Oil Capture"]["Barrel Template"].PromptPart

        if rootPart and targetPart then
            rootPart.CFrame = targetPart.CFrame
            WindUI:Notify({
                Title = "传送成功",
                Content = "已传送到油桶4",
                Duration = 3,
            })
        else
            WindUI:Notify({
                Title = "传送失败",
                Content = "未找到油桶4",
                Duration = 3,
            })
        end
    end
})

local fov = 50
local maxDistance = 500
local autoAimEnabled = false
local fovVisible = false
local ignoreCover = false
local aimTarget = "敌对"
local aimPosition = "Head"
local rainbowEnabled = false
local fovColor = Color3.new(1, 1, 1)

local whitelistPlayers = {}
local playerDropdown

local FOVring = Drawing.new("Circle")
FOVring.Visible = false
FOVring.Thickness = 1
FOVring.Color = fovColor
FOVring.Filled = false
FOVring.Radius = fov
FOVring.Position = workspace.CurrentCamera.ViewportSize / 2

local function refreshPlayerList()
    local playerList = {}
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(playerList, player.Name)
        end
    end
    playerDropdown:Refresh(playerList)
end

local function updateDrawings()
    FOVring.Position = workspace.CurrentCamera.ViewportSize / 2
end

local function lookAt(target)
    local lookVector = (target - workspace.CurrentCamera.CFrame.Position).unit
    local newCFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, workspace.CurrentCamera.CFrame.Position + lookVector)
    workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(newCFrame, 0.7)
end

local function getClosestPlayerInFOV(trg_part)
    local nearest = nil
    local last = math.huge
    local playerMousePos = workspace.CurrentCamera.ViewportSize / 2
    
    for _, player in ipairs(game.Players:GetPlayers()) do
        if whitelistPlayers[player.Name] then
            continue
        end
        
        if player ~= game.Players.LocalPlayer and (aimTarget == "全部" or player.Team ~= game.Players.LocalPlayer.Team) then
            local character = player.Character
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")
            local part = character and character:FindFirstChild(trg_part)
            
            if part and humanoid and humanoid.Health > 0 then
                local ePos, isVisible = workspace.CurrentCamera:WorldToViewportPoint(part.Position)
                local distance = (Vector2.new(ePos.x, ePos.y) - playerMousePos).Magnitude
                
                if distance < last and isVisible and distance < fov then
                    if (part.Position - workspace.CurrentCamera.CFrame.Position).Magnitude <= tonumber(maxDistance) then
                        if not ignoreCover or #workspace.CurrentCamera:GetPartsObscuringTarget({part.Position}, {character, game.Players.LocalPlayer.Character}) == 0 then
                            last = distance
                            nearest = player
                        end
                    end
                end
            end
        end
    end
    
    return nearest
end

game:GetService("RunService").RenderStepped:Connect(function()
    updateDrawings()
    
    if autoAimEnabled then
        local closestPlayer = getClosestPlayerInFOV(aimPosition)
        if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild(aimPosition) then
            lookAt(closestPlayer.Character[aimPosition].Position)
        end
    end
    
    if rainbowEnabled then
        local t = tick() * 2
        local r = math.abs(math.sin(t))
        local g = math.abs(math.sin(t + 2 * math.pi / 3))
        local b = math.abs(math.sin(t + 4 * math.pi / 3))
        FOVring.Color = Color3.new(r, g, b)
    end
end)

game.Players.PlayerAdded:Connect(function(player)
    wait(0.5)
    refreshPlayerList()
end)

game.Players.PlayerRemoving:Connect(function(player)
    wait(0.5)
    refreshPlayerList()
    if whitelistPlayers[player.Name] then
        whitelistPlayers[player.Name] = nil
    end
end)

D:Toggle({
    Title = "玩家自瞄",
    Value = false,
    Callback = function(t)
        autoAimEnabled = t
    end
})

D:Toggle({
    Title = "显示范围",
    Value = false,
    Callback = function(t)
        fovVisible = t
        FOVring.Visible = fovVisible
    end
})

D:Toggle({
    Title = "掩体不瞄",
    Value = false,
    Callback = function(t)
        ignoreCover = t
    end
})

D:Slider({
    Title = "自瞄范围",
    Step = 1,
    Value = {Min = 1, Max = 200, Default = 50},
    Callback = function(s)
        fov = tonumber(s)
        FOVring.Radius = fov
    end
})

D:Slider({
    Title = "自瞄距离",
    Step = 1,
    Value = {Min = 1, Max = 10000, Default = 500},
    Callback = function(s)
        maxDistance = tonumber(s)
    end
})

D:Slider({
    Title = "自瞄圈粗细",
    Step = 1,
    Value = {Min = 0.5, Max = 10, Default = 1},
    Callback = function(s)
        FOVring.Thickness = tonumber(s)
    end
})

D:Dropdown({
    Title = "选择自瞄目标", 
    Values = {"敌对", "全部"}, 
    Value = "敌对", 
    Callback = function(value) 
        aimTarget = value 
    end
})

D:Dropdown({
    Title = "选择自瞄位置", 
    Values = {"头部", "躯干"}, 
    Value = "头部", 
    Callback = function(value)
        if value == "头部" then
            aimPosition = "Head"
        elseif value == "躯干" then
            aimPosition = "Torso"
        end
    end
})

D:Dropdown({
    Title = "选择圈的颜色", 
    Values = {"白", "红", "黄", "蓝", "绿", "青", "紫", "彩虹"}, 
    Value = "白", 
    Callback = function(value)
        if value == "彩虹" then
            rainbowEnabled = true
        else
            rainbowEnabled = false
            local colors = {
                ["白"] = Color3.new(1, 1, 1),
                ["红"] = Color3.new(1, 0, 0),
                ["黄"] = Color3.new(1, 1, 0),
                ["蓝"] = Color3.new(0, 0, 1),
                ["绿"] = Color3.new(0, 1, 0),
                ["青"] = Color3.new(0, 1, 1),
                ["紫"] = Color3.new(1, 0, 1)
            }
            fovColor = colors[value]
            FOVring.Color = fovColor
        end
    end
})

playerDropdown = D:Dropdown({
    Title = "忽略玩家(白名单)", 
    Values = {}, 
    Value = {}, 
    Multi = true, 
    AllowNone = true, 
    Callback = function(selectedPlayers) 
        whitelistPlayers = {}
        for _, playerName in ipairs(selectedPlayers) do
            whitelistPlayers[playerName] = true
        end
    end
})

D:Button({
    Title = "刷新玩家列表",
    Callback = function()
        refreshPlayerList()
        WindUI:Notify({
            Title = "刷新成功",
            Content = "玩家列表已更新",
            Duration = 2,
        })
    end
})

refreshPlayerList()

local bulletTrackEnabled = false
local bulletTrackTarget = "头部"
local bulletTrackWhitelist = {}
local bulletTrackFOV = 50
local bulletTrackShowFOV = false
local bulletTrackFOVColor = Color3.new(1, 1, 1)
local bulletTrackRainbow = false
local oldHook = nil
local currentPlayerList = {}

local BulletTrackFOV = Drawing.new("Circle")
BulletTrackFOV.Visible = false
BulletTrackFOV.Thickness = 1
BulletTrackFOV.Color = bulletTrackFOVColor
BulletTrackFOV.Filled = false
BulletTrackFOV.Radius = bulletTrackFOV
BulletTrackFOV.Position = workspace.CurrentCamera.ViewportSize / 2

local function getPlayerList()
    local players = {}
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(players, player.Name)
        end
    end
    return players
end

currentPlayerList = getPlayerList()

local function setupBulletTracking()
    local Workspace = game:GetService("Workspace")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Camera = Workspace.CurrentCamera
    
    local function isInFOV(playerCharacter)
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return false
        end
        
        if bulletTrackFOV >= 200 then
            return true
        end
        
        local targetPart = nil
        if bulletTrackTarget == "头部" then
            targetPart = playerCharacter:FindFirstChild("Head")
        else
            targetPart = playerCharacter:FindFirstChild("HumanoidRootPart") or playerCharacter:FindFirstChild("Torso")
        end
        
        if not targetPart then return false end
        
        local targetPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then return false end
        
        local screenCenter = Camera.ViewportSize / 2
        local targetScreenPos = Vector2.new(targetPos.X, targetPos.Y)
        local distance = (targetScreenPos - screenCenter).Magnitude
        
        return distance <= bulletTrackFOV
    end
    
    local function getClosestTarget()
        if not LocalPlayer.Character then return nil end
        if not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return nil end
        
        local closestTarget = nil
        local closestDistance = math.huge
        
        for _, player in ipairs(Players:GetPlayers()) do
            if table.find(bulletTrackWhitelist, player.Name) then
                continue
            end
            
            if player ~= LocalPlayer and player.Character then
                local character = player.Character
                local root = character:FindFirstChild("HumanoidRootPart")
                local targetPart = nil
                
                if bulletTrackTarget == "头部" then
                    targetPart = character:FindFirstChild("Head")
                else
                    targetPart = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
                end
                
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local forcefield = character:FindFirstChild("ForceField")
                
                if root and targetPart and humanoid and not forcefield and humanoid.Health > 0 then
                    if bulletTrackFOV < 200 and not isInFOV(character) then
                        continue
                    end
                    
                    local distance = (root.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance < closestDistance then
                        closestTarget = targetPart
                        closestDistance = distance
                    end
                end
            end
        end
        
        return closestTarget
    end
    
    if not oldHook then
        oldHook = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if bulletTrackEnabled and method == "Raycast" and not checkcaller() then
                local origin = args[1] or Camera.CFrame.Position
                local closestTarget = getClosestTarget()
                
                if closestTarget then
                    return {
                        Instance = closestTarget,
                        Position = closestTarget.Position,
                        Normal = (origin - closestTarget.Position).Unit,
                        Material = Enum.Material.Plastic,
                        Distance = (closestTarget.Position - origin).Magnitude
                    }
                end
            end
            
            return oldHook(self, ...)
        end)
    end
end

game:GetService("RunService").RenderStepped:Connect(function()
    BulletTrackFOV.Position = workspace.CurrentCamera.ViewportSize / 2
    BulletTrackFOV.Radius = bulletTrackFOV
    
    if bulletTrackRainbow then
        local t = tick() * 2
        local r = math.abs(math.sin(t))
        local g = math.abs(math.sin(t + 2 * math.pi / 3))
        local b = math.abs(math.sin(t + 4 * math.pi / 3))
        BulletTrackFOV.Color = Color3.new(r, g, b)
    else
        BulletTrackFOV.Color = bulletTrackFOVColor
    end
end)

E:Toggle({
    Title = "子弹追踪总开关",
    Value = false,
    Callback = function(state)
        bulletTrackEnabled = state
        if state then
            setupBulletTracking()
            WindUI:Notify({
                Title = "子弹追踪",
                Content = "子弹追踪已开启",
                Duration = 2,
            })
        else
            if oldHook then
                hookmetamethod(game, "__namecall", oldHook)
                oldHook = nil
            end
            WindUI:Notify({
                Title = "子弹追踪",
                Content = "子弹追踪已关闭",
                Duration = 2,
            })
        end
    end
})

E:Toggle({
    Title = "显示追踪范围",
    Value = false,
    Callback = function(state)
        bulletTrackShowFOV = state
        BulletTrackFOV.Visible = state
    end
})

E:Slider({
    Title = "追踪范围大小",
    Step = 1,
    Value = {Min = 10, Max = 400, Default = 50},
    Callback = function(value)
        bulletTrackFOV = value
        BulletTrackFOV.Radius = value
    end
})

E:Slider({
    Title = "追踪范围粗细",
    Step = 1,
    Value = {Min = 0.5, Max = 5, Default = 1},
    Callback = function(value)
        BulletTrackFOV.Thickness = value
    end
})

E:Dropdown({
    Title = "追踪部位",
    Values = {"头部", "身体"},
    Value = "头部",
    Callback = function(value)
        bulletTrackTarget = value
    end
})

E:Dropdown({
    Title = "追踪圈颜色",
    Values = {"白", "红", "黄", "蓝", "绿", "青", "紫", "彩虹"},
    Value = "白",
    Callback = function(value)
        if value == "彩虹" then
            bulletTrackRainbow = true
        else
            bulletTrackRainbow = false
            local colors = {
                ["白"] = Color3.new(1, 1, 1),
                ["红"] = Color3.new(1, 0, 0),
                ["黄"] = Color3.new(1, 1, 0),
                ["蓝"] = Color3.new(0, 0, 1),
                ["绿"] = Color3.new(0, 1, 0),
                ["青"] = Color3.new(0, 1, 1),
                ["紫"] = Color3.new(1, 0, 1)
            }
            bulletTrackFOVColor = colors[value]
        end
    end
})

local whitelistDropdown = E:Dropdown({
    Title = "追踪白名单(不追踪的玩家)",
    Values = currentPlayerList,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selectedPlayers)
        bulletTrackWhitelist = selectedPlayers or {}
        WindUI:Notify({
            Title = "子弹追踪",
            Content = "白名单已更新为",
            Duration = 3,
        })
    end
})

E:Button({
    Title = "刷新玩家列表",
    Callback = function()
        currentPlayerList = getPlayerList()
        whitelistDropdown:Refresh(currentPlayerList)
        WindUI:Notify({
            Title = "子弹追踪",
            Content = "玩家列表已刷新",
            Duration = 2,
        })
    end
})

local C_NPlayers = {}
local Plr = game:GetService("Players")
local LP = Plr.LocalPlayer
local PlayerList = {}

local function initializePlayerList()
    PlayerList = {}
    for _, player in ipairs(Plr:GetPlayers()) do
        if player ~= LP then
            table.insert(PlayerList, player.Name)
        end
    end
end

local function refreshAttackPlayerList()
    initializePlayerList()
    if excludeTargetsDropdown then
        excludeTargetsDropdown:Refresh(PlayerList)
    end
end

Plr.PlayerAdded:Connect(function(player)
    if player ~= LP then
        table.insert(PlayerList, player.Name)
        if excludeTargetsDropdown then
            excludeTargetsDropdown:Refresh(PlayerList)
        end
    end
end)

Plr.PlayerRemoving:Connect(function(player)
    local index = table.find(PlayerList, player.Name)
    if index then
        table.remove(PlayerList, index)
        local whitelistIndex = table.find(C_NPlayers, player.Name)
        if whitelistIndex then
            table.remove(C_NPlayers, whitelistIndex)
        end
        if excludeTargetsDropdown then
            excludeTargetsDropdown:Refresh(PlayerList)
        end
    end
end)

initializePlayerList()

local excludeTargetsDropdown = F:Dropdown({
    Title = "忽略玩家(白名单)", 
    Values = PlayerList, 
    Value = {}, 
    Multi = true, 
    AllowNone = true, 
    Callback = function(values) 
        C_NPlayers = values or {}
        WindUI:Notify({
            Title = "白名单列表",
            Content = "已设置 " .. #C_NPlayers .. " 个玩家为白名单",
            Duration = 3,
        })
    end
})

F:Button({
    Title = "刷新玩家列表",
    Callback = function()
        refreshAttackPlayerList()
    end
})

F:Button({
    Title = "获取RPG",
    Callback = function()
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local TweenService = game:GetService("TweenService")
        local LPlayer = Players.LocalPlayer
        
        if LPlayer.Character and LPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local HumanoidRootPart = LPlayer.Character.HumanoidRootPart
            local initialPosition = HumanoidRootPart.CFrame
            
            local function hasRPG() 
                return LPlayer.Backpack:FindFirstChild("RPG") or LPlayer.Character:FindFirstChild("RPG") 
            end
            
            local function findClosestRPGGiver()
                local closestRPGGiver = nil
                local closestDistance = math.huge
                
                for _, tycoon in pairs(Workspace.Tycoon.Tycoons:GetChildren()) do
                    local rpgGiver = tycoon:FindFirstChild("PurchasedObjects") and tycoon.PurchasedObjects:FindFirstChild("RPG Giver")
                    if rpgGiver and rpgGiver:FindFirstChild("Prompt") and rpgGiver.Prompt:FindFirstChild("Weapon Giver") then
                        local part = rpgGiver:FindFirstChildWhichIsA("BasePart")
                        if part then
                            local distance = (HumanoidRootPart.Position - part.Position).Magnitude
                            if distance < closestDistance then
                                closestDistance = distance
                                closestRPGGiver = rpgGiver
                            end
                        end
                    end
                end
                return closestRPGGiver
            end
            
            local function teleportTo(targetCFrame)
                local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(HumanoidRootPart, tweenInfo, {CFrame = targetCFrame})
                tween:Play()
                tween.Completed:Wait()
            end
            
            local function activatePrompt(prompt)
                if prompt then
                    prompt.MaxActivationDistance = 10
                    fireproximityprompt(prompt)
                end
            end
            
            local function collectRPG()
                local closestRPGGiver = findClosestRPGGiver()
                if not closestRPGGiver then 
                    WindUI:Notify({
                        Title = "ERROR",
                        Content = "未能找到附近的RPG",
                        Duration = 4,
                    })
                    return 
                end
                
                local part = closestRPGGiver:FindFirstChildWhichIsA("BasePart")
                if part then
                    teleportTo(part.CFrame + Vector3.new(3, 0, 0))
                    task.wait(0.5)
                    
                    local prompt = closestRPGGiver.Prompt:FindFirstChild("Weapon Giver")
                    activatePrompt(prompt)
                    
                    local timeout = 0
                    while not hasRPG() and timeout < 50 do
                        activatePrompt(prompt)
                        task.wait(0.1)
                        timeout = timeout + 1
                    end
                    
                    if hasRPG() then
                        WindUI:Notify({
                            Title = "成功",
                            Content = "已获取RPG",
                            Duration = 3,
                        })
                    else
                        WindUI:Notify({
                            Title = "失败",
                            Content = "获取RPG超时",
                            Duration = 3,
                        })
                    end
                end
                teleportTo(initialPosition)
            end
            
            if not hasRPG() then 
                collectRPG() 
            else 
                WindUI:Notify({
                    Title = "提示",
                    Content = "已经拥有RPG",
                    Duration = 3,
                })
            end
        end
    end
})

local loopActive = false
local rpgAttackThread = nil

F:Toggle({
    Title = "RPG轰炸",
    Value = false,
    Callback = function(t)
        loopActive = t
        
        if t then
            if rpgAttackThread then
                coroutine.close(rpgAttackThread)
                rpgAttackThread = nil
            end
            
            rpgAttackThread = coroutine.create(function()
                local Players = game:GetService("Players")
                local LocalPlayer = Players.LocalPlayer
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RocketSystem = ReplicatedStorage:WaitForChild("RocketSystem")
                local FireRocket = RocketSystem.Events.FireRocket
                local RocketHit = RocketSystem.Events.RocketHit
                local attackPhase = "attack"
                local phaseStartTime = os.clock()
                
                while loopActive do
                    local currentTime = os.clock()
                    local elapsed = currentTime - phaseStartTime
                    
                    if not loopActive then break end
                    
                    if attackPhase == "attack" then
                        if elapsed >= 3 then
                            attackPhase = "pause"
                            phaseStartTime = os.clock()
                        else
                            local character = LocalPlayer.Character
                            if character and character:FindFirstChild("HumanoidRootPart") then
                                local attackPosition = character.HumanoidRootPart.Position + Vector3.new(0, 1000, 0)
                                local weapon = character:FindFirstChild("RPG")
                                
                                if weapon then
                                    for _, player in ipairs(Players:GetPlayers()) do
                                        if player ~= LocalPlayer and player.Character and not table.find(C_NPlayers, player.Name) then
                                            local target = player.Character:FindFirstChild("HumanoidRootPart")
                                            if target then
                                                FireRocket:InvokeServer(Vector3.new(), weapon, weapon, attackPosition)
                                                RocketHit:FireServer(attackPosition, Vector3.new(), weapon, weapon, target, nil, "asdfghvcqawRocket4")
                                                task.wait(0.3)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    elseif attackPhase == "pause" then
                        if elapsed >= 2 then
                            attackPhase = "attack"
                            phaseStartTime = os.clock()
                        end
                    end
                    
                    task.wait(0.1)
                end
            end)
            
            coroutine.resume(rpgAttackThread)
        else
            if rpgAttackThread then
                coroutine.close(rpgAttackThread)
                rpgAttackThread = nil
            end
        end
    end
})

local shieldAttackActive = false
local shieldAttackThread = nil

F:Toggle({
    Title = "攻击护盾",
    Value = false,
    Callback = function(t)
        shieldAttackActive = t
        
        if t then
            if shieldAttackThread then
                coroutine.close(shieldAttackThread)
                shieldAttackThread = nil
            end
            
            shieldAttackThread = coroutine.create(function()
                while shieldAttackActive do
                    if not shieldAttackActive then break end
                    
                    local rpg = LP.Character and LP.Character:FindFirstChild("RPG")
                    if not rpg then
                        task.wait(1)
                        continue
                    end
                    
                    local attackPosition = LP.Character.HumanoidRootPart.Position + Vector3.new(0, 1000, 0)
                    local tycoonFolder = workspace:WaitForChild("Tycoon"):WaitForChild("Tycoons")
                    
                    for _, tycoon in ipairs(tycoonFolder:GetChildren()) do
                        if not shieldAttackActive then break end
                        
                        if tycoon:FindFirstChild("Owner") and tycoon.Owner.Value ~= LP then
                            local shield = tycoon:FindFirstChild("PurchasedObjects", true) and
                                          tycoon.PurchasedObjects:FindFirstChild("Base Shield", true) and
                                          tycoon.PurchasedObjects["Base Shield"]:FindFirstChild("Shield", true) and
                                          tycoon.PurchasedObjects["Base Shield"].Shield:FindFirstChild("Shield4", true)
                            
                            if shield then
                                local fireArgs = { Vector3.new(0, 0, 0), rpg, rpg, attackPosition }
                                
                                for _ = 1, 2 do
                                    local hitArgs = {attackPosition, Vector3.new(0, -1, 0), rpg, rpg, shield, nil, string.format("%sRocket%d", string.char(math.random(65, 90)), math.random(1, 1000))}
                                    RocketSystem.Events.RocketHit:FireServer(unpack(hitArgs))
                                    RocketSystem.Events.FireRocket:InvokeServer(unpack(fireArgs))
                                    task.wait(0.3)
                                end
                            end
                        end
                    end
                    
                    task.wait(0.3)
                end
            end)
            
            coroutine.resume(shieldAttackThread)
        else
            if shieldAttackThread then
                coroutine.close(shieldAttackThread)
                shieldAttackThread = nil
            end
        end
    end
})

F:Divider({
    Text = "其他类2"
})

local shieldAttackActive = false
local shieldAttackThread = nil

F:Toggle({
    Title = "爆炸狙光环",
    Value = false,
    Callback = function(state)
        getgenv().ExplosiveSniper = state
        
        local function modifySniper()
            local player = game.Players.LocalPlayer
            local backpack = player.Backpack
            
            for _, tool in ipairs(backpack:GetChildren()) do
                local settingsModule = tool:FindFirstChild("ACS_Modulo") and 
                                      tool["ACS_Modulo"]:FindFirstChild("Variaveis") and 
                                      tool["ACS_Modulo"]["Variaveis"]:FindFirstChild("Settings")
                if settingsModule then
                    local success, gun = pcall(require, settingsModule)
                    if success then
                        if getgenv().ExplosiveSniper then
                            if gun["Bullets"] then gun["Bullets"] = 1 end
                            if gun["Ammo"] then gun["Ammo"] = 5000000 end
                            if gun["Mode"] then gun["Mode"] = "Auto" end
                            if gun["FireModes"] and gun["FireModes"]["Auto"] ~= nil then gun["FireModes"]["Auto"] = true end
                            if gun["FireRate"] then gun["FireRate"] = 1000000000 end
                            if gun["DamageMultiplier"] then gun["DamageMultiplier"] = 1000000000 end
                            if gun["Distance"] then gun["Distance"] = 1000000000 end
                            if gun["VRecoil"] then gun["VRecoil"] = {0, 0} end
                            if gun["HRecoil"] then gun["HRecoil"] = {0, 0} end
                            if gun["RecoilPunch"] then gun["RecoilPunch"] = 0 end
                            if gun["VPunchBase"] then gun["VPunchBase"] = 0 end
                            if gun["HPunchBase"] then gun["HPunchBase"] = 0 end
                            if gun["DPunchBase"] then gun["DPunchBase"] = 0 end
                            if gun["MinRecoilPower"] then gun["MinRecoilPower"] = 0 end
                            if gun["MaxRecoilPower"] then gun["MaxRecoilPower"] = 0 end
                            if gun["BSpeed"] then gun["BSpeed"] = 100000000 end
                            if gun["BDrop"] then gun["BDrop"] = 0 end
                            if gun["MinSpread"] then gun["MinSpread"] = 0 end
                            if gun["MaxSpread"] then gun["MaxSpread"] = 0 end
                            
                            WindUI:Notify({
                                Title = "爆炸狙关环",
                                Content = "开",
                                Duration = 3,
                            })
                        else
                            if gun["Bullets"] then gun["Bullets"] = 1 end
                            if gun["Ammo"] then gun["Ammo"] = 30 end
                            if gun["Mode"] then gun["Mode"] = "Semi" end
                            if gun["FireModes"] and gun["FireModes"]["Auto"] ~= nil then gun["FireModes"]["Auto"] = false end
                            if gun["FireRate"] then gun["FireRate"] = 60 end
                            if gun["DamageMultiplier"] then gun["DamageMultiplier"] = 1 end
                            if gun["Distance"] then gun["Distance"] = 500 end
                            if gun["VRecoil"] then gun["VRecoil"] = {1, 2} end
                            if gun["HRecoil"] then gun["HRecoil"] = {-1, 1} end
                            if gun["RecoilPunch"] then gun["RecoilPunch"] = 1 end
                            if gun["VPunchBase"] then gun["VPunchBase"] = 1 end
                            if gun["HPunchBase"] then gun["HPunchBase"] = 1 end
                            if gun["DPunchBase"] then gun["DPunchBase"] = 1 end
                            if gun["MinRecoilPower"] then gun["MinRecoilPower"] = 1 end
                            if gun["MaxRecoilPower"] then gun["MaxRecoilPower"] = 2 end
                            if gun["BSpeed"] then gun["BSpeed"] = 1000 end
                            if gun["BDrop"] then gun["BDrop"] = 0.1 end
                            if gun["MinSpread"] then gun["MinSpread"] = 0.01 end
                            if gun["MaxSpread"] then gun["MaxSpread"] = 0.05 end
                            
                            WindUI:Notify({
                                Title = "爆炸狙光环",
                                Content = "关",
                                Duration = 3,
                            })
                        end
                    end
                end
            end
        end
        
        modifySniper()
        
        if getgenv().ExplosiveSniper then
            if not getgenv().sniperListener then
                getgenv().sniperListener = game.Players.LocalPlayer.Backpack.ChildAdded:Connect(function(tool)
                    task.wait(0.5)
                    modifySniper()
                end)
            end
        else
            if getgenv().sniperListener then
                getgenv().sniperListener:Disconnect()
                getgenv().sniperListener = nil
            end
        end
    end
})

G:Paragraph({
    Title = "关于",
    Desc = "功能在下\n \n无限子弹教程\n首先拿着要改的枪\n启动hook功能并换子弹\n关闭hook功能后点击切枪or开枪即可 \n \n射速教程\n首先拿着要改的枪\n启动hook功能并换子弹\n切3次枪后\n切枪的自动射击模式\n然后关闭hook功能不用切开枪即可\n改得最好的是步枪\n觉得麻烦你就只玩无限子弹就行\n注意的是改后切枪失去射速\n \nRPG可以直接改无限和射速",
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local gunEnabled = false
local gunConnection = nil
local deathConnection = nil
local originalGunData = {}

local function modifyGuns()
    for i, v in next, getgc(false) do
        if typeof(v) == "function" then
            local info = getinfo(v)
            if tostring(info.name) == "fireGun" then
                local gunTable = getupvalue(v, 1)
                
                if not originalGunData[gunTable] then
                    originalGunData[gunTable] = {}
                    for key, value in pairs(gunTable) do
                        if typeof(value) ~= "function" then
                            originalGunData[gunTable][key] = value
                        end
                    end
                    
                    for key, value in pairs(gunTable) do
                        if typeof(value) == "table" then
                            originalGunData[gunTable][key] = {}
                            for subKey, subValue in pairs(value) do
                                originalGunData[gunTable][key][subKey] = subValue
                            end
                        end
                    end
                end
                
                rawset(gunTable, "Ammo", math.huge)
                rawset(gunTable, "Distance", math.huge)
                rawset(gunTable, "BSpeed", 9999)
                rawset(gunTable, "BDrop", 0)
                rawset(gunTable, "FireRate", 2000)
                rawset(gunTable, "MaxSpread", 0)
                rawset(gunTable, "MinSpread", 0)
                rawset(gunTable.FireModes, "Auto", true)
                rawset(gunTable.FireModes, "Semi", true)
                rawset(gunTable.FireModes, "ChangeFiremode", true)
                rawset(gunTable, "MinRecoilPower", 0)
                rawset(gunTable, "MaxRecoilPower", 0)
                rawset(gunTable, "RecoilPowerStepAmount", 0)
                rawset(gunTable, "RecoilPunch", 0)
                rawset(gunTable, "DPunchBase", 0)
                rawset(gunTable, "AimRecover", 1)
                rawset(gunTable, "HPunchBase", 0)
                rawset(gunTable, "VPunchBase", 0)
                rawset(gunTable, "PunchRecover", 1)
                rawset(gunTable, "SwayBase", 0)
                rawset(gunTable, "AimRecoilReduction", math.huge)
                
                for key, value in next, gunTable do
                    if typeof(value) == "table" then
                        for subKey, subValue in next, value do
                            if typeof(subValue) == "number" then
                                rawset(value, subKey, 0)
                            end
                        end
                    end
                end
            end
        end
    end
end

local function resetGuns()
    for gunTable, data in pairs(originalGunData) do
        for key, value in pairs(data) do
            if typeof(value) == "table" then
                if gunTable[key] then
                    for subKey, subValue in pairs(value) do
                        rawset(gunTable[key], subKey, subValue)
                    end
                end
            else
                rawset(gunTable, key, value)
            end
        end
    end
    originalGunData = {}
end

local function onCharacterDeath()
    resetGuns()
    
    if gunEnabled then
        LocalPlayer.CharacterAdded:Wait()
        task.wait(1)
        modifyGuns()
    end
end

local function setupDeathListener()
    if deathConnection then
        deathConnection:Disconnect()
        deathConnection = nil
    end
    
    deathConnection = LocalPlayer.CharacterAdded:Connect(function(char)
        local humanoid = char:WaitForChild("Humanoid")
        humanoid.Died:Connect(onCharacterDeath)
    end)
    
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(onCharacterDeath)
        end
    end
end

G:Toggle({
    Title = "hook实无限+射速",
    Value = false,
    Callback = function(value)
        gunEnabled = value
        
        if value then
            if LocalPlayer.Character then
                modifyGuns()
            end
            
            setupDeathListener()
            
            if gunConnection then
                gunConnection:Disconnect()
            end
            
            gunConnection = LocalPlayer.CharacterAdded:Connect(function()
                if gunEnabled then
                    task.wait(1)
                    modifyGuns()
                    setupDeathListener()
                end
            end)
        else
            resetGuns()
            
            if gunConnection then
                gunConnection:Disconnect()
                gunConnection = nil
            end
            
            if deathConnection then
                deathConnection:Disconnect()
                deathConnection = nil
            end
        end
    end
})

local rapidFireEnabled = false
local rapidFireConnection = nil
local deathConnection = nil
local originalFireRate = {}

local function modifyFireRate()
    for i, v in next, getgc(false) do
        if typeof(v) == "function" then
            local info = getinfo(v)
            if tostring(info.name) == "fireGun" then
                local gunTable = getupvalue(v, 1)
                
                if not originalFireRate[gunTable] then
                    originalFireRate[gunTable] = gunTable.FireRate
                end
                
                rawset(gunTable, "FireRate", 2000)
            end
        end
    end
end

local function resetFireRate()
    for gunTable, originalRate in pairs(originalFireRate) do
        rawset(gunTable, "FireRate", originalRate)
    end
    originalFireRate = {}
end

local function onCharacterDeath()
    resetFireRate()
    
    if rapidFireEnabled then
        game.Players.LocalPlayer.CharacterAdded:Wait()
        task.wait(1)
        modifyFireRate()
    end
end

local function setupDeathListener()
    if deathConnection then
        deathConnection:Disconnect()
        deathConnection = nil
    end
    
    deathConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
        local humanoid = char:WaitForChild("Humanoid")
        humanoid.Died:Connect(onCharacterDeath)
    end)
    
    if game.Players.LocalPlayer.Character then
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(onCharacterDeath)
        end
    end
end

G:Toggle({
    Title = "getgc改表（不建议）",
    Value = false,
    Callback = function(value)
        rapidFireEnabled = value
        
        if value then
            for _,v in next,getgc(false) do
                if typeof(v)=="function"then
                    local info=debug.getinfo(v)
                    if tostring(info.name)=="fireGun"then
                        local tab=debug.getupvalue(v,1)
                        rawset(tab,"Ammo",math.huge)
                        rawset(tab,"Distance",math.huge)
                        rawset(tab,"BSpeed",99999)
                        rawset(tab,"BDrop",0)
                        rawset(tab,"FireRate",2000)
                        rawset(tab,"MaxSpread",0)
                        rawset(tab,"MinSpread",0)
                        rawset(tab.FireModes,"Auto",true)
                        rawset(tab.FireModes,"Semi",true)
                        rawset(tab.FireModes,"ChangeFiremode",true)
                        rawset(tab,"MinRecoilPower",0)
                        rawset(tab,"MaxRecoilPower",0)
                        rawset(tab,"RecoilPowerStepAmount",0)
                        rawset(tab,"RecoilPunch",0)
                        rawset(tab,"DPunchBase",0)
                        rawset(tab,"AimRecover",1)
                        rawset(tab,"HPunchBase",0)
                        rawset(tab,"VPunchBase",0)
                        rawset(tab,"PunchRecover",1)
                        rawset(tab,"SwayBase",0)
                        rawset(tab,"AimRecoilReduction",math.huge)
                        for i,v in next,tab do
                            if typeof(v)=="table"then
                                for i,v in next,v do
                                    if typeof(v)=="number"then
                                        v=0
                                    end
                                end
                            end
                        end
                    end
                end
            end
        else
            for _,v in next,getgc(false) do
                if typeof(v)=="function"then
                    local info=debug.getinfo(v)
                    if tostring(info.name)=="fireGun"then
                        local tab=debug.getupvalue(v,1)
                        rawset(tab,"Ammo",30)
                        rawset(tab,"Distance",100)
                        rawset(tab,"BSpeed",500)
                        rawset(tab,"BDrop",0.5)
                        rawset(tab,"FireRate",60)
                        rawset(tab,"MaxSpread",0.1)
                        rawset(tab,"MinSpread",0.05)
                        rawset(tab.FireModes,"Auto",false)
                        rawset(tab.FireModes,"Semi",true)
                        rawset(tab.FireModes,"ChangeFiremode",true)
                        rawset(tab,"MinRecoilPower",0.5)
                        rawset(tab,"MaxRecoilPower",1.5)
                        rawset(tab,"RecoilPowerStepAmount",0.1)
                        rawset(tab,"RecoilPunch",0.5)
                        rawset(tab,"DPunchBase",0.3)
                        rawset(tab,"AimRecover",0.5)
                        rawset(tab,"HPunchBase",0.2)
                        rawset(tab,"VPunchBase",0.2)
                        rawset(tab,"PunchRecover",0.5)
                        rawset(tab,"SwayBase",0.1)
                        rawset(tab,"AimRecoilReduction",0.3)
                    end
                end
            end
        end
    end
})

local blockFDMG = false
local oldNamecall = nil
local isHookActive = false

local function initHook()
    if isHookActive then return end
    
    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        if blockFDMG and getnamecallmethod() == "FireServer" and tostring(self) == "FDMG" then
            return nil
        end
        return oldNamecall(self, ...)
    end)
    
    isHookActive = true
end

local function removeHook()
    if not isHookActive or not oldNamecall then return end
    
    hookmetamethod(game, "__namecall", oldNamecall)
    oldNamecall = nil
    isHookActive = false
end

H:Divider({
    Text = "其他"
})

H:Toggle({
    Title = "摔落无伤害",
    Value = false,
    Callback = function(value)
        blockFDMG = value
        
        if value then
            if not isHookActive then
                initHook()
            end
        else
            if isHookActive then
                removeHook()
            end
        end
    end
})

H:Button({
    Title = "删除所有门",
    Callback = function()
       for k,v in pairs(Workspace.Tycoon.Tycoons:GetChildren()) do
            for x,y in pairs(v.PurchasedObjects:GetChildren()) do
                if(y.Name:find("Door") or y.Name:find("Gate")) then y:destroy(); end;
            end;
        end;
    end
})

local deathPosition = nil
local deathOrientation = nil
local autoRespawnEnabled = false
local respawnConnection = nil

local function setupDeathTracking()
    local player = game.Players.LocalPlayer
    
    player.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid")
        
        humanoid.Died:Connect(function()
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                deathPosition = rootPart.Position
                deathOrientation = rootPart.CFrame - rootPart.Position
            end
        end)
    end)
    
    if player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    deathPosition = rootPart.Position
                    deathOrientation = rootPart.CFrame - rootPart.Position
                end
            end)
        end
    end
end

setupDeathTracking()

local respawnAtDeathPosition = false
local deathPosition = nil
local deathOrientation = nil

local function setupDeathTracking()
    local player = game.Players.LocalPlayer
    
    player.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid")
        
        humanoid.Died:Connect(function()
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                deathPosition = rootPart.Position
                deathOrientation = rootPart.CFrame - rootPart.Position
            end
        end)
    end)
    
    if player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    deathPosition = rootPart.Position
                    deathOrientation = rootPart.CFrame - rootPart.Position
                end
            end)
        end
    end
end

setupDeathTracking()

H:Divider()

H:Toggle({
    Title = "死后原地重生",
    Value = false,
    Callback = function(state)
        respawnAtDeathPosition = state
    end
})

game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if respawnAtDeathPosition and deathPosition then
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
        local humanoid = character:WaitForChild("Humanoid", 5)
        
        if humanoidRootPart and humanoid then
            wait(0.5)
            humanoidRootPart.CFrame = CFrame.new(deathPosition) * deathOrientation
            deathPosition = nil
            deathOrientation = nil
        end
    end
end)

H:Divider()

H:Toggle({
    Title = "删除死亡镜头",
    Value = false,
    Callback = function(kan)
        getgenv().KillCamSkipEnabled = kan
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local KillCamSkipEvent = ReplicatedStorage.Remotes:WaitForChild("KillCamSkipEvent")
        
        local function startKillCamSkip()
            while getgenv().KillCamSkipEnabled do
                pcall(function()
                    KillCamSkipEvent:FireServer()
                end)
                task.wait(0.4)
            end
        end
        
        task.spawn(function()
            while true do
                if getgenv().KillCamSkipEnabled then
                    startKillCamSkip()
                end
                task.wait(0.1)
            end
        end)
    end
})

H:Toggle({
    Title = "机枪防损坏",
    Value = false,
    Callback = function(state)
        getgenv().BlockCRAMHits = state
        
        local Players = game:GetService("Players")
        local LPlayer = Players.LocalPlayer
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local remote = ReplicatedStorage:WaitForChild("BulletFireSystem"):WaitForChild("RegisterTurretHit")
        
        local function isOwnVehicle(hitPart)
            if not hitPart then return false end
            
            local vehicleWorkspace = workspace:FindFirstChild("Game Systems"):FindFirstChild("Helicopter Workspace")
            if vehicleWorkspace and hitPart:IsDescendantOf(vehicleWorkspace) then
                return true
            end
            return false
        end
        
        local oldNamecall
        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if getgenv().BlockCRAMHits and method == "FireServer" and self == remote then
                local turretPart = args[1] 
                local hitData = args[4] 
                local hitPart = hitData and hitData["hitPart"]
                if turretPart and tostring(turretPart):find("CRAM") and isOwnVehicle(hitPart) then
                    return nil
                end
            end
            return oldNamecall(self, ...)
        end)
    end
})

H:Button({
    Title = "防暴盾牌",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        ReplicatedStorage.BulletFireSystem.GunReload:destroy()
        local gunReload = Instance.new("Part")
        gunReload.Name = "GunReload"
        gunReload.Parent = ReplicatedStorage.BulletFireSystem
        while true do
            wait(0)
            for _, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
                if v.ClassName == "Tool" then v.ACS_Modulo.Variaveis.Ammo.Value = 9999 end
            end
        end
    end
})

H:Button({
    Title = "删除视觉盔甲和头盔",
    Callback = function()
        local character = game.Players.LocalPlayer.Character
        for _, child in pairs(character:GetChildren()) do
            if child.ClassName == "Accessory" then
                child:Destroy()
            elseif child:IsA("BasePart") then
                if child.Name:find("Armor") then
                    if child:FindFirstChild("Mesh") then
                        child.Mesh:Destroy()
                    end
                elseif child.Name:find("Helmet") then
                    child:Destroy()
                end
            end
        end
    end
})

H:Toggle({
    Title = "获取所有玩家背包",
    Value = false,
    Callback = function(state)
        if state then
            task.spawn(function()
                while state do
                    for i,v in pairs(game.Players:GetChildren()) do
                        task.wait()
                        for i,b in pairs(v.Backpack:GetChildren()) do
                            b.Parent = game.Players.LocalPlayer.Backpack
                            task.wait()
                        end
                    end
                end
            end)
        end
    end
})

H:Button({
    Title = "重置角色",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player.Character then 
            player.Character:BreakJoints() 
        end
    end
})

local ps = game:GetService("Players")
local ws = game:GetService("Workspace")
local rs = game:GetService("ReplicatedStorage")
local lp = ps.LocalPlayer

I:Toggle({
    Title = "自动箱子（废在修）",
    Value = false,
    Callback = function(state)
        getgenv().AutoFarm = state
        
        local function setupCharacter()
            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                return character.HumanoidRootPart
            end
            return nil
        end
        
        local hrp = setupCharacter()
        local currentCrate = nil
        local waitingForCrate = false
        
        local function checkForCrates()
            local crates = workspace["Game Systems"]["Crate Workspace"]:GetChildren()
            for _, crate in ipairs(crates) do
                if crate:GetAttribute("Owner") ~= lp.Name then
                    return true
                end
            end
            return false
        end
        
        game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
            task.wait(1)
            hrp = character:WaitForChild("HumanoidRootPart")
        end)
        
        task.spawn(function()
            while true do
                task.wait(0.1)
                
                if not getgenv().AutoFarm then
                    currentCrate = nil
                    waitingForCrate = false
                    task.wait(1)
                    continue
                end
                
                if not hrp or not hrp.Parent then
                    hrp = setupCharacter()
                    if not hrp then
                        task.wait(1)
                        continue
                    end
                end
                
                local player = game.Players.LocalPlayer
                local tycoon = nil
                
                local leaderstats = player:FindFirstChild("leaderstats")
                if leaderstats then
                    local team = leaderstats:FindFirstChild("Team")
                    if team and team.Value then
                        tycoon = workspace.Tycoon.Tycoons:FindFirstChild(team.Value)
                    end
                end
                
                if not tycoon then
                    task.wait(1)
                    continue
                end
                
                if currentCrate and (currentCrate.Parent == nil or currentCrate:GetAttribute("Owner") == player.Name) then
                    currentCrate = nil
                end
                
                if not currentCrate then
                    if not checkForCrates() then
                        if not waitingForCrate then
                            WindUI:Notify({
                                Title = "自动箱子",
                                Content = "等待新箱子出现...",
                                Duration = 3,
                            })
                            waitingForCrate = true
                        end
                        task.wait(2)
                        continue
                    else
                        waitingForCrate = false
                        local crates = workspace["Game Systems"]["Crate Workspace"]:GetChildren()
                        for _, crate in ipairs(crates) do
                            if crate:GetAttribute("Owner") ~= player.Name then
                                currentCrate = crate
                                break
                            end
                        end
                    end
                end
                
                if currentCrate then
                    local success, result = pcall(function()
                        local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
                        local tween = game:GetService("TweenService"):Create(
                            hrp, 
                            tweenInfo, 
                            {CFrame = currentCrate.CFrame + Vector3.new(3, 0, 0)}
                        )
                        tween:Play()
                        tween.Completed:Wait()
                    end)
                    
                    if not success then
                        currentCrate = nil
                        continue
                    end
                    
                    task.wait(0.3)
                    
                    local prompt = currentCrate:FindFirstChild("StealPrompt")
                    if prompt then
                        prompt.MaxActivationDistance = 10
                        fireproximityprompt(prompt, 1)
                        task.wait(0.2)
                        
                        local weldRemote = game:GetService("ReplicatedStorage"):FindFirstChild("TankCrates")
                        if weldRemote and weldRemote:FindFirstChild("WeldCrate") then
                            pcall(function() 
                                weldRemote.WeldCrate:InvokeServer(currentCrate) 
                            end)
                        end
                    end
                    
                    local cratePromptPart = tycoon.Essentials:FindFirstChild("Oil Collector") and 
                                           tycoon.Essentials["Oil Collector"]:FindFirstChild("CratePromptPart")
                    if cratePromptPart then
                        pcall(function()
                            local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
                            local tween = game:GetService("TweenService"):Create(
                                hrp, 
                                tweenInfo, 
                                {CFrame = cratePromptPart.CFrame + Vector3.new(0, 3, 0)}
                            )
                            tween:Play()
                            tween.Completed:Wait()
                        end)
                        
                        task.wait(0.5)
                        
                        local sellPrompt = cratePromptPart:FindFirstChild("SellPrompt")
                        if sellPrompt then
                            sellPrompt.MaxActivationDistance = 10
                            fireproximityprompt(sellPrompt, 1)
                            task.wait(0.5)
                            currentCrate = nil
                        end
                    end
                end
            end
        end)
    end
})

I:Toggle({
    Title = "自动建造（废在修）",
    Value = false,
    Callback = function(state)
        getgenv().AutoBuy = state
        
        task.spawn(function()
            while getgenv().AutoBuy do
                task.wait(0.5)
                
                if not getgenv().AutoBuy then break end
                
                local player = game.Players.LocalPlayer
                if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                    task.wait(1)
                    continue
                end
                
                local teamName = player.Team.Name
                local playerTycoon = workspace.Tycoon.Tycoons:FindFirstChild(teamName)
                
                if not playerTycoon or not playerTycoon:FindFirstChild("UnpurchasedButtons") then
                    task.wait(1)
                    continue
                end
                
                local closestNeon = nil
                local closestDistance = math.huge 
                
                for _, button in pairs(playerTycoon.UnpurchasedButtons:GetChildren()) do
                    if not button:FindFirstChild("Mission") then
                        local neon = button:FindFirstChild("Neon")
                        local price = button:FindFirstChild("Price")
                        
                        if neon and price and price.Value ~= 0 then
                            local distance = (neon.Position - player.Character.HumanoidRootPart.Position).Magnitude
                            if distance < closestDistance then
                                closestNeon = neon
                                closestDistance = distance
                            end
                        end
                    end
                end
                
                if closestNeon then
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(closestNeon.Position)
                else
                    task.wait(2)
                end
            end
        end)
    end
})

local ExcludedBases = {}

local function GetAvailableBases()
    local bases = {}
    if not workspace:FindFirstChild("Tycoon") or not workspace.Tycoon:FindFirstChild("Tycoons") then
        return bases
    end
    local tycoons = workspace.Tycoon.Tycoons:GetChildren()
    for _, tycoon in ipairs(tycoons) do
        if not table.find(ExcludedBases, tycoon.Name) then
            table.insert(bases, tycoon.Name)
        end
    end
    return bases
end

I:Toggle({
    Title = "自动重生",
    Value = false,
    Callback = function(state)
        getgenv().autoRebirth = state
        task.spawn(function()
            while getgenv().autoRebirth and task.wait() do
                pcall(function()
                    game:GetService("ReplicatedStorage").RebirthEVT:FireServer()
                end)
                task.wait(0.5)
            end
        end)
    end
})

I:Button({
    Title = "自动空投",
    Callback = function()
        if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and workspace:FindFirstChild("Game Systems") then
            for _,v in next,workspace["Game Systems"]:GetChildren() do
                if v.Name:find("Airdrop_") and v:FindFirstChild("MainPart") then
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.MainPart.CFrame
                    if v.MainPart:FindFirstChild("AirDropPrompt") then
                        fireproximityprompt(v.MainPart.AirDropPrompt)
                    end
                end
            end
        end
    end
})


I:Toggle({
    Title = "自动救人",
    Value = false,
    Callback = function(state)
        getgenv().autoRevive = state
        if state then
            local RunService = game:GetService("RunService")
            local CollectionService = game:GetService("CollectionService")

            local REVIVE_PROMPT_TAG = "RevivePromptTag"

            for _, prompt in ipairs(workspace:GetDescendants()) do
                if prompt.Name == "RevivePrompt" then
                    CollectionService:AddTag(prompt, REVIVE_PROMPT_TAG)
                end
            end

            workspace.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "RevivePrompt" then
                    CollectionService:AddTag(descendant, REVIVE_PROMPT_TAG)
                end
            end)

            local function triggerPrompt(prompt)
                if prompt.Parent then
                    fireproximityprompt(prompt)
                end
            end

            while getgenv().autoRevive do
                local tagged = CollectionService:GetTagged(REVIVE_PROMPT_TAG)
                for _, prompt in ipairs(tagged) do
                    coroutine.wrap(triggerPrompt)(prompt)
                end
                task.wait()
            end
        end
    end
})

I:Toggle({
    Title = "自动修电箱",
    Value = false,
    Callback = function(state)
        getgenv().autoFixGenerator = state
        if state then
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()

            while getgenv().autoFixGenerator do
                pcall(function()
                    for _, room in pairs(workspace.Rooms:GetChildren()) do
                        local interactables = room:FindFirstChild("Interactables")
                        
                        if interactables then
                            for _, generator in pairs(interactables:GetChildren()) do
                                if generator.Name == "Generator" and generator:FindFirstChild("Fixed") and generator:FindFirstChild("RemoteFunction") and generator:FindFirstChild("RemoteEvent") then
                                    local proximityPrompt = generator.ProxyPart:FindFirstChild("ProximityPrompt")
                                    
                                    generator.RemoteFunction:InvokeServer()

                                    local distance = (character.PrimaryPart.Position - generator.ProxyPart.Position).Magnitude

                                    if distance <= proximityPrompt.MaxActivationDistance and generator.Fixed.Value < 100 then
                                        local args = {
                                            [1] = true
                                        }
                                        generator.RemoteEvent:FireServer(unpack(args))
                                    end
                                elseif generator.Name == "EncounterGenerator" and generator:FindFirstChild("Fixed") and generator:FindFirstChild("RemoteFunction") and generator:FindFirstChild("RemoteEvent") then
                                    local proximityPrompt = generator.ProxyPart:FindFirstChild("ProximityPrompt")
                                    
                                    generator.RemoteFunction:InvokeServer()

                                    local distance = (character.PrimaryPart.Position - generator.ProxyPart.Position).Magnitude

                                    if distance <= proximityPrompt.MaxActivationDistance and generator.Fixed.Value < 100 then
                                        local args = {
                                            [1] = true
                                        }
                                        generator.RemoteEvent:FireServer(unpack(args))
                                    end
                                end
                            end
                        end
                    end
                end)
                task.wait(0)
            end
        end
    end
})

spawn(function()
    while task.wait(0.1) do
        if getgenv().auto then
            autofarmLoop()
        end
    end
end)

spawn(function()
    while true do
        wait(0.5)
        if getgenv().autoTeleport then
            teleportToClosestNeon()
        end
    end
end)

J:Toggle({
    Title = "自动闪光（直升机）",
    Value = false,
    Callback = function(state)
        local pl = {}
        pl.rs = game:GetService("ReplicatedStorage")
        pl.ws = game:GetService("Workspace")

        getgenv().toggle = state
        
        if getgenv().toggle then
            task.spawn(function()
                while getgenv().toggle do
                    pcall(function()
                        for _, nig in pairs(pl.ws:WaitForChild("Game Systems"):WaitForChild("Helicopter Workspace"):GetChildren()) do
                            if nig:IsA("Model") and nig:FindFirstChild("Misc") then
                                local fl = nig:FindFirstChild("Misc"):FindFirstChild("Turrets"):FindFirstChild("AH Weapons"):FindFirstChild("Flares")
                                local sp = nig:FindFirstChild("Misc"):FindFirstChild("Turrets"):FindFirstChild("SoundPart")
                                if fl and sp then
                                    local args = {fl, nig, sp}
                                    pl.rs:WaitForChild("RocketSystem"):WaitForChild("Events"):WaitForChild("FireFlare"):FireServer(unpack(args))
                                end
                            end
                        end
                    end)
                    task.wait(0.5)
                end
            end)
        end
    end
})

J:Divider({
    Text = "飞车"
})

J:Toggle({
    Title = "飞车UI",
    Value = false,
    Callback = function(state)
        if state then
            if getgenv().FlyGui and getgenv().FlyGui.Parent then
                getgenv().FlyGui:Destroy()
            end
            
            local Speed = 520
            local HumanoidRP = game.Players.LocalPlayer.Character.HumanoidRootPart

            getgenv().FlyGui = Instance.new("ScreenGui")
            local W = Instance.new("TextButton")
            local S = Instance.new("TextButton")
            local A = Instance.new("TextButton")
            local D = Instance.new("TextButton")
            local Fly = Instance.new("TextButton")
            local unfly = Instance.new("TextButton")
            local StopFly = Instance.new("TextButton")

            getgenv().FlyGui.Parent = game.CoreGui
            getgenv().FlyGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

            unfly.Name = "上"
            unfly.Parent = getgenv().FlyGui
            unfly.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            unfly.Position = UDim2.new(0.694387913, 0, 0.181818187, 0)
            unfly.Size = UDim2.new(0, 72, 0, 50)
            unfly.Font = Enum.Font.SourceSans
            unfly.Text = "停止飞行"
            unfly.TextColor3 = Color3.fromRGB(127, 34, 548)
            unfly.TextScaled = true
            unfly.TextSize = 14.000
            unfly.TextWrapped = true
            unfly.MouseButton1Down:Connect(function()
                if HumanoidRP:FindFirstChildOfClass("BodyVelocity") then
                    HumanoidRP:FindFirstChildOfClass("BodyVelocity"):Destroy()
                end
                if HumanoidRP:FindFirstChildOfClass("BodyGyro") then
                    HumanoidRP:FindFirstChildOfClass("BodyGyro"):Destroy()
                end
            end)

            StopFly.Name = "关闭飞行"
            StopFly.Parent = getgenv().FlyGui
            StopFly.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            StopFly.Position = UDim2.new(0.695689976, 0, 0.0213903747, 0)
            StopFly.Size = UDim2.new(0, 71, 0, 50)
            StopFly.Font = Enum.Font.SourceSans
            StopFly.Text = "关闭飞行"
            StopFly.TextColor3 = Color3.fromRGB(170, 0, 255)
            StopFly.TextScaled = true
            StopFly.TextSize = 14.000
            StopFly.TextWrapped = true
            StopFly.MouseButton1Down:Connect(function()
                HumanoidRP.Anchored = true
            end)

            Fly.Name = "开启飞车"
            Fly.Parent = getgenv().FlyGui
            Fly.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            Fly.Position = UDim2.new(0.588797748, 0, 0.0213903747, 0)
            Fly.Size = UDim2.new(0, 66, 0, 50)
            Fly.Font = Enum.Font.SourceSans
            Fly.Text = "飞行"
            Fly.TextColor3 = Color3.fromRGB(170, 0, 127)
            Fly.TextScaled = true
            Fly.TextSize = 14.000
            Fly.TextWrapped = true
            Fly.MouseButton1Down:Connect(function()
                local BV = Instance.new("BodyVelocity",HumanoidRP)
                local BG = Instance.new("BodyGyro",HumanoidRP)
                BG.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
                BG.D = 5000
                BG.P = 50000
                BG.CFrame = game.Workspace.CurrentCamera.CFrame
                BV.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
            end)

            W.Name = "W"
            W.Parent = getgenv().FlyGui
            W.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            W.Position = UDim2.new(0.161668837, 0, 0.601604283, 0)
            W.Size = UDim2.new(0, 58, 0, 50)
            W.Font = Enum.Font.SourceSans
            W.Text = "↑"
            W.TextColor3 = Color3.fromRGB(226, 226, 526)
            W.TextScaled = true
            W.TextSize = 5.000
            W.TextWrapped = true
            W.MouseButton1Down:Connect(function()
                HumanoidRP.Anchored = false
                if HumanoidRP:FindFirstChildOfClass("BodyVelocity") then
                    HumanoidRP:FindFirstChildOfClass("BodyVelocity"):Destroy()
                end
                if HumanoidRP:FindFirstChildOfClass("BodyGyro") then
                    HumanoidRP:FindFirstChildOfClass("BodyGyro"):Destroy()
                end
                task.wait(.1)
                local BV = Instance.new("BodyVelocity",HumanoidRP)
                local BG = Instance.new("BodyGyro",HumanoidRP)
                BG.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
                BG.D = 50000
                BG.P = 50000
                BG.CFrame = game.Workspace.CurrentCamera.CFrame
                BV.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
                BV.Velocity = game.Workspace.CurrentCamera.CFrame.LookVector * Speed
            end)

            S.Name = "S"
            S.Parent = getgenv().FlyGui
            S.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            S.Position = UDim2.new(0.161668837, 0, 0.735294104, 0)
            S.Size = UDim2.new(0, 58, 0, 50)
            S.Font = Enum.Font.SourceSans
            S.Text = "↓"
            S.TextColor3 = Color3.fromRGB(255, 255, 255)
            S.TextScaled = true
            S.TextSize = 14.000
            S.TextWrapped = true
            S.MouseButton1Down:Connect(function()
                HumanoidRP.Anchored = false
                if HumanoidRP:FindFirstChildOfClass("BodyVelocity") then
                    HumanoidRP:FindFirstChildOfClass("BodyVelocity"):Destroy()
                end
                if HumanoidRP:FindFirstChildOfClass("BodyGyro") then
                    HumanoidRP:FindFirstChildOfClass("BodyGyro"):Destroy()
                end
                task.wait(.1)
                local BV = Instance.new("BodyVelocity",HumanoidRP)
                local BG = Instance.new("BodyGyro",HumanoidRP)
                BG.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
                BG.D = 5000
                BG.P = 50000
                BG.CFrame = game.Workspace.CurrentCamera.CFrame
                BV.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
                BV.Velocity = game.Workspace.CurrentCamera.CFrame.LookVector * -Speed
            end)
        else
            if getgenv().FlyGui and getgenv().FlyGui.Parent then
                getgenv().FlyGui:Destroy()
                getgenv().FlyGui = nil
            end
        end
    end
})

spawn(function()
    while task.wait(0.1) do
        if getgenv().auto then
            autofarmLoop()
        end
    end
end)

spawn(function()
    while true do
        wait(0.5)
        if getgenv().autoTeleport then
            teleportToClosestNeon()
        end
    end
end)

spawn(function()
    wait(2)
    BasesDropdown:Refresh(GetAvailableBases())
end)

local TeleportTab = AddTab(OtherSection, "玩家传送", "map-pin")

getgenv().LockTPEnabled = false
getgenv().LoopTPEnabled = false
getgenv().LoopFrontTPEnabled = false
getgenv().LoopHeadHeightEnabled = false
getgenv().LoopHeadTPEnabled = false
getgenv().LoopBackTPEnabled = false
getgenv().LoopThrowEnabled = false
getgenv().FrontDistance = 5
getgenv().BackDistance = 5

local RunService = game:GetService("RunService")

local PlayerSection = TeleportTab:Section({Title = "玩家选择", Icon="lucide:list-chevrons-up-down", Opened = false})

local selectedPlayer = nil
local playerList = {}
local connections = {}

local function refreshPlayers()
    playerList = {}
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(playerList, player.Name)
        end
    end
end

refreshPlayers()

local PlayerDropdown = PlayerSection:Dropdown({
    Title = "选择玩家",
    Values = playerList,
    Value = "",
    Callback = function(selectedName)
        selectedPlayer = game.Players:FindFirstChild(selectedName)
    end
})

PlayerSection:Button({
    Title = "刷新玩家列表",
    Callback = function()
        refreshPlayers()
        PlayerDropdown:Refresh(playerList)
    end
})

PlayerSection:Button({
    Title = "查看玩家",
    Callback = function()
        if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Humanoid") then
            game.Workspace.CurrentCamera.CameraSubject = selectedPlayer.Character.Humanoid
        end
    end
})

PlayerSection:Button({
    Title = "停止查看",
    Callback = function()
        local localPlayer = game.Players.LocalPlayer
        if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
            game.Workspace.CurrentCamera.CameraSubject = localPlayer.Character.Humanoid
        end
    end
})

PlayerSection:Button({
    Title = "传送到玩家旁边",
    Callback = function()
        if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPos = selectedPlayer.Character.HumanoidRootPart.Position
            if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos + Vector3.new(3, 0, 3))
            end
        end
    end
})

local LockTPToggle = PlayerSection:Toggle({
    Title = "锁定传送",
    Default = false,
    Callback = function(state)
        getgenv().LockTPEnabled = state
        if connections["LockTP"] then
            connections["LockTP"]:Disconnect()
            connections["LockTP"] = nil
        end
        
        if state and selectedPlayer then
            connections["LockTP"] = RunService.Heartbeat:Connect(function()
                if not getgenv().LockTPEnabled or not selectedPlayer or not selectedPlayer.Character or not selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    if connections["LockTP"] then
                        connections["LockTP"]:Disconnect()
                        connections["LockTP"] = nil
                    end
                    return
                end
                local targetPos = selectedPlayer.Character.HumanoidRootPart.Position
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos + Vector3.new(3, 0, 3))
                end
            end)
        end
    end
})

PlayerSection:Button({
    Title = "把玩家传送过来",
    Callback = function()
        if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local myChar = game.Players.LocalPlayer.Character
            if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                local myPos = myChar.HumanoidRootPart.Position
                selectedPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(myPos + Vector3.new(3, 0, 3))
            end
        end
    end
})

local LoopTPToggle = PlayerSection:Toggle({
    Title = "循环把玩家传送过来",
    Default = false,
    Callback = function(state)
        getgenv().LoopTPEnabled = state
        if connections["LoopTP"] then
            connections["LoopTP"]:Disconnect()
            connections["LoopTP"] = nil
        end
        
        if state and selectedPlayer then
            connections["LoopTP"] = RunService.Heartbeat:Connect(function()
                if not getgenv().LoopTPEnabled or not selectedPlayer or not selectedPlayer.Character or not selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    if connections["LoopTP"] then
                        connections["LoopTP"]:Disconnect()
                        connections["LoopTP"] = nil
                    end
                    return
                end
                local myChar = game.Players.LocalPlayer.Character
                if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                    local myPos = myChar.HumanoidRootPart.Position
                    selectedPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(myPos + Vector3.new(3, 0, 3))
                end
            end)
        end
    end
})

local AttractSection = TeleportTab:Section({Title = "吸附功能", Icon="lucide:rose", Opened = false})

local AttractToggle = AttractSection:Toggle({
    Title = "吸附所有人",
    Default = false,
    Callback = function(state)
        getgenv().AttractAllEnabled = state
        if connections["AttractAll"] then
            connections["AttractAll"]:Disconnect()
            connections["AttractAll"] = nil
        end
        
        if state then
            connections["AttractAll"] = RunService.Heartbeat:Connect(function()
                if not getgenv().AttractAllEnabled then
                    if connections["AttractAll"] then
                        connections["AttractAll"]:Disconnect()
                        connections["AttractAll"] = nil
                    end
                    return
                end
                local myChar = game.Players.LocalPlayer.Character
                if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                    local myPos = myChar.HumanoidRootPart.Position
                    for _, player in pairs(game.Players:GetPlayers()) do
                        if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(myPos + Vector3.new(15, 0, 15))
                        end
                    end
                end
            end)
        end
    end
})

local PositionSection = TeleportTab:Section({Title = "位置传送", Icon="lucide:navigation", Opened = false})

local FrontSlider = PositionSection:Slider({
    Title = "前方距离",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = 5},
    Callback = function(value)
        getgenv().FrontDistance = value
        print("前方距离设置为:", value)
    end
})

local LoopFrontToggle = PositionSection:Toggle({
    Title = "循环传送至玩家前方",
    Default = false,
    Callback = function(state)
        getgenv().LoopFrontTPEnabled = state
        if connections["LoopFrontTP"] then
            connections["LoopFrontTP"]:Disconnect()
            connections["LoopFrontTP"] = nil
        end
        
        if state and selectedPlayer then
            connections["LoopFrontTP"] = RunService.Heartbeat:Connect(function()
                if not getgenv().LoopFrontTPEnabled or not selectedPlayer or not selectedPlayer.Character or not selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    if connections["LoopFrontTP"] then
                        connections["LoopFrontTP"]:Disconnect()
                        connections["LoopFrontTP"] = nil
                    end
                    return
                end
                local targetCF = selectedPlayer.Character.HumanoidRootPart.CFrame
                local frontPos = targetCF.Position + targetCF.LookVector * (getgenv().FrontDistance or 5)
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(frontPos)
                end
            end)
        end
    end
})

local HeadSlider = PositionSection:Slider({
    Title = "头顶距离",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = 4},
    Callback = function(value)
        getgenv().HeadDistance = value
        print("头顶距离设置为:", value)
    end
})

local LoopHeadToggle = PositionSection:Toggle({
    Title = "循环传送至玩家头顶",
    Default = false,
    Callback = function(state)
        getgenv().LoopHeadHeightEnabled = state
        if connections["LoopHeadHeight"] then
            connections["LoopHeadHeight"]:Disconnect()
            connections["LoopHeadHeight"] = nil
        end
        
        if state and selectedPlayer then
            connections["LoopHeadHeight"] = RunService.Heartbeat:Connect(function()
                if not getgenv().LoopHeadHeightEnabled or not selectedPlayer or not selectedPlayer.Character or not selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    if connections["LoopHeadHeight"] then
                        connections["LoopHeadHeight"]:Disconnect()
                        connections["LoopHeadHeight"] = nil
                    end
                    return
                end
                local targetPos = selectedPlayer.Character.HumanoidRootPart.Position
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos.X, targetPos.Y + (getgenv().HeadDistance or 5), targetPos.Z)
                end
            end)
        end
    end
})

local BackSlider = PositionSection:Slider({
    Title = "后方距离",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = 2},
    Callback = function(value)
        getgenv().BackDistance = value
        print("后方距离设置为:", value)
    end
})

local LoopBackToggle = PositionSection:Toggle({
    Title = "循环传送至玩家后面",
    Default = false,
    Callback = function(state)
        getgenv().LoopBackTPEnabled = state
        if connections["LoopBackTP"] then
            connections["LoopBackTP"]:Disconnect()
            connections["LoopBackTP"] = nil
        end
        
        if state and selectedPlayer then
            connections["LoopBackTP"] = RunService.Heartbeat:Connect(function()
                if not getgenv().LoopBackTPEnabled or not selectedPlayer or not selectedPlayer.Character or not selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    if connections["LoopBackTP"] then
                        connections["LoopBackTP"]:Disconnect()
                        connections["LoopBackTP"] = nil
                    end
                    return
                end
                local targetCF = selectedPlayer.Character.HumanoidRootPart.CFrame
                local backPos = targetCF.Position - targetCF.LookVector * (getgenv().BackDistance or 5)
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(backPos)
                end
            end)
        end
    end
})

local TeleportTab = OtherSection:Tab({Title = "画质功能", Icon = "boxes"})

TeleportTab:Button({
    Title = "去雾",
    Desc = "去除游戏中的雾气效果", 
    Callback = function()
        game.Lighting.FogStart = 3276634343
        game.Lighting.FogEnd = 3276734343
        WindUI:Notify({
            Title = "去雾成功",
            Content = "雾气效果已去除",
            Duration = 3
        })
    end
})

TeleportTab:Button({
    Title = "删除爆炸狙特效",
    Desc = "防止爆炸狙循环卡入", 
    Callback = function()
        local v1 = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
        if v1:FindFirstChild("ExplosionEffect") then
            getgenv().explosionConnection1 = v1.ExplosionEffect.OnClientEvent:Connect(function() end)
        end
        if v1:FindFirstChild("ExplosionEffectLocal") then
            getgenv().explosionConnection2 = v1.ExplosionEffectLocal.Event:Connect(function() end)
        end
        WindUI:Notify({
            Title = "删除成功",
            Content = "爆炸狙特效已经去除",
            Duration = 3
        })
    end
})

WindUI:Notify({
    Title = "YG SCRIPT",
    Content = "战争大亨",
    Duration = 3,
})
end
refreshAttackPlayerList()
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})

local MyButton = LeftGroupBox:AddButton({
    Text = 'FISH🐟',---服务器名称
    Func = function()
    local originalUI = Library
        
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/123fa98/Xi_Pro/refs/heads/main/UI.lua"))()


WindUI:AddTheme({
  Name = "Halloween",
  Accent = "#3c0b0b",
  Outline = "#ff0000",
  Text = "#FFFFFF",
  PlaceholderText = "#AAAAAA",
})

local Window = WindUI:CreateWindow({
  Title = "YG SCRIPT丨FISCH",
  Icon = "rbxassetid://93487642627310",
  Author = "YG PRO",
  Folder = "CloudHub",
  Size = UDim2.fromOffset(600, 350),
  Transparent = false,
  Theme = "Halloween",
  SideBarWidth = 200,
  HasOutline = true,
})
Window:EditOpenButton({
  Title = "开启",
  Color = ColorSequence.new(Color3.fromHex("2C2C2C"), Color3.fromHex("FFFFFF")),
  HoverColor = ColorSequence.new(Color3.fromHex("1A1A1A"), Color3.fromHex("D9D9D9")),
  PressedColor = ColorSequence.new(Color3.fromHex("000000"), Color3.fromHex("BFBFBF")),
  BorderColor = Color3.fromRGB(0, 0, 0),
  BorderTransparency = 0.5,
  BorderSize = 2,
  CornerRadius = UDim.new(0, 12),
  Font = Enum.Font.ArialBold,
  TextSize = 18,
  Size = UDim2.new(0.7, 0, 0.12, 0),
  Position = UDim2.new(0.15, 0, 0.85, 0),
  Icon = "rbxassetid://93487642627310",
  IconSize = 24,
  ShadowColor = Color3.fromRGB(0, 0, 0),
  ShadowTransparency = 0.5,
  ShadowOffset = Vector2.new(2, 2),
})
WindUI:Notify({
  Title = "加载完成",
  Content = "欢迎使用YG SCRIPT",
  Icon = "droplet",
  Duration = 3,
})
local dataTable = {}
ReplicatedStorage = game:GetService("ReplicatedStorage")
local buyPurchaseEvent = ReplicatedStorage:FindFirstChild("events") and ReplicatedStorage.events:FindFirstChild("purchase")
local buySelectedItem, buyItemQuantity = "None", 1
local buySelectedRod = "None"
local function getBuyResourceList(t)
  local r = ReplicatedStorage:FindFirstChild("resources")
  if not r then return {} end
  local f = r:FindFirstChild(t)
  if not f then return {} end
  local list = {}
  for _, c in ipairs(f:GetChildren()) do
    if c:IsA("Folder") then table.insert(list, c.Name) end
  end
  return list
end
local function buyFromMerlin(n)
  local w = workspace:FindFirstChild("world")
  if not w then return end
  local npcs = w:FindFirstChild("npcs")
  if not npcs then return end
  local m = npcs:FindFirstChild("Merlin")
  if not m then return end
  local mm = m:FindFirstChild("Merlin")
  if not mm then return end
  local r = mm:FindFirstChild(n)
  if r then r:InvokeServer() end
end
local buyItemList = getBuyResourceList("items")
if #buyItemList == 0 then table.insert(buyItemList, "None") end
buySelectedItem = buyItemList[1]
local buyRodList = getBuyResourceList("rods")
if #buyRodList == 0 then table.insert(buyRodList, "None") end
buySelectedRod = buyRodList[1]
HttpService = game:GetService("HttpService")
local settingsFolderName = "WindUI"
if makefolder then makefolder(settingsFolderName) end
local function saveSettings(fileName, data)
  if writefile then
    writefile(settingsFolderName .. "/" .. fileName .. ".json", HttpService:JSONEncode(data))
  end
end
local function loadSettings(fileName)
  if isfile and readfile then
    local filePath = settingsFolderName .. "/" .. fileName .. ".json"
    if isfile(filePath) then
      local fileContent = readfile(filePath)
      if fileContent then
        local success, decodedData = pcall(function()
          return HttpService:JSONDecode(fileContent)
        end)
        if success then return decodedData end
      end
    end
  end
  return nil
end
local function listSettingsFiles()
  local fileList = {}
  if listfiles then
    for _, filePath in ipairs(listfiles(settingsFolderName)) do
      local fileName = filePath:match("([^/]+)%.json$")
      if fileName then table.insert(fileList, fileName) end
    end
  end
  return fileList
end
local currentThemeName = WindUI:GetCurrentTheme()
local themes = WindUI:GetThemes()
local currentTheme = themes[currentThemeName]
local accentColor = (currentTheme and currentTheme.Accent and type(currentTheme.Accent) == "string" and currentTheme.Accent ~= "") and currentTheme.Accent or "#1e88e5"
local outlineColor = (currentTheme and currentTheme.Outline and type(currentTheme.Outline) == "string" and currentTheme.Outline ~= "") and currentTheme.Outline or "#ffffff"
local textColor = (currentTheme and currentTheme.Text and type(currentTheme.Text) == "string" and currentTheme.Text ~= "") and currentTheme.Text or "#ffffff"
local placeholderTextColor = (currentTheme and currentTheme.PlaceholderText and type(currentTheme.PlaceholderText) == "string" and currentTheme.PlaceholderText ~= "") and currentTheme.PlaceholderText or "#808080"
local function updateTheme()
  WindUI:AddTheme({
    Name = currentThemeName,
    Accent = accentColor,
    Outline = outlineColor,
    Text = textColor,
    PlaceholderText = placeholderTextColor,
  })
  WindUI:SetTheme(currentThemeName)
end
local themeList = {}
for tn, td in pairs(WindUI:GetThemes()) do
  table.insert(themeList, tn)
end
local feedbackParagraph1, feedbackParagraph2, themeNameInput, transparencyToggle, settingsFileName, fileDropdown
Players = game:GetService("Players")
Lighting = game:GetService("Lighting")
GuiService = game:GetService("GuiService")
VirtualInputManager = game:GetService("VirtualInputManager")
UserInputService = game:GetService("UserInputService")
MarketplaceService = game:GetService("MarketplaceService")
RbxAnalyticsService = game:GetService("RbxAnalyticsService")
RunService = game:GetService("RunService")
TweenService = game:GetService("TweenService")
ProximityPromptService = game:GetService("ProximityPromptService")
Workspace = game:GetService("Workspace")
local playerTeleportButtons = {}
local webhookUrl = [[https://discord.com/api/webhooks/1310067885267484763/dExL1AHg5i-XSgwKFJUmXN96J0fn3FpDz966w_RTISQJ0NMhnbBiX1-OLuRpSt3h6mNA]]
LocalPlayer = Players.LocalPlayer
local feedbackCurrentTime = os.time()
local feedbackJoinDateTable = os.date("*t", os.time() - LocalPlayer.AccountAge * 86400 + os.difftime(feedbackCurrentTime, os.time(os.date("!*t", feedbackCurrentTime))))
local feedbackJoinDateString = string.format("%02d/%02d/%d %02d:%02d:%02d", feedbackJoinDateTable.day, feedbackJoinDateTable.month, feedbackJoinDateTable.year, feedbackJoinDateTable.hour, feedbackJoinDateTable.min, feedbackJoinDateTable.sec)
local feedbackIsPremium = LocalPlayer.MembershipType == Enum.MembershipType.Premium
local feedbackDeviceType = nil
if UserInputService.KeyboardEnabled and UserInputService.MouseEnabled then
  feedbackDeviceType = "模拟器/PC"
elseif UserInputService.TouchEnabled then
  feedbackDeviceType = "IOS/Android"
else
  feedbackDeviceType = "IOS/Android/Unknown"
end
local feedbackExecutorName = "Unknown"
if identifyexecutor then feedbackExecutorName = identifyexecutor() or "Unknown" end
local feedbackHwid = "Unknown"
if gethwid then feedbackHwid = gethwid() or "Unknown" end
local feedbackAvatarResponse = nil
local feedbackAvatarImageUrl = ""
pcall(function()
  feedbackAvatarResponse = game:HttpGet(string.format([[https://thumbnails.roblox.com/v1/users/avatar?userIds=%d&size=180x180&format=Png&isCircular=true]], LocalPlayer.UserId))
  if feedbackAvatarResponse then
    local decodedResponse = HttpService:JSONDecode(feedbackAvatarResponse)
    if decodedResponse and decodedResponse.data and decodedResponse.data[1] then
      feedbackAvatarImageUrl = decodedResponse.data[1].imageUrl or ""
    end
  end
end)
local TextChatService = game:GetService("TextChatService")
local isAutoSendingEnabled = false
local chatMessage = "默认消息"
local sendCount = 1
local sendInterval = 1
local function sendChatMessage(message)
  if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
    local generalChannel = TextChatService:FindFirstChild("TextChannels")
    if generalChannel then
      local rbxGeneral = generalChannel:FindFirstChild("RBXGeneral")
      if rbxGeneral then rbxGeneral:SendAsync(message) end
    end
  else
    local defaultChatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
    if defaultChatEvents then
      local sayMessageRequest = defaultChatEvents:FindFirstChild("SayMessageRequest")
      if sayMessageRequest then sayMessageRequest:FireServer(message, "All") end
    end
  end
end

local InfoTab = Window:Tab({
  Title = "信息",
  Icon = "frown",
})

local MainTab = Window:Tab({
  Title = "主要功能",
  Icon = "house",
})

local SubTab = Window:Tab({
  Title = "副功能",
})

local SellTab = Window:Tab({
  Title = "出售功能",
})

local TeleportTab = Window:Tab({
  Title = "传送",
})

local TPTab = Window:Tab({
  Title = "TP",
})

local BuyTab = Window:Tab({
  Title = "购买",
})

local FeedbackTab = Window:Tab({
  Title = "反馈",
})

Window:Divider()

local ChatTab = Window:Tab({
  Title = "发言功能",
})

local GuideTab = Window:Tab({
  Title = "攻略",
})

Window:Divider()

local SettingsTab = Window:Tab({
  Title = "窗口和文件配置",
  Icon = "settings",
})

local ThemeTab = Window:Tab({
  Title = "自定义主题",
  Icon = "palette",
})

InfoTab:Section({
  Title = "qq群",
  TextSize = 22,
})



local accountAge = LocalPlayer.AccountAge
local currentTime = os.time()

InfoTab:Section({
  Title = "你的用户名: " .. LocalPlayer.Name,
  TextXAlignment = Enum.TextXAlignment.Center,
})

InfoTab:Section({
  Title = "账号天数: " .. accountAge .. " 天",
  TextXAlignment = Enum.TextXAlignment.Center,
})

InfoTab:Button({
  Title = "重新进入",
  Callback = function()
    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
  end,
})


MainTab:Section({
  Title = "自动区",
})

local isAppraisingEnabled = false

local function appraiseRoutine()
  local appraiserNPC = workspace:WaitForChild("world"):WaitForChild("npcs"):FindFirstChild("Appraiser")
  if appraiserNPC and appraiserNPC:FindFirstChild("appraiser") and appraiserNPC.appraiser:FindFirstChild("appraise") then
    appraiserNPC.appraiser.appraise:InvokeServer()
  end
end

MainTab:Toggle({
  Title = "远程鉴定(用鱼复制鱼)",
  Locked = true,
  Callback = function(enabled)
    isAppraisingEnabled = enabled
    if isAppraisingEnabled then
      table.insert(dataTable, game:GetService("RunService").Stepped:Connect(appraiseRoutine))
    else
      for _, connection in ipairs(dataTable) do
        connection:Disconnect()
      end
      dataTable = {}
    end
  end,
})
local isAutoAppraisingEnabled = false
local autoAppraiseConnection = nil

MainTab:Toggle({
  Title = "远程自动鉴定",
  Callback = function(enabled)
    isAutoAppraisingEnabled = enabled
    if isAutoAppraisingEnabled then
      autoAppraiseConnection = game:GetService("RunService").Heartbeat:Connect(function()
        pcall(function()
          workspace.world.npcs.Appraiser.appraiser.appraise:InvokeServer()
        end)
        task.wait(5)
      end)
    elseif autoAppraiseConnection then
      autoAppraiseConnection:Disconnect()
      autoAppraiseConnection = nil
    end
  end,
})

local isFastFishingEnabled = false
local fastFishingCoroutine = nil

MainTab:Toggle({
  Title = "快速钓鱼（防完美钓鱼）",
  Callback = function(enabled)
    isFastFishingEnabled = enabled
    if isFastFishingEnabled then
      fastFishingCoroutine = coroutine.create(function()
        while isFastFishingEnabled do
          local reelParams = {
            [1] = 1000,
            [2] = false,
          }
          game:GetService("ReplicatedStorage").events.reelfinished:FireServer(unpack(reelParams))
          task.wait(0.1)
        end
      end)
      coroutine.resume(fastFishingCoroutine)
    elseif fastFishingCoroutine then
      coroutine.close(fastFishingCoroutine)
      fastFishingCoroutine = nil
    end
  end,
})
local isPerfectFishingEnabled = false
local perfectFishingTask = nil

MainTab:Toggle({
  Title = "快速钓鱼（完美钓鱼）",
  Callback = function(enabled)
    isPerfectFishingEnabled = enabled
    if isPerfectFishingEnabled then
      print("快速钓鱼已启用")
      perfectFishingTask = task.spawn(function()
        while isPerfectFishingEnabled do
          local reelParams = {
            [1] = 1000000000000000000000000,
            [2] = true,
          }
          game:GetService("ReplicatedStorage").events.reelfinished:FireServer(unpack(reelParams))
          task.wait(0.1)
        end
      end)
    else
      print("快速钓鱼已禁用")
      if perfectFishingTask then
        task.cancel(perfectFishingTask)
        perfectFishingTask = nil
      end
    end
  end,
})

local isTrackingWhiteBlockEnabled = false

local function trackWhiteBlock()
  local reelGui = LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("reel")
  if reelGui and reelGui:FindFirstChild("bar") then
    local playerBar = reelGui.bar:FindFirstChild("playerbar")
    local fishBar = reelGui.bar:FindFirstChild("fish")
    if playerBar and fishBar then
      playerBar.Position = fishBar.Position
    end
  end
end

MainTab:Toggle({
  Title = "追踪白块",
  Callback = function(enabled)
    isTrackingWhiteBlockEnabled = enabled
    if isTrackingWhiteBlockEnabled then
      table.insert(dataTable, game:GetService("RunService").RenderStepped:Connect(trackWhiteBlock))
    else
      for _, connection in ipairs(dataTable) do
        connection:Disconnect()
      end
      dataTable = {}
    end
  end,
})

local function getRodTool()
  local character = LocalPlayer.Character
  if not character then
    return nil
  end
  for _, child in ipairs(character:GetChildren()) do
    if child:IsA("Tool") and (child.Name:find("rod") or child.Name:find("Rod")) then
      return child
    end
  end
  return nil
end

local isAutoShakeEnabled = false
local autoShakeConnections = {}

local function clickButton(button)
  GuiService.SelectedObject = button
  VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
  VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

local function setupAutoShake()
  local playerGui = LocalPlayer:WaitForChild("PlayerGui")
  table.insert(autoShakeConnections, playerGui.DescendantAdded:Connect(function(descendant)
    if isAutoShakeEnabled and descendant.Name == "button" and descendant.Parent and descendant.Parent.Name == "safezone" and descendant.Parent.Parent and descendant.Parent.Parent.Name == "shakeui" then
      table.insert(autoShakeConnections, task.spawn(function()
        while isAutoShakeEnabled do
          local buttonParent = descendant.Parent
          if buttonParent then
            clickButton(descendant)
            task.wait()
          else
            break
          end
        end
      end))
    end
  end))
end

local function cleanupAutoShake()
  for _, connection in ipairs(autoShakeConnections) do
    if typeof(connection) == "RBXScriptConnection" then
      connection:Disconnect()
    elseif typeof(connection) == "thread" then
      task.cancel(connection)
    end
  end
  autoShakeConnections = {}
end

MainTab:Toggle({
  Title = "快速摇晃",
  Callback = function(enabled)
    isAutoShakeEnabled = enabled
    if isAutoShakeEnabled then
      setupAutoShake()
    else
      cleanupAutoShake()
    end
  end,
})
local isAutoCastEnabled = false

MainTab:Toggle({
  Title = "自动抛竿",
  Callback = function(enabled)
    isAutoCastEnabled = enabled
    print("自动抛竿开启状态: ", enabled)
    if isAutoCastEnabled then
      task.spawn(function()
        while isAutoCastEnabled do
          local function findRod()
            local character = LocalPlayer.Character
            if not character then
              return nil
            end
            for _, child in ipairs(character:GetChildren()) do
              if child:IsA("Tool") and (child.Name:find("rod") or child.Name:find("Rod")) then
                return child
              end
            end
            return nil
          end
          
          (function()
            local rod = findRod()
            if not rod then
              warn("没有找到钓鱼竿！")
              return
            end
            local castParams = {
              [1] = 100,
              [2] = 1,
            }
            if rod:FindFirstChild("events") and rod.events:FindFirstChild("cast") then
              rod.events.cast:FireServer(unpack(castParams))
              print("成功抛竿！")
            else
              warn("钓鱼竿没有正确的抛竿事件！")
            end
          end)()
          task.wait(0.1)
        end
      end)
    else
      print("自动抛竿已禁用")
    end
  end,
})
local isAFKFishingEnabled = false

MainTab:Toggle({
  Title = "挂机钓鱼",
  Callback = function(enabled)
    isAFKFishingEnabled = enabled
    print("挂机钓鱼状态:", enabled)
    local config = {
      fpsCap = 9999,
      disableChat = true,
      enableBigButton = true,
      bigButtonScaleFactor = 2,
      shakeSpeed = 0.5,
      FreezeWhileFishing = true,
    }
    setfpscap(config.fpsCap)
    local PlayerGui = LocalPlayer.PlayerGui
    local utils = {
      blacklisted_attachments = {
        "bob",
        "bodyweld"
      },
      simulate_click = function(x, y, button)
        VirtualInputManager:SendMouseButtonEvent(x, y, button - 1, true, game, 1)
        VirtualInputManager:SendMouseButtonEvent(x, y, button - 1, false, game, 1)
      end,
      move_fix = function(instance)
        for _, descendant in instance:GetDescendants() do
          if descendant.ClassName == "Attachment" and table.find(utils.blacklisted_attachments, descendant.Name) then
            descendant:Destroy()
          end
        end
      end,
    }
    local fishingSystem = {
      reel_tick = nil,
      cast_tick = nil,
      find_rod = function()
        local character = LocalPlayer.Character
        if not character then
          return nil
        end
        for _, child in ipairs(character:GetChildren()) do
          if child:IsA("Tool") and (child.Name:find("rod") or child.Name:find("Rod")) then
            return child
          end
        end
        return nil
      end,
      freeze_character = function(freeze)
        local character = LocalPlayer.Character
        if character then
          local humanoid = character:FindFirstChildOfClass("Humanoid")
          if humanoid then
            if freeze then
              humanoid.WalkSpeed = 0
              humanoid.JumpPower = 0
              character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame)
            else
              humanoid.WalkSpeed = 16
              humanoid.JumpPower = 50
            end
          end
        end
      end,
      cast = function()
        local rod = fishingSystem.find_rod()
        if not rod then
          return
        end
        local castParams = {
          [1] = 100,
          [2] = 1,
        }
        if rod:FindFirstChild("events") and rod.events:FindFirstChild("cast") then
          rod.events.cast:FireServer(unpack(castParams))
          print("成功抛竿！")
        else
          warn("钓鱼竿事件不存在！")
        end
        fishingSystem.cast_tick = 0
      end,
      shake = function()
        local shakeUI = PlayerGui:FindFirstChild("shakeui")
        if shakeUI then
          local safeZone = shakeUI:FindFirstChild("safezone")
          local button = safeZone and safeZone:FindFirstChild("button")
          if button and button.Visible then
            if config.enableBigButton then
              button.Size = UDim2.new(config.bigButtonScaleFactor, 0, config.bigButtonScaleFactor, 0)
            else
              button.Size = UDim2.new(1, 0, 1, 0)
            end
            utils.simulate_click(button.AbsolutePosition.X + button.AbsoluteSize.X / 2, button.AbsolutePosition.Y + button.AbsoluteSize.Y / 2, 1)
          end
        end
      end,
      reel = function()
        local reelParams = {
          [1] = 1000,
          [2] = false,
        }
        if ReplicatedStorage:FindFirstChild("events") and ReplicatedStorage.events:FindFirstChild("reelfinished") then
          ReplicatedStorage.events.reelfinished:FireServer(unpack(reelParams))
          print("成功完成收竿！")
        else
          warn("未找到收竿事件！")
        end
      end,
    }
    task.spawn(function()
      while isAFKFishingEnabled do
        task.wait(config.shakeSpeed)
        local rod = fishingSystem.find_rod()
        if rod then
          if config.FreezeWhileFishing then
            fishingSystem.freeze_character(true)
          end
          fishingSystem.cast()
          fishingSystem.shake()
          fishingSystem.reel()
        else
          fishingSystem.freeze_character(false)
        end
      end
      if not isAFKFishingEnabled then
        fishingSystem.freeze_character(false)
      end
    end)
  end,
})
local isAFKFishingV2Enabled = false
local afkFishingV2Connections = {}

local function clickButton(button)
  GuiService.SelectedObject = button
  VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
  VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

local function setupAFKFishingV2()
  local playerGui = LocalPlayer:WaitForChild("PlayerGui")
  table.insert(afkFishingV2Connections, playerGui.DescendantAdded:Connect(function(descendant)
    if isAFKFishingV2Enabled and descendant.Name == "button" and descendant.Parent and descendant.Parent.Name == "safezone" and descendant.Parent.Parent and descendant.Parent.Parent.Name == "shakeui" then
      table.insert(afkFishingV2Connections, task.spawn(function()
        while isAFKFishingV2Enabled do
          local buttonParent = descendant.Parent
          if buttonParent then
            clickButton(descendant)
            task.wait()
          else
            break
          end
        end
      end))
    end
  end))
  for _, existingDescendant in ipairs(playerGui:GetDescendants()) do
    if isAFKFishingV2Enabled and existingDescendant.Name == "button" and existingDescendant.Parent and existingDescendant.Parent.Name == "safezone" and existingDescendant.Parent.Parent and existingDescendant.Parent.Parent.Name == "shakeui" then
      table.insert(afkFishingV2Connections, task.spawn(function()
        while isAFKFishingV2Enabled do
          local buttonParent = existingDescendant.Parent
          if buttonParent then
            clickButton(existingDescendant)
            task.wait()
          else
            break
          end
        end
      end))
    end
  end
end

local function cleanupAFKFishingV2(connections)
  for _, connection in ipairs(connections) do
    if typeof(connection) == "RBXScriptConnection" then
      connection:Disconnect()
    elseif typeof(connection) == "thread" then
      task.cancel(connection)
    end
  end
  afkFishingV2Connections = {}
end
MainTab:Toggle({
  Title = "挂机钓鱼v2",
  Callback = function(enabled)
    isAFKFishingV2Enabled = enabled
    if not enabled then
      cleanupAFKFishingV2(afkFishingV2Connections)
      return
    end
    local config = {
      fpsCap = 144,
      FreezeWhileFishing = true,
      FishingInterval = 1,
    }
    setfpscap(config.fpsCap)
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    local utils = {
      simulate_click = function(x, y, button)
        VirtualInputManager:SendMouseButtonEvent(x, y, button - 1, true, game, 1)
        VirtualInputManager:SendMouseButtonEvent(x, y, button - 1, false, game, 1)
      end,
    }
    local fishingSystem = {
      find_rod = function()
        local character = LocalPlayer.Character
        if not character then
          return nil
        end
        for _, child in ipairs(character:GetChildren()) do
          if child:IsA("Tool") and (child.Name:find("rod") or child.Name:find("Rod")) then
            return child
          end
        end
        return nil
      end,
      freeze_character = function(freeze)
        local character = LocalPlayer.Character
        if character then
          local humanoid = character:FindFirstChildOfClass("Humanoid")
          if humanoid then
            if freeze then
              humanoid.WalkSpeed = 0
              humanoid.JumpPower = 0
            else
              humanoid.WalkSpeed = 16
              humanoid.JumpPower = 50
            end
          end
        end
      end,
      cast = function()
        local rod = fishingSystem.find_rod()
        if not rod then
          return
        end
        rod.events.cast:FireServer(unpack({
          [1] = 100,
          [2] = 1,
        }))
      end,
      reel = function()
        ReplicatedStorage.events.reelfinished:FireServer(unpack({
          [1] = 1000,
          [2] = false,
        }))
      end,
    }
    setupAFKFishingV2()
    while isAFKFishingV2Enabled do
      local rod = fishingSystem.find_rod()
      if rod then
        if config.FreezeWhileFishing then
          fishingSystem.freeze_character(true)
        end
        fishingSystem.cast()
        fishingSystem.reel()
      else
        fishingSystem.freeze_character(false)
      end
      task.wait(config.FishingInterval)
    end
    fishingSystem.freeze_character(false)
    cleanupAFKFishingV2(afkFishingV2Connections)
  end,
})
local currentFishingMode = nil
local fishingModeConnection = nil
local fishingMode = "普通钓鱼"
local isFishingModeEnabled = false
local fishingModeConnections = {}

local fishingModes = {
  ["普通钓鱼"] = function()
    game:GetService("ReplicatedStorage").events.reelfinished:FireServer(unpack({
      [1] = 1000,
      [2] = false,
    }))
  end,
  ["完美钓鱼"] = function()
    game:GetService("ReplicatedStorage").events.reelfinished:FireServer(unpack({
      [1] = 1000000000000000000000000,
      [2] = true,
    }))
  end,
}
local function clickButton(button)
  GuiService.SelectedObject = button
  VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
  VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end
local function setupFishingV3()
  local playerGui = LocalPlayer:WaitForChild("PlayerGui")
  table.insert(fishingModeConnections, playerGui.DescendantAdded:Connect(function(descendant)
    if descendant.Name == "button" and descendant.Parent and descendant.Parent.Name == "safezone" and descendant.Parent.Parent and descendant.Parent.Parent.Name == "shakeui" then
      table.insert(fishingModeConnections, task.spawn(function()
        while isFishingModeEnabled do
          local buttonParent = descendant.Parent
          if buttonParent then
            clickButton(descendant)
            task.wait()
          else
            break
          end
        end
      end))
    end
  end))
  for _, existingDescendant in ipairs(playerGui:GetDescendants()) do
    if existingDescendant.Name == "button" and existingDescendant.Parent and existingDescendant.Parent.Name == "safezone" and existingDescendant.Parent.Parent and existingDescendant.Parent.Parent.Name == "shakeui" then
      table.insert(fishingModeConnections, task.spawn(function()
        while isFishingModeEnabled do
          local buttonParent = existingDescendant.Parent
          if buttonParent then
            clickButton(existingDescendant)
            task.wait()
          else
            break
          end
        end
      end))
    end
  end
end

local function cleanupFishingV3()
  for _, connection in ipairs(fishingModeConnections) do
    if typeof(connection) == "RBXScriptConnection" then
      connection:Disconnect()
    elseif typeof(connection) == "thread" then
      task.cancel(connection)
    end
  end
  fishingModeConnections = {}
end

MainTab:Dropdown({
  Title = "选择钓鱼v3模式",
  Values = {
    "普通钓鱼",
    "完美钓鱼"
  },
  Callback = function(selected)
    fishingMode = selected
  end,
})

MainTab:Toggle({
  Title = "挂机钓鱼v3",
  Callback = function(enabled)
    isFishingModeEnabled = enabled
    if not enabled then
      if currentFishingMode then
        currentFishingMode:Disconnect()
        currentFishingMode = nil
      end
      cleanupFishingV3()
      fishingModeConnection = nil
      return
    end
    local config = {
      fpsCap = 999999,
      FreezeWhileFishing = true,
      FishingInterval = 0,
    }
    setfpscap(config.fpsCap)
    local function findRod()
      local character = LocalPlayer.Character
      if not character then
        return nil
      end
      for _, tool in ipairs(character:GetChildren()) do
        if tool:FindFirstChild("events") and tool.events:FindFirstChild("cast") then
          return tool
        end
      end
      return nil
    end
    local function castAndReel()
      local rod = findRod()
      if rod then
        rod.events.cast:FireServer(unpack({
          [1] = 1000000000000000000000000,
        }))
        if fishingModes[fishingMode] then
          fishingModes[fishingMode]()
        else
          print("无效钓鱼模式！")
        end
      else
        print("未找到钓鱼竿")
      end
    end
    local function freezeCharacter()
      local character = LocalPlayer.Character
      if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart and not currentFishingMode then
          fishingModeConnection = humanoidRootPart.CFrame
          currentFishingMode = RunService.RenderStepped:Connect(function()
            if humanoidRootPart and fishingModeConnection then
              humanoidRootPart.CFrame = fishingModeConnection
            end
          end)
        elseif humanoidRootPart and currentFishingMode then
          fishingModeConnection = humanoidRootPart.CFrame
        end
      end
    end
    local function unfreezeCharacter()
      if currentFishingMode then
        currentFishingMode:Disconnect()
        currentFishingMode = nil
      end
      fishingModeConnection = nil
    end
    setupFishingV3()
    task.spawn(function()
      while isFishingModeEnabled do
        local rod = findRod()
        if rod then
          if config.FreezeWhileFishing then
            freezeCharacter()
          end
          castAndReel()
        else
          unfreezeCharacter()
        end
        task.wait(config.FishingInterval)
      end
      unfreezeCharacter()
    end)
  end,
})
local freezeConnection = nil
local freezeCFrame = nil
MainTab:Toggle({
  Title = "冻结玩家位置",
  Callback = function(enabled)
    local humanoidRootPart = (LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
    if freezeConnection then
      freezeConnection:Disconnect()
      freezeConnection = nil
    end
    if enabled then
      freezeCFrame = humanoidRootPart.CFrame
      freezeConnection = game:GetService("RunService").RenderStepped:Connect(function()
        if humanoidRootPart and freezeCFrame then
          humanoidRootPart.CFrame = freezeCFrame
        end
      end)
    else
      freezeCFrame = nil
    end
  end,
})
MainTab:Button({
  Title = "47钓鱼",
  Callback = function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/474375w/nocdyv/refs/heads/main/fish"))()
  end,
})
local purchaseDialog = Window:Dialog({
  Title = "警告！",
  Content = "使用后退出来将会回档，是否确认使用？",
  Buttons = {
    {
      Title = "确认",
      Callback = function()
        local function purchaseAllRods()
          local rodsFolder = game:GetService("ReplicatedStorage").resources.items.rods
          if not rodsFolder then
            warn("Folder Rods not found")
            return 
          end
          local purchaseEvent = game:GetService("ReplicatedStorage").events.purchase
          local price = math.huge
          for _, rodFolder in ipairs(rodsFolder:GetChildren()) do
            if rodFolder:IsA("Folder") then
              purchaseEvent:FireServer(rodFolder.Name, "Rod", nil, price)
            end
          end
        end
        purchaseAllRods()
        task.spawn(function()
          task.wait(1)
          purchaseAllRods()
        end)
      end,
    },
    {
      Title = "取消",
      Callback = function()
        print("cancel")
      end,
    }
  },
})
local purchaseButton = MainTab:Button({
  Title = "无限金钱和一键获取杆子",
  Desc = "建议用小号",
  Locked = true,
  Callback = function()
    purchaseDialog:Open()
  end,
})
MainTab:Section({
  Title = "随机钓鱼设置功能",
})
local normalFishingProbability = 50
local perfectFishingProbability = 50
local isRandomFishingEnabled = false
MainTab:Toggle({
  Title = "随机钓鱼",
  Callback = function(enabled)
    isRandomFishingEnabled = enabled
    if isRandomFishingEnabled then
      task.spawn(function()
        while isRandomFishingEnabled do
          local randomValue = math.random(1, 100)
          if randomValue <= perfectFishingProbability then
            game:GetService("ReplicatedStorage").events.reelfinished:FireServer(unpack({
              [1] = 1000000000000000000000000,
              [2] = true,
            }))
            print("执行完美钓鱼")
          else
            game:GetService("ReplicatedStorage").events.reelfinished:FireServer(unpack({
              [1] = 1000,
              [2] = false,
            }))
            print("执行普通钓鱼")
          end
          task.wait(0.1)
        end
      end)
    end
  end,
})
MainTab:Input({
  Title = "自定义普通钓鱼概率",
  Desc = "请输入普通钓鱼的概率 (0-100)",
  Callback = function(input)
    local probability = tonumber(input)
    if probability and probability >= 0 and probability <= 100 then
      normalFishingProbability = probability
      perfectFishingProbability = 100 - probability
      WindUI:Notify({
        Title = "设置成功",
        Content = "普通钓鱼概率设置为 " .. normalFishingProbability .. "%，完美钓鱼概率设置为 " .. perfectFishingProbability .. "%",
        Icon = "gear",
        Duration = 5,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "输入的概率值无效，请输入 0 到 100 之间的数字",
        Icon = "alert",
        Duration = 5,
      })
    end
  end,
})
MainTab:Input({
  Title = "自定义完美钓鱼概率",
  Desc = "请输入完美钓鱼的概率 (0-100)",
  Callback = function(input)
    local probability = tonumber(input)
    if probability and probability >= 0 and probability <= 100 then
      perfectFishingProbability = probability
      normalFishingProbability = 100 - probability
      WindUI:Notify({
        Title = "设置成功",
        Content = "完美钓鱼概率设置为 " .. perfectFishingProbability .. "%，普通钓鱼概率设置为 " .. normalFishingProbability .. "%",
        Icon = "gear",
        Duration = 5,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "输入的概率值无效，请输入 0 到 100 之间的数字",
        Icon = "alert",
        Duration = 5,
      })
    end
  end,
})
MainTab:Section({
  Title = "玩家",
})
local fovSlider = MainTab:Slider({
  Title = "fov",
  Step = 1,
  Value = {
    Min = 20,
    Max = 120,
    Default = 70,
  },
  Callback = function(value)
    game.Workspace.Camera.FieldOfView = value
  end,
})
local speedSlider = MainTab:Slider({
  Title = "速度",
  Desc = "",
  Step = 1,
  Value = {
    Min = 16,
    Max = 500,
    Default = 16,
  },
  Callback = function(value)
    local character = LocalPlayer.Character
    if character then
      local humanoid = character:FindFirstChildOfClass("Humanoid")
      if humanoid then
        humanoid.WalkSpeed = value
      end
    end
  end,
})
local isInfiniteJumpEnabled = false
game:GetService("UserInputService").JumpRequest:Connect(function()
  if isInfiniteJumpEnabled then
    local character = LocalPlayer.Character
    if character then
      local humanoid = character:FindFirstChildOfClass("Humanoid")
      if humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
      end
    end
  end
end)
MainTab:Toggle({
  Title = "无限跳跃",
  Callback = function(enabled)
    isInfiniteJumpEnabled = enabled
  end,
})
MainTab:Section({
  Title = "坐标传送",
})
local teleportX = 0
local teleportY = 0
local teleportZ = 0
local xInput = MainTab:Input({
  Title = "X坐标",
  Desc = "请输入X坐标",
  Callback = function(input)
    teleportX = tonumber(input) or 0
    warn("X坐标: " .. teleportX)
  end,
})
local yInput = MainTab:Input({
  Title = "Y坐标",
  Desc = "请输入Y坐标",
  Callback = function(input)
    teleportY = tonumber(input) or 0
    warn("Y坐标: " .. teleportY)
  end,
})
local zInput = MainTab:Input({
  Title = "Z坐标",
  Desc = "请输入Z坐标",
  Callback = function(input)
    teleportZ = tonumber(input) or 0
    warn("Z坐标: " .. teleportZ)
  end,
})
MainTab:Button({
  Title = "传送",
  Callback = function()
    if teleportX and teleportY and teleportZ then
      local character = LocalPlayer.Character
      if character and character.PrimaryPart then
        character:SetPrimaryPartCFrame(CFrame.new(teleportX, teleportY, teleportZ))
        warn("玩家已传送到坐标: (" .. teleportX .. ", " .. teleportY .. ", " .. teleportZ .. ")")
      end
    end
  end,
})
local antiAFKConnection = nil
local idleConnection = nil
SubTab:Toggle({
  Title = "AFK",
  Callback = function(enabled)
    if enabled then
      local VirtualUser = game:GetService("VirtualUser")
      local RunService = game:GetService("RunService")
      local lastClickTime = tick()
      
      idleConnection = LocalPlayer.Idled:Connect(function()
        pcall(function()
          VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
          task.wait(1)
          VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
        end)
      end)
      
      antiAFKConnection = RunService.PreRender:Connect(function()
        if tick() - lastClickTime >= 900 then
          pcall(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
          end)
          lastClickTime = tick()
        end
      end)
    else
      if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
      end
      if idleConnection then
        idleConnection:Disconnect()
        idleConnection = nil
      end
    end
  end,
})
local autoInteractDescendantConnection = nil
local autoInteractPromptConnection = nil
SubTab:Toggle({
  Title = "自动互动",
  Callback = function(enabled)
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    
    local function clickButton(button)
      if button then
        GuiService.SelectedObject = button
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
      end
    end
    
    local function pressE()
      VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
      VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
    end
    
    local function setupDescendantListener()
      autoInteractDescendantConnection = PlayerGui.DescendantAdded:Connect(function(descendant)
        if enabled and descendant.Name == "ButtonImage" then
          task.spawn(function()
            while enabled do
              if descendant and descendant.Parent then
                clickButton(descendant)
                pressE()
                task.wait(0.2)
              else
                break
              end
            end
          end)
        end
      end)
    end
    
    if enabled then
      autoInteractPromptConnection = ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
        if enabled then
          prompt.HoldDuration = 0
        end
      end)
      setupDescendantListener()
    else
      if autoInteractPromptConnection then
        autoInteractPromptConnection:Disconnect()
        autoInteractPromptConnection = nil
      end
      if autoInteractDescendantConnection then
        autoInteractDescendantConnection:Disconnect()
        autoInteractDescendantConnection = nil
      end
    end
    
    Players.PlayerRemoving:Connect(function(player)
      if player == LocalPlayer then
        if autoInteractPromptConnection then
          autoInteractPromptConnection:Disconnect()
        end
        if autoInteractDescendantConnection then
          autoInteractDescendantConnection:Disconnect()
        end
      end
    end)
  end,
})
local isRemoveFogEnabled = false
SubTab:Toggle({
  Title = "删除雾",
  Value = isRemoveFogEnabled,
  Callback = function(enabled)
    isRemoveFogEnabled = enabled
    local sky = Lighting:FindFirstChild("Sky")
    local bloom = Lighting:FindFirstChild("bloom")
    if isRemoveFogEnabled and sky and bloom then
      sky.Parent = bloom
    elseif bloom and bloom:FindFirstChild("Sky") then
      bloom.Sky.Parent = Lighting
    end
  end,
})
local isKeepDaytimeEnabled = false
local keepDaytimeConnection = nil
SubTab:Toggle({
  Title = "保持白天",
  Value = isKeepDaytimeEnabled,
  Callback = function(enabled)
    isKeepDaytimeEnabled = enabled
    if keepDaytimeConnection then
      keepDaytimeConnection:Disconnect()
      keepDaytimeConnection = nil
    end
    if isKeepDaytimeEnabled then
      Lighting.ClockTime = 12
      keepDaytimeConnection = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
        if isKeepDaytimeEnabled then
          Lighting.ClockTime = 12
        end
      end)
    end
  end,
})
local isAutoSkinCrateEnabled = false
SubTab:Toggle({
  Title = "自动开皮肤开箱",
  Value = isAutoSkinCrateEnabled,
  Callback = function(enabled)
    isAutoSkinCrateEnabled = enabled
    if isAutoSkinCrateEnabled then
      task.spawn(function()
        while isAutoSkinCrateEnabled do
          task.wait(0.1)
          pcall(function()
            local requestSpin = game:GetService("ReplicatedStorage").packages.Net:FindFirstChild("RF/SkinCrates/RequestSpin")
            if requestSpin then
              requestSpin:InvokeServer({
                skipAnimation = true,
              })
            end
          end)
        end
      end)
    end
  end,
})
local isDisableOxygenEnabled = false
local disableOxygenConnection = nil
local function updateOxygenForAllPlayers()
  for _, player in pairs(Players:GetPlayers()) do
    local character = workspace:FindFirstChild(player.Name)
    if character and character:FindFirstChild("oxygen") then
      character.oxygen.Disabled = isDisableOxygenEnabled
    end
  end
end
SubTab:Toggle({
  Title = "禁用氧气",
  Value = isDisableOxygenEnabled,
  Callback = function(enabled)
    isDisableOxygenEnabled = enabled
    if disableOxygenConnection then
      disableOxygenConnection:Disconnect()
      disableOxygenConnection = nil
    end
    updateOxygenForAllPlayers()
    if isDisableOxygenEnabled then
      disableOxygenConnection = Players.PlayerAdded:Connect(function()
        task.wait(0.5)
        updateOxygenForAllPlayers()
      end)
    end
  end,
})
local isDisablePeakOxygenEnabled = false
SubTab:Toggle({
  Title = "禁用雪山氧气",
  Value = isDisablePeakOxygenEnabled,
  Callback = function(enabled)
    isDisablePeakOxygenEnabled = enabled
    for _, child in ipairs(workspace:GetChildren()) do
      if child:FindFirstChild("client") and child.client:FindFirstChild("oxygen(peaks)") then
        local oxygenPeaks = child.client["oxygen(peaks)"]
        if oxygenPeaks then
          oxygenPeaks.Disabled = isDisablePeakOxygenEnabled
          print("氧气状态已更新:", isDisablePeakOxygenEnabled)
          break
        end
      end
    end
  end,
})
local isShakeEnlargeEnabled = false
SubTab:Toggle({
  Title = "摇晃放大",
  Callback = function(enabled)
    isShakeEnlargeEnabled = enabled
    if isShakeEnlargeEnabled then
      task.spawn(function()
        while isShakeEnlargeEnabled do
          task.wait(0.5)
          local shakeUI = LocalPlayer.PlayerGui:FindFirstChild("shakeui")
          if shakeUI then
            local safezone = shakeUI:FindFirstChild("safezone")
            if safezone then
              local button = safezone:FindFirstChild("button")
              if button then
                button.Size = UDim2.new(2, 0, 2, 0)
              end
            end
          end
        end
      end)
    end
  end,
})
local nukeButton = SubTab:Button({
  Title = "一秒放核",
  Desc = "需要有核",
  Callback = function()
    local nukeRemote = game:GetService("ReplicatedStorage").packages.Net:FindFirstChild("RE/Nuke")
    if nukeRemote then
      nukeRemote:FireServer()
    end
  end,
})
local walkOnWaterToggle = SubTab:Toggle({
  Title = "海上行走",
  Callback = function(enabled)
    local fishingZones = workspace:FindFirstChild("zones")
    if fishingZones then
      local fishingZone = fishingZones:FindFirstChild("fishing")
      if fishingZone then
        for _, zone in pairs(fishingZone:GetChildren()) do
          if zone.Name == "Ocean" or zone.Name == "Deep Ocean" then
            zone.CanCollide = enabled
          end
        end
        warn("Walk On Water state:", enabled)
      end
    end
  end,
})
local showCoordinatesConnection = nil
local coordinatesLabel = nil
SubTab:Toggle({
  Title = "显示坐标",
  Callback = function(enabled)
    if enabled then
      local gpsMain = ReplicatedStorage:FindFirstChild("resources")
      if gpsMain then
        gpsMain = gpsMain:FindFirstChild("items")
        if gpsMain then
          gpsMain = gpsMain:FindFirstChild("items")
          if gpsMain then
            gpsMain = gpsMain:FindFirstChild("GPS")
            if gpsMain then
              gpsMain = gpsMain:FindFirstChild("GPS")
              if gpsMain then
                gpsMain = gpsMain:FindFirstChild("gpsMain")
                if gpsMain then
                  local xyzTemplate = gpsMain:FindFirstChild("xyz")
                  if xyzTemplate then
                    coordinatesLabel = xyzTemplate:Clone()
                    local playerGui = LocalPlayer.PlayerGui
                    local hud = playerGui:WaitForChild("hud")
                    local safezone = hud:WaitForChild("safezone")
                    local backpack = safezone:WaitForChild("backpack")
                    coordinatesLabel.Parent = backpack
                    
                    local position = GetPosition()
                    local positionText = string.format("%s, %s, %s", ExportValue(position[1]), ExportValue(position[2]), ExportValue(position[3]))
                    coordinatesLabel.Text = [[<font color='#ff4949'>X</font><font color='#a3ff81'>Y</font><font color='#626aff'>Z</font>: ]] .. positionText
                    
                    showCoordinatesConnection = game:GetService("RunService").Heartbeat:Connect(function()
                      if coordinatesLabel and coordinatesLabel.Parent then
                        local currentPosition = GetPosition()
                        positionText = string.format("%s, %s, %s", ExportValue(currentPosition[1]), ExportValue(currentPosition[2]), ExportValue(currentPosition[3]))
                        coordinatesLabel.Text = [[<font color='#ff4949'>X</font><font color='#a3ff81'>Y</font><font color='#626aff'>Z</font>: ]] .. positionText
                      end
                    end)
                  end
                end
              end
            end
          end
        end
      end
    else
      if coordinatesLabel then
        coordinatesLabel:Destroy()
        coordinatesLabel = nil
      end
      if showCoordinatesConnection then
        showCoordinatesConnection:Disconnect()
        showCoordinatesConnection = nil
      end
    end
  end,
})
function GetPosition()
  local humanoidRootPart = (LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()):FindFirstChild("HumanoidRootPart")
  if humanoidRootPart then
    return {
      humanoidRootPart.Position.X,
      humanoidRootPart.Position.Y,
      humanoidRootPart.Position.Z
    }
  end
  return {0, 0, 0}
end
function ExportValue(value)
  return string.format("%.2f", value)
end
local fishRadarToggle = SubTab:Toggle({
  Title = "鱼区域显示",
  Callback = function(enabled)
    local CollectionService = game:GetService("CollectionService")
    for _, taggedObject in pairs(CollectionService:GetTagged("radarTag")) do
      if taggedObject:IsA("BillboardGui") or taggedObject:IsA("SurfaceGui") then
        taggedObject.Enabled = enabled
      end
    end
    warn("Bypass Fish Radar state:", enabled)
  end,
})
local isAirWallEnabled = false
local airWallConnection = nil
local lastAirWallPosition = nil
SubTab:Toggle({
  Title = "生成空气墙",
  Callback = function(enabled)
    isAirWallEnabled = enabled
    if airWallConnection then
      airWallConnection:Disconnect()
      airWallConnection = nil
    end
    
    if isAirWallEnabled then
      local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
      local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
      
      local function createAirWall(position)
        local part = Instance.new("Part")
        part.Size = Vector3.new(5, 1, 5)
        part.Position = Vector3.new(position.X, position.Y - 3, position.Z)
        part.Anchored = true
        part.Transparency = 0.5
        part.CanCollide = true
        part.Material = Enum.Material.ForceField
        part.Parent = workspace
      end
      
      lastAirWallPosition = humanoidRootPart.Position
      
      airWallConnection = RunService.Heartbeat:Connect(function()
        if not isAirWallEnabled then
          if airWallConnection then
            airWallConnection:Disconnect()
            airWallConnection = nil
          end
          return
        end
        
        if humanoidRootPart and humanoidRootPart.Parent then
          local currentPosition = humanoidRootPart.Position
          if lastAirWallPosition and (currentPosition - lastAirWallPosition).Magnitude > 3 then
            lastAirWallPosition = currentPosition
            createAirWall(Vector3.new(math.floor(currentPosition.X), math.floor(currentPosition.Y), math.floor(currentPosition.Z)))
          end
        end
      end)
    end
  end,
})
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local isAutoPurchaseEnabled = false
local confirmButtonTask = nil
local buttonImageTask = nil
local confirmDescendantConnection = nil
local buttonImageDescendantConnection = nil

local function clickButton(button)
  if button then
    GuiService.SelectedObject = button
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
  end
end

local function pressE()
  VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
  VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
end

local function setupConfirmButtonListener()
  if confirmDescendantConnection then
    confirmDescendantConnection:Disconnect()
    confirmDescendantConnection = nil
  end
  
  if confirmButtonTask then
    task.cancel(confirmButtonTask)
    confirmButtonTask = nil
  end
  
  local overUI = PlayerGui:FindFirstChild("over", true)
  if overUI then
    local prompt = overUI:FindFirstChild("prompt")
    if prompt then
      local confirmButton = prompt:FindFirstChild("confirm")
      if confirmButton and isAutoPurchaseEnabled then
        confirmButtonTask = task.spawn(function()
          while isAutoPurchaseEnabled do
            if confirmButton and confirmButton.Parent then
              clickButton(confirmButton)
              task.wait(0.2)
            else
              break
            end
          end
        end)
      end
    end
  end
  
  confirmDescendantConnection = PlayerGui.DescendantAdded:Connect(function(descendant)
    if isAutoPurchaseEnabled and descendant.Name == "confirm" and descendant.Parent and descendant.Parent.Name == "prompt" and descendant.Parent.Parent and descendant.Parent.Parent.Name == "over" then
      task.spawn(function()
        while isAutoPurchaseEnabled do
          if descendant and descendant.Parent then
            clickButton(descendant)
            task.wait(0.2)
          else
            break
          end
        end
      end)
    end
  end)
end

local function setupButtonImageListener()
  if buttonImageDescendantConnection then
    buttonImageDescendantConnection:Disconnect()
    buttonImageDescendantConnection = nil
  end
  
  if buttonImageTask then
    task.cancel(buttonImageTask)
    buttonImageTask = nil
  end
  
  local proximityPrompts = PlayerGui:FindFirstChild("ProximityPrompts", true)
  if proximityPrompts then
    local promptTemplate = proximityPrompts:FindFirstChild("PromptTemplate")
    if promptTemplate then
      local frame = promptTemplate:FindFirstChild("Frame")
      if frame then
        local inputFrame = frame:FindFirstChild("InputFrame")
        if inputFrame then
          local innerFrame = inputFrame:FindFirstChild("Frame")
          if innerFrame then
            local buttonImage = innerFrame:FindFirstChild("ButtonImage")
            if buttonImage and isAutoPurchaseEnabled then
              buttonImageTask = task.spawn(function()
                while isAutoPurchaseEnabled do
                  if buttonImage and buttonImage.Parent then
                    clickButton(buttonImage)
                    pressE()
                    task.wait(0.2)
                  else
                    break
                  end
                end
              end)
            end
          end
        end
      end
    end
  end
  
  buttonImageDescendantConnection = PlayerGui.DescendantAdded:Connect(function(descendant)
    if isAutoPurchaseEnabled and descendant.Name == "ButtonImage" then
      local parent = descendant.Parent
      if parent and parent.Name == "Frame" then
        parent = parent.Parent
        if parent and parent.Name == "InputFrame" then
          parent = parent.Parent
          if parent and parent.Name == "Frame" then
            parent = parent.Parent
            if parent and parent.Name == "PromptTemplate" then
              parent = parent.Parent
              if parent and parent.Name == "ProximityPrompts" then
                task.spawn(function()
                  while isAutoPurchaseEnabled do
                    if descendant and descendant.Parent then
                      clickButton(descendant)
                      pressE()
                      task.wait(0.2)
                    else
                      break
                    end
                  end
                end)
              end
            end
          end
        end
      end
    end
  end)
end

SubTab:Toggle({
  Title = "自动购买",
  Callback = function(enabled)
    isAutoPurchaseEnabled = enabled
    if isAutoPurchaseEnabled then
      setupConfirmButtonListener()
      setupButtonImageListener()
    else
      if confirmButtonTask then
        task.cancel(confirmButtonTask)
        confirmButtonTask = nil
      end
      if buttonImageTask then
        task.cancel(buttonImageTask)
        buttonImageTask = nil
      end
      if confirmDescendantConnection then
        confirmDescendantConnection:Disconnect()
        confirmDescendantConnection = nil
      end
      if buttonImageDescendantConnection then
        buttonImageDescendantConnection:Disconnect()
        buttonImageDescendantConnection = nil
      end
    end
  end,
})
local changePlayerNameInput = SubTab:Input({
  Title = "修改玩家名字",
  Desc = "修改名字",
  Value = "输入",
  PlaceholderText = "你在看什么嘛",
  ClearTextOnFocus = true,
  Callback = function(input)
    local character = workspace:FindFirstChild(LocalPlayer.Name)
    if character then
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if humanoidRootPart then
        local user = humanoidRootPart:FindFirstChild("user")
        if user then
          local userName = user:FindFirstChild("user")
          if userName then
            userName.Text = input
          end
        end
      end
    end
  end,
})
local changeLeaderboardCashInput = SubTab:Input({
  Title = "修改玩家排行榜C$",
  Desc = "请输入新的C$值",
  Value = "输入",
  PlaceholderText = "你在看什么嘛",
  ClearTextOnFocus = true,
  Callback = function(input)
    local cashValue = tonumber(input)
    if cashValue then
      if LocalPlayer:FindFirstChild("leaderstats") and LocalPlayer.leaderstats:FindFirstChild("C$") then
        LocalPlayer.leaderstats["C$"].Value = cashValue
      end
    end
  end,
})
local autoCrateScreenGui = nil
local autoCrateButton = nil
local isAutoCrateEnabled = false
local autoCrateConnection = nil

SubTab:Button({
  Title = "自动开箱",
  Callback = function()
    if autoCrateScreenGui and autoCrateScreenGui.Parent then
      return
    end
    
    
    autoCrateScreenGui = Instance.new("ScreenGui")
    autoCrateScreenGui.Name = "AutoCrateGui"
    autoCrateScreenGui.Parent = game.CoreGui
    autoCrateScreenGui.ResetOnSpawn = false
    
    autoCrateButton = Instance.new("ImageButton")
    autoCrateButton.Size = UDim2.new(0, 60, 0, 60)
    autoCrateButton.Position = UDim2.new(0.05, 0, 0.05, 0)
    autoCrateButton.Image = "rbxassetid://72347864782725"
    autoCrateButton.BackgroundTransparency = 1
    autoCrateButton.Parent = autoCrateScreenGui
    
    local function startAutoCrate()
      if not autoCrateConnection then
        autoCrateConnection = RunService.RenderStepped:Connect(function()
          local camera = workspace.CurrentCamera
          if camera then
            VirtualInputManager:SendMouseButtonEvent(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2, 0, true, game, 0)
            task.wait(0.1)
            VirtualInputManager:SendMouseButtonEvent(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2, 0, false, game, 0)
          end
        end)
      end
    end
    
    local function stopAutoCrate()
      if autoCrateConnection then
        autoCrateConnection:Disconnect()
        autoCrateConnection = nil
      end
    end
    
    autoCrateButton.MouseButton1Click:Connect(function()
      isAutoCrateEnabled = not isAutoCrateEnabled
      if isAutoCrateEnabled then
        autoCrateButton.Image = "rbxassetid://112352263547758"
        startAutoCrate()
      else
        autoCrateButton.Image = "rbxassetid://72347864782725"
        stopAutoCrate()
      end
    end)
  end,
})
SubTab:Button({
  Title = "自动寻找宝箱",
  Description = "不需要时可以重进",
  Tab = Main,
  Callback = function()
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    
    local function repairTreasureMaps()
      local treasureMaps = {}
      for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item.Name == "Treasure Map" then
          table.insert(treasureMaps, item)
        end
      end
      
      for _, treasureMap in ipairs(treasureMaps) do
        local hud = PlayerGui:FindFirstChild("hud")
        if hud then
          local safezone = hud:FindFirstChild("safezone")
          if safezone then
            local backpack = safezone:FindFirstChild("backpack")
            if backpack then
              local events = backpack:FindFirstChild("events")
              if events then
                local equip = events:FindFirstChild("equip")
                if equip then
                  equip:FireServer(unpack({[1] = treasureMap}))
                end
              end
            end
          end
        end
        
        local jackMarrow = workspace:FindFirstChild("world")
        if jackMarrow then
          jackMarrow = jackMarrow:FindFirstChild("npcs")
          if jackMarrow then
            jackMarrow = jackMarrow:FindFirstChild("Jack Marrow")
            if jackMarrow then
              local treasure = jackMarrow:FindFirstChild("treasure")
              if treasure then
                local repairmap = treasure:FindFirstChild("repairmap")
                if repairmap then
                  repairmap:InvokeServer()
                  task.wait(0.5)
                  repairmap:InvokeServer()
                end
              end
            end
          end
        end
        task.wait(0.5)
      end
    end
    
    local function teleportToPosition(x, y, z)
      if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(x, y, z)
      end
    end
    
    local function findAndTeleportToChest()
      local world = workspace:FindFirstChild("world")
      if world then
        local chests = world:FindFirstChild("chests")
        if chests then
          for _, chest in pairs(chests:GetChildren()) do
            if chest.Name:match("TreasureChest_") then
              if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = chest.CFrame
              end
              break
            end
          end
        end
      end
    end
    
    local function clickButton(button)
      if button then
        GuiService.SelectedObject = button
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
      end
    end
    
    local function pressE()
      VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
      VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
    end
    
    local promptConnection = ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
      prompt.HoldDuration = 0
    end)
    
    local proximityPrompts = PlayerGui:FindFirstChild("ProximityPrompts", true)
    if proximityPrompts then
      local promptTemplate = proximityPrompts:FindFirstChild("PromptTemplate")
      if promptTemplate then
        local frame = promptTemplate:FindFirstChild("Frame")
        if frame then
          local inputFrame = frame:FindFirstChild("InputFrame")
          if inputFrame then
            local innerFrame = inputFrame:FindFirstChild("Frame")
            if innerFrame then
              local buttonImage = innerFrame:FindFirstChild("ButtonImage")
              if buttonImage then
                task.spawn(function()
                  while buttonImage and buttonImage.Parent do
                    clickButton(buttonImage)
                    pressE()
                    task.wait(0.2)
                  end
                end)
              end
            end
          end
        end
      end
    end
    
    local descendantConnection = PlayerGui.DescendantAdded:Connect(function(descendant)
      if descendant.Name == "ButtonImage" then
        local parent = descendant.Parent
        if parent and parent.Name == "Frame" then
          parent = parent.Parent
          if parent and parent.Name == "InputFrame" then
            parent = parent.Parent
            if parent and parent.Name == "Frame" then
              parent = parent.Parent
              if parent and parent.Name == "PromptTemplate" then
                parent = parent.Parent
                if parent and parent.Name == "ProximityPrompts" then
                  task.spawn(function()
                    while descendant and descendant.Parent do
                      clickButton(descendant)
                      pressE()
                      task.wait(0.2)
                    end
                  end)
                end
              end
            end
          end
        end
      end
    end)
    
    task.spawn(function()
      teleportToPosition(-2826, 214, 1520)
      repairTreasureMaps()
      while true do
        findAndTeleportToChest()
        task.wait(0.1)
      end
    end)
  end,
})
SubTab:Button({
  Title = "降低画质",
  Callback = function()
    
    loadstring(game:HttpGet("https://raw.githubusercontent.com/ago106/ScriptsRoblox/refs/heads/main/FpS"))()
  end,
})
local getAllRodsButton = SubTab:Button({
  Title = "获取所有竿子",
  Desc = "需要你足够的钱",
  Callback = function()
    local purchaseEvent = ReplicatedStorage:FindFirstChild("events")
    if purchaseEvent then
      purchaseEvent = purchaseEvent:FindFirstChild("purchase")
      if purchaseEvent then
        local resources = ReplicatedStorage:FindFirstChild("resources")
        if resources then
          local items = resources:FindFirstChild("items")
          if items then
            local rods = items:FindFirstChild("rods")
            if rods then
              for _, rodFolder in pairs(rods:GetChildren()) do
                if rodFolder:IsA("Folder") then
                  purchaseEvent:FireServer(rodFolder.Name, "Rod", nil, 1)
                end
              end
            end
          end
        end
      end
    end
  end,
})
local instantInteractConnection = nil
SubTab:Button({
  Title = "即时互动",
  Callback = function()
    if instantInteractConnection then
      instantInteractConnection:Disconnect()
      instantInteractConnection = nil
    else
      instantInteractConnection = ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
        prompt.HoldDuration = 0
      end)
    end
  end,
})
SubTab:Button({
  Title = "飞行",
  Callback = function()
    
    loadstring(game:HttpGet("https://pastebin.com/raw/J9PbZFVP", true))()
  end,
})
SubTab:Button({
  Title = "全图变亮",
  Callback = function()
    local Lighting = game:GetService("Lighting")
    Lighting.Brightness = 5
    Lighting.Ambient = Color3.fromRGB(255, 255, 255)
    Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    Lighting.GlobalShadows = false
    Lighting.FogEnd = 100000
    Lighting.ClockTime = 12
    Lighting.Technology = Enum.Technology.Future
    print("全图亮度已调整完成！")
  end,
})
SubTab:Button({
  Title = "寻找商人",
  Callback = function()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    local function showNotification(title, message)
      local screenGui = Instance.new("ScreenGui")
      screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
      
      local frame = Instance.new("Frame")
      frame.Size = UDim2.new(0.3, 0, 0.1, 0)
      frame.Position = UDim2.new(0.35, 0, 0.05, 0)
      frame.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
      frame.Parent = screenGui
      
      local titleLabel = Instance.new("TextLabel")
      titleLabel.Size = UDim2.new(1, 0, 0.5, 0)
      titleLabel.Text = title
      titleLabel.Font = Enum.Font.SourceSansBold
      titleLabel.TextSize = 24
      titleLabel.TextColor3 = Color3.new(1, 1, 1)
      titleLabel.BackgroundTransparency = 1
      titleLabel.Parent = frame
      
      local messageLabel = Instance.new("TextLabel")
      messageLabel.Size = UDim2.new(1, 0, 0.5, 0)
      messageLabel.Position = UDim2.new(0, 0, 0.5, 0)
      messageLabel.Text = message
      messageLabel.Font = Enum.Font.SourceSans
      messageLabel.TextSize = 18
      messageLabel.TextColor3 = Color3.new(1, 1, 1)
      messageLabel.BackgroundTransparency = 1
      messageLabel.Parent = frame
      
      task.wait(2)
      TweenService:Create(frame, TweenInfo.new(1), {
        BackgroundTransparency = 1,
      }):Play()
      TweenService:Create(titleLabel, TweenInfo.new(1), {
        TextTransparency = 1,
      }):Play()
      TweenService:Create(messageLabel, TweenInfo.new(1), {
        TextTransparency = 1,
      }):Play()
      task.wait(1)
      screenGui:Destroy()
    end
    
    local hasTeleported = false
    
    local function checkForMerchant()
      local active = Workspace:FindFirstChild("active")
      if active then
        local merchantBoat = active:FindFirstChild("Merchant Boat")
        if merchantBoat then
          local boat = merchantBoat:FindFirstChild("Boat")
          if boat then
            local merchantBoatInner = boat:FindFirstChild("Merchant Boat")
            if merchantBoatInner then
              local core = merchantBoatInner:FindFirstChild("core")
              if core and not hasTeleported then
                if humanoidRootPart then
                  humanoidRootPart.CFrame = core.CFrame + Vector3.new(0, 5, 0)
                end
                hasTeleported = true
                showNotification("通知", "检测到商人船，已自动传送到附近！")
              elseif not core then
                hasTeleported = false
              end
            else
              hasTeleported = false
            end
          else
            hasTeleported = false
          end
        else
          hasTeleported = false
        end
      else
        hasTeleported = false
      end
    end
    
    task.spawn(function()
      while true do
        checkForMerchant()
        task.wait(1)
      end
    end)
  end,
})
SubTab:Button({
  Title = "一键获取核弹",
  Callback = function()
    
    loadstring(game:HttpGet("https://pastefy.app/YF21aXwe/raw"))()
  end,
})
SubTab:Section({
  Title = "删除",
})
SubTab:Button({
  Title = "聊天",
  Callback = function()
    
    game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
  end,
})
SubTab:Section({
  Title = "宝箱",
})
SubTab:Button({
  Title = "收集宝箱",
  Callback = function()
    for _, descendant in ipairs(Workspace:GetDescendants()) do
      if descendant:IsA("ProximityPrompt") then
        descendant.HoldDuration = 0
      end
    end
    
    local world = Workspace:FindFirstChild("world")
    if world then
      local chests = world:FindFirstChild("chests")
      if chests then
        for _, descendant in pairs(chests:GetDescendants()) do
          if descendant:IsA("Part") and descendant:FindFirstChild("ChestSetup") then
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
              character.HumanoidRootPart.CFrame = descendant.CFrame
              
              for _, promptDescendant in pairs(chests:GetDescendants()) do
                if promptDescendant:IsA("ProximityPrompt") then
                  promptDescendant.HoldDuration = 0
                  promptDescendant:InputHoldBegin()
                  task.wait(0.1)
                  promptDescendant:InputHoldEnd()
                end
              end
              task.wait(1)
            end
          end
        end
      end
    end
  end,
})
SubTab:Button({
  Title = "修复地图",
  Callback = function()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
      for _, item in pairs(backpack:GetChildren()) do
        if item.Name == "Treasure Map" then
          local character = LocalPlayer.Character
          if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
              humanoid:EquipTool(item)
              
              local world = workspace:FindFirstChild("world")
              if world then
                local npcs = world:FindFirstChild("npcs")
                if npcs then
                  local jackMarrow = npcs:FindFirstChild("Jack Marrow")
                  if jackMarrow then
                    local treasure = jackMarrow:FindFirstChild("treasure")
                    if treasure then
                      local repairmap = treasure:FindFirstChild("repairmap")
                      if repairmap then
                        repairmap:InvokeServer()
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end,
})
SubTab:Button({
  Title = "传送修地图的npc",
  Callback = function()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoidRootPart.CFrame = CFrame.new(257.22, 135.88, 62.53)
  end,
})
SubTab:Section({
  Title = "交易",
})
local tradeTargetName = ""
local tradeAmount = 0
local tradeTargetInput = SubTab:Input({
  Title = "输入玩家名字",
  Desc = "输入后点交易",
  Value = "",
  PlaceholderText = "请输入玩家名字",
  ClearTextOnFocus = true,
  Callback = function(input)
    tradeTargetName = input
    print("交易目标更新为：" .. (tradeTargetName or "未指定"))
  end,
})
local tradeAmountInput = SubTab:Input({
  Title = "输入交易的数量",
  Desc = "交易数量",
  Value = "",
  PlaceholderText = "请输入交易数量",
  ClearTextOnFocus = true,
  Callback = function(input)
    tradeAmount = tonumber(input) or 0
    if tradeAmount <= 0 then
      print("请输入有效的交易数量")
    else
      print("交易数量已设置为：" .. tradeAmount)
    end
  end,
})
local startTradeButton = SubTab:Button({
  Title = "开始交易",
  Callback = function()
    if not tradeTargetName or tradeTargetName == "" then
      print("请输入有效的玩家名字")
      return 
    end
    local Players = game:GetService("Players")
    local targetPlayer = Players:FindFirstChild(tradeTargetName)
    if not targetPlayer then
      print("玩家 " .. tradeTargetName .. " 不存在，请检查输入的名字")
      return 
    end
    local character = LocalPlayer.Character
    if not character then
      print("角色不存在，请等待角色加载")
      return
    end
    local tool = character:FindFirstChildOfClass("Tool")
    if not tool then
      print("未找到可用物品，请手持物品后重试")
      return 
    end
    local offer = tool:FindFirstChild("offer")
    if offer then
      offer:FireServer(unpack({
        targetPlayer,
        tradeAmount
      }))
      print("交易完成，目标：" .. tradeTargetName .. "，交易数量：" .. tradeAmount)
    else
      print("当前物品不支持交易功能")
    end
  end,
})
local isRemoteSellEnabled = false
SellTab:Toggle({
  Title = "远程出售",
  Callback = function(enabled)
    isRemoteSellEnabled = enabled
    if isRemoteSellEnabled then
      task.spawn(function()
        while isRemoteSellEnabled do
          task.wait(0)
          pcall(function()
    local events = ReplicatedStorage:FindFirstChild("events")
            if events then
              local sellEvent = events:FindFirstChild("Sell")
              if sellEvent then
                sellEvent:InvokeServer()
              end
            end
          end)
        end
      end)
    end
  end,
})
SellTab:Button({
  Title = "一键出售",
  Callback = function()
    local events = ReplicatedStorage:FindFirstChild("events")
    if events then
      local sellAllEvent = events:FindFirstChild("SellAll")
      if sellAllEvent then
        sellAllEvent:InvokeServer()
      end
    end
  end,
})
SellTab:Section({
  Title = "设置出售",
})
local autoSellSettings = {
  legendary = false,
  mythical = false,
  relic = false,
  exotic = false,
  event = false,
  gemstone = false,
}
local function updateAutoSellSetting(settingName, enabled)
  autoSellSettings[settingName] = enabled
  local packages = ReplicatedStorage:FindFirstChild("packages")
  if packages then
    local net = packages:FindFirstChild("Net")
    if net then
      local updateRemote = net:FindFirstChild("RE/Settings/Update")
      if updateRemote then
        updateRemote:FireServer(unpack({
          [1] = "willautosell_" .. settingName,
          [2] = enabled,
        }))
      end
    end
  end
end
SellTab:Toggle({
  Title = "传奇",
  Callback = function(enabled)
    updateAutoSellSetting("legendary", enabled)
  end,
})
SellTab:Toggle({
  Title = "神话",
  Callback = function(enabled)
    updateAutoSellSetting("mythical", enabled)
  end,
})
SellTab:Toggle({
  Title = "魔法遗迹",
  Callback = function(enabled)
    updateAutoSellSetting("relic", enabled)
  end,
})
SellTab:Toggle({
  Title = "异国鱼",
  Callback = function(enabled)
    updateAutoSellSetting("exotic", enabled)
  end,
})
SellTab:Toggle({
  Title = "限量鱼",
  Callback = function(enabled)
    updateAutoSellSetting("event", enabled)
  end,
})
SellTab:Toggle({
  Title = "宝石",
  Callback = function(enabled)
    updateAutoSellSetting("gemstone", enabled)
  end,
})
local purchaseTeleportLocations = {
  ["竿"] = Vector3.new(20211, 739, 5709),
  ["流星图腾"] = Vector3.new(-1948, 275.36, 230),
  ["雪崩图腾"] = Vector3.new(19708.7, 467.6, 6060.1),
  ["暴风雪图腾"] = Vector3.new(20145.4, 743, 5805.1),
  ["风暴图腾"] = Vector3.new(33.7, 132.5, 1942.7),
  ["日蚀图腾"] = Vector3.new(5937.6, 281.6, 880.3),
  ["陨石图腾"] = Vector3.new(-1950, 275.4, 230.4),
  ["钟表图腾"] = Vector3.new(-1147.4, 134.5, -1073.2),
  ["顺风图腾"] = Vector3.new(2848.1, 178.4, 2701.3),
  ["极光图腾"] = Vector3.new(-1810.2, -136.9, -3283.1),
  ["三叉戟"] = Vector3.new(-1485, -226, -2210),
  ["诱饵_箱"] = Vector3.new(384.57513427734375, 135.3519287109375, 337.5340270996094),
  Carbon_Rod = Vector3.new(454.083618, 150.590073, 225.328827),
  Crab_Cage = Vector3.new(474.803589, 149.664566, 229.49469),
  Fast_Rod = Vector3.new(447.183563, 148.225739, 220.187454),
  Flimsy_Rod = Vector3.new(471.107697, 148.36171, 229.642441),
  GPS = Vector3.new(517.896729, 149.217636, 284.856842),
  Long_Rod = Vector3.new(485.695038, 171.656326, 145.746109),
  Lucky_Rod = Vector3.new(446.085999, 148.253006, 222.160004),
  Plastic_Rod = Vector3.new(454.425385, 148.169739, 229.172424),
}
local purchaseTeleportDropdown = TeleportTab:Dropdown({
  Title = "购买传送",
  Desc = "选择要传送的购买地点",
  Multi = false,
  Value = "选择一个地点",
  AllowNone = true,
  Values = {
    "竿",
    "流星图腾",
    "雪崩图腾",
    "暴风雪图腾",
    "风暴图腾",
    "日蚀图腾",
    "陨石图腾",
    "钟表图腾",
    "顺风图腾",
    "极光图腾",
    "三叉戟",
    "诱饵_箱",
    "Carbon_Rod",
    "Crab_Cage",
    "Fast_Rod",
    "Flimsy_Rod",
    "GPS",
    "Long_Rod",
    "Lucky_Rod",
    "Plastic_Rod"
  },
  Callback = function(selectedLocation)
    local position = purchaseTeleportLocations[selectedLocation]
    if position then
      local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
      if character and character.PrimaryPart then
        character:SetPrimaryPartCFrame(CFrame.new(position))
        warn("玩家已传送至:", selectedLocation)
      else
        warn("角色或主部件未找到！")
      end
    else
      warn("无效的地点选择")
    end
  end,
})
local regionTeleportLocations = {
  ["亚特兰蒂斯"] = Vector3.new(-4259.6, -603.4, 1812.8),
  ["克拉肯"] = Vector3.new(-4250.17, -993.59, 2156.79),
  ["新岛"] = Vector3.new(-3548.9, 130, 568.3),
  ["传送门竿子"] = Vector3.new(19987.6, 918.8, 5434.5),
  ["雪山钓鱼位置3"] = Vector3.new(20048.3, 511.6, 5420.1),
  ["雪山钓鱼位置2"] = Vector3.new(20038.2, 883.2, 5636.3),
  ["雪山钓鱼位置1"] = Vector3.new(19893.1, 581.9, 5636.2),
  ["雪山钓鱼位置"] = Vector3.new(20266.7, 273.2, 5546.1),
  ["雪山"] = Vector3.new(19949, 1142, 5549),
  ["陨石坑"] = Vector3.new(5690, 166, 600),
  ["原古岛"] = Vector3.new(4073, 131.5, 78.1),
  ["古岛1"] = Vector3.new(6035.32, 197.26, 309.9),
  ["制作新的鱼竿"] = Vector3.new(-3161.83, -745.51, 1683.37),
  ["古岛"] = Vector3.new(5948.8, 154.9, 482.2),
  ["深渊"] = Vector3.new(950.9, -711.7, 1246.3),
  ["福尔萨亨海岸"] = Vector3.new(-2512.9, 137.2, 1557.5),
  ["女巫小屋"] = Vector3.new(-949.6, 222.3, -988),
  ["硫酸池"] = Vector3.new(-1793.3, -142.7, -3414),
  ["铜鱼竿"] = Vector3.new(-977.4, -244.9, -2700.7),
  ["水下洞穴"] = Vector3.new(-1654.9, -213.7, -2846.4),
  ["三叉戟洞穴"] = Vector3.new(-1474, -226, -2302),
  ["祭坛"] = Vector3.new(1296.32, -808.55, -298.94),
  ["拱门"] = Vector3.new(998.97, 126.68, -1237.14),
  ["桦木"] = Vector3.new(1742.32, 138.26, -2502.24),
  ["使着迷"] = Vector3.new(1296.32, -808.55, -298.94),
  ["执行的"] = Vector3.new(-29.84, -250.48, 199.12),
  ["executive"] = Vector3.new(-29.84, -250.48, 199.12),
  ["保管员"] = Vector3.new(1296.32, -808.55, -298.94),
  mod_house = Vector3.new(-30.21, -249.41, 204.05),
  ["出生点"] = Vector3.new(383, 139.49, 266.9),
  ["菇类"] = Vector3.new(2501.49, 127.76, -720.7),
  roslit = Vector3.new(-1476.51, 130.17, 671.69),
  ["雪"] = Vector3.new(2648.68, 139.07, 2521.3),
  ["雪帽岛"] = Vector3.new(2648.68, 139.07, 2521.3),
  ["斯派克"] = Vector3.new(-1254.8, 133.89, 1554.2),
  ["雕像"] = Vector3.new(72.88, 138.7, -1028.42),
  ["太阳石"] = Vector3.new(-933.26, 128.14, -1119.52),
  ["沼泽"] = Vector3.new(2501.49, 127.76, -720.7),
  ["水龟"] = Vector3.new(-143.88, 141.17, 1909.61),
  ["深渊钥匙钓点"] = Vector3.new(-112.01, -492.9, 1040.33),
  ["火山"] = Vector3.new(-1888.52, 163.85, 329.24),
}
local regionTeleportDropdown = TeleportTab:Dropdown({
  Title = "选择传送地区",
  Desc = "选择要传送的地区",
  Multi = false,
  Value = "选择一个地区",
  AllowNone = true,
  Values = {
    "亚特兰蒂斯",
    "克拉肯",
    "新岛",
    "传送门竿子",
    "雪山钓鱼位置3",
    "雪山钓鱼位置2",
    "雪山钓鱼位置1",
    "雪山钓鱼位置",
    "雪山",
    "陨石坑",
    "原古岛",
    "古岛1",
    "制作新的鱼竿",
    "古岛",
    "深渊",
    "福尔萨亨海岸",
    "女巫小屋",
    "硫酸池",
    "铜鱼竿",
    "水下洞穴",
    "三叉戟洞穴",
    "祭坛",
    "拱门",
    "桦木",
    "使着迷",
    "executive",
    "保管员",
    "mod_house",
    "出生点",
    "菇类",
    "roslit",
    "雪",
    "雪帽岛",
    "斯派克",
    "雕像",
    "太阳石",
    "沼泽",
    "水龟",
    "深渊钥匙钓点",
    "火山"
  },
  Callback = function(selectedRegion)
    local position = regionTeleportLocations[selectedRegion]
    if position then
      local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
      if character and character.PrimaryPart then
        character:SetPrimaryPartCFrame(CFrame.new(position))
        warn("已传送到位置:", selectedRegion)
      else
        warn("角色或主部件未找到！")
      end
    else
      warn("无效的地点选择")
    end
  end,
})
local npcTeleportLocations = {
  ["修地图的npc"] = Vector3.new(257.22, 135.88, 62.53),
  wilson = Vector3.new(2938.80591, 277.474762, 2567.13379),
  wilsons_rod = Vector3.new(2879.2085, 135.07663, 2723.64233),
  Witch = Vector3.new(409.368713, 135.712708, 312.134338),
  Merchant = Vector3.new(416.690521, 130.302628, 342.765289),
  Synph = Vector3.new(566.36499, 151.671799, 353.993896),
  Pierre = Vector3.new(391.38855, 136.82576, 196.710144),
  Phineas = Vector3.new(469.901093, 152.136032, 277.97641),
  ["船匠"] = Vector3.new(357.972595, 135.112106, 258.154541),
  ["垂钓者"] = Vector3.new(480.102478, 151.963333, 302.226898),
  mod_Keeper = Vector3.new(-39.0905838, -245.141144, 195.837891),
  Marc = Vector3.new(466.060913, 152.480682, 224.723465),
  Lucas = Vector3.new(449.09433, 181.516205, 180.772995),
  Roslit_Keeper = Vector3.new(-1512.37891, 134.500031, 631.24353),
  Inn_Keeper = Vector3.new(487.458466, 152.300034, 231.498932),
  FishingNpc_1 = Vector3.new(-1429.04138, 134.371552, 686.034424),
  FishingNpc_2 = Vector3.new(-1778.55408, 149.791779, 648.097107),
  FishingNpc_3 = Vector3.new(-1778.26807, 147.83165, 653.258606),
  Ashe = Vector3.new(-1709.94055, 149.862411, 729.399536),
  Alfredrickus = Vector3.new(-1520.60632, 142.923264, 764.522034),
  Daisy = Vector3.new(581.550049, 166.974594, 213.499969),
  Appraiser = Vector3.new(453.003967, 151.970993, 206.907928),
}
local npcTeleportDropdown = TeleportTab:Dropdown({
  Title = "选择NPC",
  Desc = "选择要传送到的NPC位置",
  Multi = false,
  Value = "选择一个NPC",
  AllowNone = true,
  Values = {
    "修地图的npc",
    "wilson",
    "wilsons_rod",
    "Witch",
    "Merchant",
    "Synph",
    "Pierre",
    "Phineas",
    "船匠",
    "垂钓者",
    "mod_Keeper",
    "Marc",
    "Lucas",
    "Roslit_Keeper",
    "Inn_Keeper",
    "FishingNpc_1",
    "FishingNpc_2",
    "FishingNpc_3",
    "Ashe",
    "Alfredrickus",
    "Daisy",
    "Appraiser"
  },
  Callback = function(selectedNpc)
    local position = npcTeleportLocations[selectedNpc]
    if position then
      local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
      if character and character.PrimaryPart then
        character:SetPrimaryPartCFrame(CFrame.new(position))
        warn("已传送到NPC位置:", selectedNpc)
      else
        warn("角色或主部件未找到！")
      end
    else
      warn("无效的NPC选择")
    end
  end,
})
TeleportTab:Section({
  Title = "事件检测功能",
})
local savedPosition = nil
TeleportTab:Button({
  Title = "保存当前位置",
  Callback = function()
    local character = LocalPlayer.Character
    if character then
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if humanoidRootPart then
        savedPosition = humanoidRootPart.CFrame
        WindUI:Notify({
          Title = "提示",
          Content = "当前位置已保存！",
          Icon = "save",
          Duration = 5,
        })
      else
        WindUI:Notify({
          Title = "错误",
          Content = "无法找到 HumanoidRootPart，保存位置失败！",
          Icon = "error",
          Duration = 10,
        })
      end
    else
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
local isSnowcapAlgaePoolDetectionEnabled = false
local savedDetectionPosition = nil
local function smoothTeleport(humanoidRootPart, targetCFrame)
  local distance = (humanoidRootPart.Position - targetCFrame.Position).Magnitude
  local travelTime = distance / 250
  local startTime = tick()
  local startCFrame = humanoidRootPart.CFrame
  
  while tick() - startTime < travelTime do
    local progress = math.min((tick() - startTime) / travelTime, 1)
    humanoidRootPart.CFrame = startCFrame:Lerp(targetCFrame, progress)
    task.wait()
  end
  humanoidRootPart.CFrame = targetCFrame
end
TeleportTab:Toggle({
  Title = "持续检测雪冠藻池",
  Callback = function(enabled)
    if enabled then
      if isSnowcapAlgaePoolDetectionEnabled then
        WindUI:Notify({
          Title = "提示",
          Content = "检测已在进行中！",
          Icon = "eye",
          Duration = 5,
        })
        return 
      end
      isSnowcapAlgaePoolDetectionEnabled = true
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isSnowcapAlgaePoolDetectionEnabled = false
        return
      end
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if not humanoidRootPart then
        WindUI:Notify({
          Title = "错误",
          Content = "未找到 HumanoidRootPart，检测无法开始！",
          Icon = "error",
          Duration = 10,
        })
        isSnowcapAlgaePoolDetectionEnabled = false
        return 
      end
      savedDetectionPosition = humanoidRootPart.CFrame
      
      task.spawn(function()
        local hasFoundPool = false
        while isSnowcapAlgaePoolDetectionEnabled do
          task.wait(1)
          
          local zones = workspace:FindFirstChild("zones")
          if zones then
            local fishing = zones:FindFirstChild("fishing")
            if fishing then
              local snowcapAlgaePool = fishing:FindFirstChild("Snowcap Algae Pool")
              if snowcapAlgaePool and not hasFoundPool then
                if humanoidRootPart and humanoidRootPart.Parent then
                  humanoidRootPart.CFrame = CFrame.new(snowcapAlgaePool.Position)
                  WindUI:Notify({
                    Title = "成功",
                    Content = "已传送至雪冠藻池区域中心！",
                    Icon = "eye",
                    Duration = 5,
                  })
                  hasFoundPool = true
                end
              elseif not snowcapAlgaePool and hasFoundPool then
                if humanoidRootPart and humanoidRootPart.Parent and savedDetectionPosition then
                  WindUI:Notify({
                    Title = "提示",
                    Content = "雪冠藻池点消失，正在飞回保存的位置！",
                    Icon = "home",
                    Duration = 5,
                  })
                  smoothTeleport(humanoidRootPart, savedDetectionPosition)
                  hasFoundPool = false
                end
              end
            end
          end
        end
        WindUI:Notify({
          Title = "检测停止",
          Content = "玩家已退出检测！",
          Icon = "info",
          Duration = 5,
        })
      end)
    else
      isSnowcapAlgaePoolDetectionEnabled = false
      WindUI:Notify({
        Title = "提示",
        Content = "检测已关闭！",
        Icon = "eye",
        Duration = 5,
      })
    end
  end,
})
local isAncientAlgaeDetectionEnabled = false
local savedAncientAlgaePosition = nil
TeleportTab:Toggle({
  Title = "持续检测古藻",
  Callback = function(enabled)
    if enabled then
      if isAncientAlgaeDetectionEnabled then
        WindUI:Notify({
          Title = "提示",
          Content = "检测已在进行中！",
          Icon = "eye",
          Duration = 5,
        })
        return 
      end
      isAncientAlgaeDetectionEnabled = true
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isAncientAlgaeDetectionEnabled = false
        return
      end
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if not humanoidRootPart then
        WindUI:Notify({
          Title = "错误",
          Content = "未找到 HumanoidRootPart，检测无法开始！",
          Icon = "error",
          Duration = 10,
        })
        isAncientAlgaeDetectionEnabled = false
        return 
      end
      savedAncientAlgaePosition = humanoidRootPart.CFrame
      
      task.spawn(function()
        local hasFoundPool = false
        while isAncientAlgaeDetectionEnabled do
          task.wait(1)
          
          local zones = workspace:FindFirstChild("zones")
          if zones then
            local fishing = zones:FindFirstChild("fishing")
            if fishing then
              local ancientAlgaePool = fishing:FindFirstChild("Ancient Algae Pool")
              if ancientAlgaePool and not hasFoundPool then
                if humanoidRootPart and humanoidRootPart.Parent then
                  humanoidRootPart.CFrame = CFrame.new(ancientAlgaePool.Position)
                  WindUI:Notify({
                    Title = "成功",
                    Content = "已传送至Ancient Algae区域中心！",
                    Icon = "eye",
                    Duration = 5,
                  })
                  hasFoundPool = true
                end
              elseif not ancientAlgaePool and hasFoundPool then
                if humanoidRootPart and humanoidRootPart.Parent and savedAncientAlgaePosition then
                  WindUI:Notify({
                    Title = "提示",
                    Content = "Ancient Algae点消失，正在飞回保存的位置！",
                    Icon = "home",
                    Duration = 5,
                  })
                  smoothTeleport(humanoidRootPart, savedAncientAlgaePosition)
                  hasFoundPool = false
                end
              end
            end
          end
        end
        WindUI:Notify({
          Title = "检测停止",
          Content = "玩家已退出检测！",
          Icon = "info",
          Duration = 5,
        })
      end)
    else
      isAncientAlgaeDetectionEnabled = false
      WindUI:Notify({
        Title = "提示",
        Content = "检测已关闭！",
        Icon = "eye",
        Duration = 5,
      })
    end
  end,
})
local isGoldenTideDetectionEnabled = false
local savedGoldenTidePosition = nil
TeleportTab:Toggle({
  Title = "持续检测金潮",
  Callback = function(enabled)
    if enabled then
      if isGoldenTideDetectionEnabled then
        WindUI:Notify({
          Title = "提示",
          Content = "检测已在进行中！",
          Icon = "eye",
          Duration = 5,
        })
        return 
      end
      isGoldenTideDetectionEnabled = true
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isGoldenTideDetectionEnabled = false
        return
      end
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if not humanoidRootPart then
        WindUI:Notify({
          Title = "错误",
          Content = "未找到 HumanoidRootPart，检测无法开始！",
          Icon = "error",
          Duration = 10,
        })
        isGoldenTideDetectionEnabled = false
        return 
      end
      savedGoldenTidePosition = humanoidRootPart.CFrame
      
      task.spawn(function()
        local hasFoundTide = false
        while isGoldenTideDetectionEnabled do
          task.wait(1)
          
          local zones = workspace:FindFirstChild("zones")
          if zones then
            local fishing = zones:FindFirstChild("fishing")
            if fishing then
              local goldenTide = fishing:FindFirstChild("Golden Tide")
              if goldenTide and not hasFoundTide then
                if humanoidRootPart and humanoidRootPart.Parent then
                  humanoidRootPart.CFrame = CFrame.new(goldenTide.Position)
                  WindUI:Notify({
                    Title = "成功",
                    Content = "已传送至金潮区域中心！",
                    Icon = "eye",
                    Duration = 5,
                  })
                  hasFoundTide = true
                end
              elseif not goldenTide and hasFoundTide then
                if humanoidRootPart and humanoidRootPart.Parent and savedGoldenTidePosition then
                  WindUI:Notify({
                    Title = "提示",
                    Content = "金潮点消失，正在飞回保存的位置！",
                    Icon = "home",
                    Duration = 5,
                  })
                  smoothTeleport(humanoidRootPart, savedGoldenTidePosition)
                  hasFoundTide = false
                end
              end
            end
          end
        end
        WindUI:Notify({
          Title = "检测停止",
          Content = "玩家已退出检测！",
          Icon = "info",
          Duration = 5,
        })
      end)
    else
      isGoldenTideDetectionEnabled = false
      WindUI:Notify({
        Title = "提示",
        Content = "检测已关闭！",
        Icon = "eye",
        Duration = 5,
      })
    end
  end,
})
local isMushgroveAlgaeDetectionEnabled = false
local savedMushgroveAlgaePosition = nil
TeleportTab:Toggle({
  Title = "持续检测Mushgrove藻池",
  Callback = function(enabled)
    if enabled then
      if isMushgroveAlgaeDetectionEnabled then
        WindUI:Notify({
          Title = "提示",
          Content = "检测已在进行中！",
          Icon = "eye",
          Duration = 5,
        })
        return 
      end
      isMushgroveAlgaeDetectionEnabled = true
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isMushgroveAlgaeDetectionEnabled = false
        return
      end
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if not humanoidRootPart then
        WindUI:Notify({
          Title = "错误",
          Content = "未找到 HumanoidRootPart，检测无法开始！",
          Icon = "error",
          Duration = 10,
        })
        isMushgroveAlgaeDetectionEnabled = false
        return 
      end
      savedMushgroveAlgaePosition = humanoidRootPart.CFrame
      
      task.spawn(function()
        local hasFoundPool = false
        while isMushgroveAlgaeDetectionEnabled do
          task.wait(1)
          
          local zones = workspace:FindFirstChild("zones")
          if zones then
            local fishing = zones:FindFirstChild("fishing")
            if fishing then
              local mushgroveAlgaePool = fishing:FindFirstChild("Mushgrove Algae Pool")
              if mushgroveAlgaePool and not hasFoundPool then
                if humanoidRootPart and humanoidRootPart.Parent then
                  humanoidRootPart.CFrame = CFrame.new(mushgroveAlgaePool.Position)
                  WindUI:Notify({
                    Title = "成功",
                    Content = "已传送至Mushgrove Algae区域中心！",
                    Icon = "eye",
                    Duration = 5,
                  })
                  hasFoundPool = true
                end
              elseif not mushgroveAlgaePool and hasFoundPool then
                if humanoidRootPart and humanoidRootPart.Parent and savedMushgroveAlgaePosition then
                  WindUI:Notify({
                    Title = "提示",
                    Content = "Mushgrove Algae点消失，正在飞回保存的位置！",
                    Icon = "home",
                    Duration = 5,
                  })
                  smoothTeleport(humanoidRootPart, savedMushgroveAlgaePosition)
                  hasFoundPool = false
                end
              end
            end
          end
        end
        WindUI:Notify({
          Title = "检测停止",
          Content = "玩家已退出检测！",
          Icon = "info",
          Duration = 5,
        })
      end)
    else
      isMushgroveAlgaeDetectionEnabled = false
      WindUI:Notify({
        Title = "提示",
        Content = "检测已关闭！",
        Icon = "eye",
        Duration = 5,
      })
    end
  end,
})
local isForsakenAlgaeDetectionEnabled = false
local savedForsakenAlgaePosition = nil
TeleportTab:Toggle({
  Title = "持续检测弃藻池",
  Callback = function(enabled)
    if enabled then
      if isForsakenAlgaeDetectionEnabled then
        WindUI:Notify({
          Title = "提示",
          Content = "检测已在进行中！",
          Icon = "eye",
          Duration = 5,
        })
        return 
      end
      isForsakenAlgaeDetectionEnabled = true
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isForsakenAlgaeDetectionEnabled = false
        return
      end
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if not humanoidRootPart then
        WindUI:Notify({
          Title = "错误",
          Content = "未找到 HumanoidRootPart，检测无法开始！",
          Icon = "error",
          Duration = 10,
        })
        isForsakenAlgaeDetectionEnabled = false
        return 
      end
      savedForsakenAlgaePosition = humanoidRootPart.CFrame
      
      task.spawn(function()
        local hasFoundPool = false
        while isForsakenAlgaeDetectionEnabled do
          task.wait(1)
          
          local zones = workspace:FindFirstChild("zones")
          if zones then
            local fishing = zones:FindFirstChild("fishing")
            if fishing then
              local forsakenAlgaePool = fishing:FindFirstChild("Forsaken Algae Pool")
              if forsakenAlgaePool and not hasFoundPool then
                if humanoidRootPart and humanoidRootPart.Parent then
                  humanoidRootPart.CFrame = CFrame.new(forsakenAlgaePool.Position)
                  WindUI:Notify({
                    Title = "成功",
                    Content = "已传送至弃藻池区域中心！",
                    Icon = "eye",
                    Duration = 5,
                  })
                  hasFoundPool = true
                end
              elseif not forsakenAlgaePool and hasFoundPool then
                if humanoidRootPart and humanoidRootPart.Parent and savedForsakenAlgaePosition then
                  WindUI:Notify({
                    Title = "提示",
                    Content = "弃藻池点消失，正在飞回保存的位置！",
                    Icon = "home",
                    Duration = 5,
                  })
                  smoothTeleport(humanoidRootPart, savedForsakenAlgaePosition)
                  hasFoundPool = false
                end
              end
            end
          end
        end
        WindUI:Notify({
          Title = "检测停止",
          Content = "玩家已退出检测！",
          Icon = "info",
          Duration = 5,
        })
      end)
    else
      isForsakenAlgaeDetectionEnabled = false
      WindUI:Notify({
        Title = "提示",
        Content = "检测已关闭！",
        Icon = "eye",
        Duration = 5,
      })
    end
  end,
})
local isMegalodonV2DetectionEnabled = false
local megalodonV2Offset = Vector3.new(0, 5, 0)
local savedMegalodonV2Position = nil
TeleportTab:Toggle({
  Title = "持续检测巨齿鲨v2",
  Callback = function(enabled)
    if enabled then
      if isMegalodonV2DetectionEnabled then
        WindUI:Notify({
          Title = "提示",
          Content = "检测已在进行中！",
          Icon = "eye",
          Duration = 5,
        })
        return 
      end
      isMegalodonV2DetectionEnabled = true
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isMegalodonV2DetectionEnabled = false
        return
      end
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if not humanoidRootPart then
        WindUI:Notify({
          Title = "错误",
          Content = "未找到 HumanoidRootPart，检测无法开始！",
          Icon = "error",
          Duration = 10,
        })
        isMegalodonV2DetectionEnabled = false
        return 
      end
      savedMegalodonV2Position = humanoidRootPart.CFrame
      
      task.spawn(function()
        local hasFoundMegalodon = false
        while isMegalodonV2DetectionEnabled do
          task.wait(1)
          
          local zones = workspace:FindFirstChild("zones")
          if zones then
            local fishing = zones:FindFirstChild("fishing")
            if fishing then
              local megalodon = fishing:FindFirstChild("Megalodon Default")
              if megalodon and not hasFoundMegalodon then
                if humanoidRootPart and humanoidRootPart.Parent then
                  humanoidRootPart.CFrame = CFrame.new(megalodon.Position + megalodonV2Offset)
                  WindUI:Notify({
                    Title = "成功",
                    Content = "已传送至巨齿鲨区域中心！",
                    Icon = "eye",
                    Duration = 5,
                  })
                  hasFoundMegalodon = true
                end
              elseif not megalodon and hasFoundMegalodon then
                if humanoidRootPart and humanoidRootPart.Parent and savedMegalodonV2Position then
                  WindUI:Notify({
                    Title = "提示",
                    Content = "巨齿鲨点消失，正在飞回保存的位置！",
                    Icon = "home",
                    Duration = 5,
                  })
                  smoothTeleport(humanoidRootPart, savedMegalodonV2Position)
                  hasFoundMegalodon = false
                end
              end
            end
          end
        end
        WindUI:Notify({
          Title = "检测停止",
          Content = "玩家已退出检测！",
          Icon = "info",
          Duration = 5,
        })
      end)
    else
      isMegalodonV2DetectionEnabled = false
      WindUI:Notify({
        Title = "提示",
        Content = "检测已关闭！",
        Icon = "eye",
        Duration = 5,
      })
    end
  end,
})
local isMegalodonV21DetectionEnabled = false
local megalodonV21Offset = Vector3.new(0, 135, 0)
local savedMegalodonV21Position = nil
TeleportTab:Toggle({
  Title = "持续检测巨齿鲨v2.1",
  Callback = function(enabled)
    if enabled then
      if isMegalodonV21DetectionEnabled then
        WindUI:Notify({
          Title = "提示",
          Content = "检测已在进行中！",
          Icon = "eye",
          Duration = 5,
        })
        return 
      end
      isMegalodonV21DetectionEnabled = true
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isMegalodonV21DetectionEnabled = false
        return
      end
      local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
      if not humanoidRootPart then
        WindUI:Notify({
          Title = "错误",
          Content = "未找到 HumanoidRootPart，检测无法开始！",
          Icon = "error",
          Duration = 10,
        })
        isMegalodonV21DetectionEnabled = false
        return 
      end
      savedMegalodonV21Position = humanoidRootPart.CFrame
      
      task.spawn(function()
        local hasFoundMegalodon = false
        while isMegalodonV21DetectionEnabled do
          task.wait(1)
          
          local zones = workspace:FindFirstChild("zones")
          if zones then
            local fishing = zones:FindFirstChild("fishing")
            if fishing then
              local megalodon = fishing:FindFirstChild("Megalodon Default")
              if megalodon and not hasFoundMegalodon then
                if humanoidRootPart and humanoidRootPart.Parent then
                  local targetCFrame = CFrame.new(megalodon.Position + megalodonV21Offset)
                  WindUI:Notify({
                    Title = "成功",
                    Content = "正在飞往巨齿鲨区域！",
                    Icon = "eye",
                    Duration = 5,
                  })
                  hasFoundMegalodon = true
                  smoothTeleport(humanoidRootPart, targetCFrame)
                end
              elseif not megalodon and hasFoundMegalodon then
                if humanoidRootPart and humanoidRootPart.Parent and savedMegalodonV21Position then
                  WindUI:Notify({
                    Title = "提示",
                    Content = "巨齿鲨点消失，正在飞回保存的位置！",
                    Icon = "home",
                    Duration = 5,
                  })
                  smoothTeleport(humanoidRootPart, savedMegalodonV21Position)
                  hasFoundMegalodon = false
                end
              end
            end
          end
        end
        WindUI:Notify({
          Title = "检测停止",
          Content = "玩家已退出检测！",
          Icon = "info",
          Duration = 5,
        })
      end)
    else
      isMegalodonV21DetectionEnabled = false
      WindUI:Notify({
        Title = "提示",
        Content = "检测已关闭！",
        Icon = "eye",
        Duration = 5,
      })
    end
  end,
})
TeleportTab:Section({
  Title = "事件传送",
})
local isDepthsSerpentDetectionEnabled = false
TeleportTab:Button({
  Title = "检测深度-蛇",
  Callback = function()
    if isDepthsSerpentDetectionEnabled or isMegalodonV2DetectionEnabled or isMegalodonV21DetectionEnabled then
      WindUI:Notify({
        Title = "提示",
        Content = "检测已在进行中",
        Icon = "eye",
        Duration = 5,
      })
      return 
    end
    isDepthsSerpentDetectionEnabled = true
    local offset = Vector3.new(0, 135, 0)
    task.spawn(function()
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isDepthsSerpentDetectionEnabled = false
        return
      end
      
      while isDepthsSerpentDetectionEnabled do
        task.wait(1)
        
        local zones = workspace:FindFirstChild("zones")
        if zones then
          local fishing = zones:FindFirstChild("fishing")
          if fishing then
            local depthsSerpent = fishing:FindFirstChild("The Depths - Serpent")
            if depthsSerpent then
              local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
              if humanoidRootPart then
                humanoidRootPart.CFrame = CFrame.new(depthsSerpent.Position + offset)
                WindUI:Notify({
                  Title = "成功",
                  Content = "玩家已传送至 深度蛇",
                  Icon = "eye",
                  Duration = 10,
                })
              else
                WindUI:Notify({
                  Title = "错误",
                  Content = "未找到玩家的 HumanoidRootPart",
                  Icon = "error",
                  Duration = 10,
                })
              end
              isDepthsSerpentDetectionEnabled = false
              break
            end
          end
        end
      end
      
      if isDepthsSerpentDetectionEnabled then
        WindUI:Notify({
          Title = "检测停止",
          Content = "深度蛇已找到或检测已终止",
          Icon = "info",
          Duration = 5,
        })
        isDepthsSerpentDetectionEnabled = false
      end
    end)
  end,
})
local isMegalodonDetectionEnabled = false
TeleportTab:Button({
  Title = "检测巨齿鲨",
  Callback = function()
    if isMegalodonDetectionEnabled or isMegalodonV2DetectionEnabled or isMegalodonV21DetectionEnabled then
      WindUI:Notify({
        Title = "提示",
        Content = "检测已在进行中",
        Icon = "eye",
        Duration = 5,
      })
      return 
    end
    isMegalodonDetectionEnabled = true
    local offset = Vector3.new(0, 135, 0)
    task.spawn(function()
      local character = LocalPlayer.Character
      if not character then
        WindUI:Notify({
          Title = "错误",
          Content = "角色不存在，请等待角色加载！",
          Icon = "error",
          Duration = 10,
        })
        isMegalodonDetectionEnabled = false
        return
      end
      
      while isMegalodonDetectionEnabled do
        task.wait(1)
        
        local zones = workspace:FindFirstChild("zones")
        if zones then
          local fishing = zones:FindFirstChild("fishing")
          if fishing then
            local megalodon = fishing:FindFirstChild("Megalodon Default")
            if megalodon then
              local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
              if humanoidRootPart then
                humanoidRootPart.CFrame = CFrame.new(megalodon.Position + offset)
                WindUI:Notify({
                  Title = "成功",
                  Content = "玩家已传送至 巨齿鲨",
                  Icon = "eye",
                  Duration = 10,
                })
              else
                WindUI:Notify({
                  Title = "错误",
                  Content = "未找到玩家的 HumanoidRootPart",
                  Icon = "error",
                  Duration = 10,
                })
              end
              isMegalodonDetectionEnabled = false
              break
            end
          end
        end
      end
      
      if isMegalodonDetectionEnabled then
        WindUI:Notify({
          Title = "检测停止",
          Content = "巨齿鲨已找到或检测已终止",
          Icon = "info",
          Duration = 5,
        })
        isMegalodonDetectionEnabled = false
      end
    end)
  end,
})
TeleportTab:Button({
  Title = "Sunken Chests",
  Callback = function()
    local offset = Vector3.new(0, 135, 0)
    local zones = workspace:FindFirstChild("zones")
    if not zones then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 zones",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local fishing = zones:FindFirstChild("fishing")
    if not fishing then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 fishing 区域",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local sunkenChests = fishing:FindFirstChild("Sunken Chests")
    if not sunkenChests then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 Sunken Chests",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local character = LocalPlayer.Character
    if not character then
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      humanoidRootPart.CFrame = CFrame.new(sunkenChests.Position + offset)
      WindUI:Notify({
        Title = "成功",
        Content = "玩家已传送至 Sunken Chests",
        Icon = "eye",
        Duration = 10,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 HumanoidRootPart",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
TeleportTab:Button({
  Title = "弃藻池",
  Callback = function()
    local offset = Vector3.new(0, 135, 0)
    local zones = workspace:FindFirstChild("zones")
    if not zones then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 zones",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local fishing = zones:FindFirstChild("fishing")
    if not fishing then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 fishing 区域",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local forsakenAlgaePool = fishing:FindFirstChild("Forsaken Algae Pool")
    if not forsakenAlgaePool then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 弃藻池",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local character = LocalPlayer.Character
    if not character then
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      humanoidRootPart.CFrame = CFrame.new(forsakenAlgaePool.Position + offset)
      WindUI:Notify({
        Title = "成功",
        Content = "玩家已传送至 弃藻池",
        Icon = "eye",
        Duration = 10,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 HumanoidRootPart",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
TeleportTab:Button({
  Title = "奇怪的漩涡",
  Callback = function()
    local offset = Vector3.new(25, 135, 25)
    local zones = workspace:FindFirstChild("zones")
    if not zones then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 zones",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local fishing = zones:FindFirstChild("fishing")
    if not fishing then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 fishing 区域",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local isonade = fishing:FindFirstChild("Isonade")
    if not isonade then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 奇怪的漩涡",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local character = LocalPlayer.Character
    if not character then
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      humanoidRootPart.CFrame = CFrame.new(isonade.Position + offset)
      WindUI:Notify({
        Title = "成功",
        Content = "玩家已传送至 奇怪的漩涡",
        Icon = "eye",
        Duration = 10,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 HumanoidRootPart",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
TeleportTab:Button({
  Title = "大锤头鲨",
  Callback = function()
    local offset = Vector3.new(0, 135, 0)
    local zones = workspace:FindFirstChild("zones")
    if not zones then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 zones",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local fishing = zones:FindFirstChild("fishing")
    if not fishing then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 fishing 区域",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local greatHammerheadShark = fishing:FindFirstChild("Great Hammerhead Shark")
    if not greatHammerheadShark then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 大锤头鲨",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local character = LocalPlayer.Character
    if not character then
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      humanoidRootPart.CFrame = CFrame.new(greatHammerheadShark.Position + offset)
      WindUI:Notify({
        Title = "成功",
        Content = "玩家已传送至 大锤头鲨",
        Icon = "eye",
        Duration = 10,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 HumanoidRootPart",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
TeleportTab:Button({
  Title = "大白鲨",
  Callback = function()
    local offset = Vector3.new(0, 135, 0)
    local zones = workspace:FindFirstChild("zones")
    if not zones then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 zones",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local fishing = zones:FindFirstChild("fishing")
    if not fishing then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 fishing 区域",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local greatWhiteShark = fishing:FindFirstChild("Great White Shark")
    if not greatWhiteShark then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 大白鲨",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local character = LocalPlayer.Character
    if not character then
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      humanoidRootPart.CFrame = CFrame.new(greatWhiteShark.Position + offset)
      WindUI:Notify({
        Title = "成功",
        Content = "玩家已传送至 大白鲨",
        Icon = "eye",
        Duration = 10,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 HumanoidRootPart",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
TeleportTab:Button({
  Title = "巨齿鲨",
  Callback = function()
    local offset = Vector3.new(0, 135, 0)
    local zones = workspace:FindFirstChild("zones")
    if not zones then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 zones",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local fishing = zones:FindFirstChild("fishing")
    if not fishing then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 fishing 区域",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local megalodon = fishing:FindFirstChild("Megalodon Default")
    if not megalodon then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 巨齿鲨",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local character = LocalPlayer.Character
    if not character then
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      humanoidRootPart.CFrame = CFrame.new(megalodon.Position + offset)
      WindUI:Notify({
        Title = "成功",
        Content = "玩家已传送至 巨齿鲨",
        Icon = "eye",
        Duration = 10,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 HumanoidRootPart",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
TeleportTab:Button({
  Title = "鲸鲨",
  Callback = function()
    local offset = Vector3.new(0, 135, 0)
    local zones = workspace:FindFirstChild("zones")
    if not zones then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 zones",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local fishing = zones:FindFirstChild("fishing")
    if not fishing then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 fishing 区域",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local whaleShark = fishing:FindFirstChild("Whale Shark")
    if not whaleShark then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 鲸鲨",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local character = LocalPlayer.Character
    if not character then
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      humanoidRootPart.CFrame = CFrame.new(whaleShark.Position + offset)
      WindUI:Notify({
        Title = "成功",
        Content = "玩家已传送至 鲸鲨",
        Icon = "eye",
        Duration = 10,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 HumanoidRootPart",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
TeleportTab:Button({
  Title = "深度-蛇",
  Callback = function()
    local offset = Vector3.new(0, 50, 0)
    local zones = workspace:FindFirstChild("zones")
    if not zones then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 zones",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local fishing = zones:FindFirstChild("fishing")
    if not fishing then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 fishing 区域",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local depthsSerpent = fishing:FindFirstChild("The Depths - Serpent")
    if not depthsSerpent then
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 深度-蛇",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local character = LocalPlayer.Character
    if not character then
      WindUI:Notify({
        Title = "错误",
        Content = "角色不存在，请等待角色加载！",
        Icon = "error",
        Duration = 10,
      })
      return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      humanoidRootPart.CFrame = CFrame.new(depthsSerpent.Position + offset)
      WindUI:Notify({
        Title = "成功",
        Content = "玩家已传送至 深度-蛇",
        Icon = "eye",
        Duration = 10,
      })
    else
      WindUI:Notify({
        Title = "错误",
        Content = "未找到 HumanoidRootPart",
        Icon = "error",
        Duration = 10,
      })
    end
  end,
})
local function createPlayerTeleportButton(playerName, player)
  playerTeleportButtons[player.Name] = TPTab:Button({
    Title = playerName,
    Callback = function()
      local targetCharacter = player.Character
      if targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") then
        local localCharacter = LocalPlayer.Character
        if localCharacter and localCharacter.PrimaryPart then
          localCharacter:SetPrimaryPartCFrame(CFrame.new(targetCharacter.HumanoidRootPart.Position))
        else
          WindUI:Notify({
            Title = "错误",
            Content = "本地角色或 PrimaryPart 不存在",
            Icon = "error",
            Duration = 10,
          })
        end
      else
        WindUI:Notify({
          Title = "错误",
          Content = "目标玩家角色不存在",
          Icon = "error",
          Duration = 10,
        })
      end
    end,
  })
  print("Created button for: " .. playerName)
end
local function removePlayerTeleportButton(playerName)
  local button = playerTeleportButtons[playerName]
  if button then
    if typeof(button) == "Instance" then
      button:Destroy()
    elseif button.Destroy then
      button:Destroy()
    elseif button.Remove then
      button:Remove()
    elseif button.Parent then
      button.Parent = nil
    end
    playerTeleportButtons[playerName] = nil
    print("Removed button for: " .. playerName)
  end
end
local function refreshPlayerTeleportButtons()
  for playerName, button in pairs(playerTeleportButtons) do
    removePlayerTeleportButton(playerName)
  end
  for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
      createPlayerTeleportButton(player.Name, player)
    end
  end
end
Players.PlayerAdded:Connect(function(player)
  print("Player joined: " .. player.Name)
  player.CharacterAdded:Connect(function()
    refreshPlayerTeleportButtons()
  end)
end)
Players.PlayerRemoving:Connect(function(player)
  print("Player left: " .. player.Name)
  removePlayerTeleportButton(player.Name)
end)
refreshPlayerTeleportButtons()
local feedbackInput = FeedbackTab:Input({
  Title = "输入",
  Desc = "输入你想反馈的",
  Value = "输入",
  PlaceholderText = "你在看什么嘛",
  ClearTextOnFocus = true,
  Callback = function(feedbackContent)
    if feedbackContent == "" then
      warn("反馈内容不能为空！")
      return 
    end
    local embedData = {
      username = "Feedback Bot",
      embeds = {
        {
          color = 3329330,
          title = "新反馈提交",
          description = feedbackContent,
          thumbnail = {
            url = feedbackAvatarImageUrl,
          },
          fields = {
            {
              name = "名称(Name)",
              value = LocalPlayer.Name,
              inline = true,
            },
            {
              name = "昵称(DisplayName)",
              value = LocalPlayer.DisplayName,
              inline = true,
            },
            {
              name = "UserId",
              value = string.format("[%d](https://www.roblox.com/users/%d/profile)", LocalPlayer.UserId, LocalPlayer.UserId),
              inline = true,
            },
            {
              name = "设备",
              value = feedbackDeviceType,
              inline = true,
            },
            {
              name = "HWID",
              value = feedbackHwid,
              inline = true,
            },
            {
              name = "加入日期",
              value = feedbackJoinDateString,
              inline = true,
            }
          },
          footer = {
            text = "反馈时间: " .. os.date("%Y-%m-%d %H:%M:%S"),
          },
        }
      },
    }
    local httpRequest = http_request or request
    if not httpRequest and syn then
      httpRequest = syn.request
    end
    if httpRequest then
      local success, errorMessage = pcall(function()
        httpRequest({
          Url = webhookUrl,
          Method = "POST",
          Headers = {
            ["Content-Type"] = "application/json",
          },
          Body = HttpService:JSONEncode(embedData),
        })
      end)
      if success then
        print("反馈提交成功！")
      else
        warn("反馈提交失败：", errorMessage)
      end
    else
      warn("未找到可用的HTTP请求函数")
    end
  end,
})
FeedbackTab:Button({
  Title = "发送",
  Callback = function()
    print("发送反馈请求")
  end,
})
feedbackParagraph1 = FeedbackTab:Paragraph({
  Title = "反馈功能是实用的，大胆提建议！",
})
feedbackParagraph2 = FeedbackTab:Paragraph({
  Title = "若你不想在这里反馈，可以进入反馈群:139452869",
})
themeNameInput = ThemeTab:Input({
  Title = "主题",
  Value = currentThemeName,
  Callback = function(input)
    currentThemeName = input
  end,
})
ThemeTab:Colorpicker({
  Title = "背景",
  Default = (function()
    local success, result = pcall(function() return Color3.fromHex(accentColor) end)
    return success and result or Color3.fromHex("#1e88e5")
  end)(),
  Callback = function(color)
    accentColor = color:ToHex()
  end,
})
ThemeTab:Colorpicker({
  Title = "框",
  Default = (function()
    local success, result = pcall(function() return Color3.fromHex(outlineColor) end)
    return success and result or Color3.fromHex("#ffffff")
  end)(),
  Callback = function(color)
    outlineColor = color:ToHex()
  end,
})
ThemeTab:Colorpicker({
  Title = "文本",
  Default = (function()
    local success, result = pcall(function() return Color3.fromHex(textColor) end)
    return success and result or Color3.fromHex("#ffffff")
  end)(),
  Callback = function(color)
    textColor = color:ToHex()
  end,
})
ThemeTab:Colorpicker({
  Title = "输入框文本",
  Default = (function()
    local success, result = pcall(function() return Color3.fromHex(placeholderTextColor) end)
    return success and result or Color3.fromHex("#808080")
  end)(),
  Callback = function(color)
    placeholderTextColor = color:ToHex()
  end,
})
ThemeTab:Button({
  Title = "更新主题",
  Callback = function()
    
    updateTheme()
  end,
})
SettingsTab:Section({
  Title = "主题",
})
SettingsTab:Dropdown({
  Title = "选择主题",
  Multi = false,
  AllowNone = false,
  Value = nil,
  Values = themeList,
  Callback = function(selectedTheme)
    WindUI:SetTheme(selectedTheme)
  end,
}):Select(WindUI:GetCurrentTheme())
transparencyToggle = SettingsTab:Toggle({
  Title = "切换窗口透明度",
  Callback = function(enabled)
    Window:ToggleTransparency(enabled)
  end,
  Value = WindUI:GetTransparency(),
})
SettingsTab:Section({
  Title = "文件",
})
settingsFileName = ""
SettingsTab:Input({
  Title = "写入文件名",
  PlaceholderText = "输入文件名",
  Callback = function(input)
    settingsFileName = input
  end,
})
SettingsTab:Button({
  Title = "保存文件",
  Callback = function()
    if settingsFileName ~= "" then
      saveSettings(settingsFileName, {
        Transparent = WindUI:GetTransparency(),
        Theme = WindUI:GetCurrentTheme(),
      })
    end
  end,
})
SettingsTab:Section({
  Title = "文件",
})
fileDropdown = SettingsTab:Dropdown({
  Title = "选择文件",
  Multi = false,
  AllowNone = true,
  Values = listSettingsFiles(),
  Callback = function(selectedFile)
    settingsFileName = selectedFile
  end,
})
SettingsTab:Button({
  Title = "载入文件",
  Callback = function()
    if settingsFileName ~= "" then
      local loadedData = loadSettings(settingsFileName)
      if loadedData then
        WindUI:Notify({
          Title = "文件已加载",
          Content = "加载的数据: " .. HttpService:JSONEncode(loadedData),
          Duration = 5,
        })
        if loadedData.Transparent ~= nil then
          Window:ToggleTransparency(loadedData.Transparent)
          transparencyToggle:SetValue(loadedData.Transparent)
        end
        if loadedData.Theme then
          WindUI:SetTheme(loadedData.Theme)
        end
      else
        WindUI:Notify({
          Title = "错误",
          Content = "无法加载文件",
          Icon = "error",
          Duration = 5,
        })
      end
    end
  end,
})
SettingsTab:Button({
  Title = "覆盖文件",
  Callback = function()
    if settingsFileName ~= "" then
      saveSettings(settingsFileName, {
        Transparent = WindUI:GetTransparency(),
        Theme = WindUI:GetCurrentTheme(),
      })
    end
  end,
})
SettingsTab:Button({
  Title = "刷新列表",
  Callback = function()
    if fileDropdown then
      fileDropdown:Refresh(listSettingsFiles())
    end
  end,
})
GuideTab:Code({
  Title = "新版本",
  Code = [[
虚空树枝(主权祭坛钓)
地狱树枝(火山钓)
古老树枝(太阳岛钓)
月亮树枝(雪帽晚上或日食钓)
月亮线(开宝藏) ↓
魔法线(开宝藏)(概率钓出)
古代线(开宝藏) ↑
太阳碎片(日食古代岛最高处拿)
(需在日食天气↑)
深海碎片(瀑布最下面水里获得)
地球碎片(古代岛高处山洞获得)
古代碎片(古代岛瀑布钓)
月长石↓
天青石↓
红宝石(五颗全在陨石获得)
紫宝石↑
蛋白石↑
金色海洋珍珠(海湾钓clam获得)
漂浮木(海湾下笼子大概率获得)
神话漂浮木↓(使用垃圾饵)
(使用神话竿钓↑)
亚特兰蒂斯漂浮木↓(用垃圾饵)
(使用三叉戟竿钓↑)
月光漂浮木(通过鉴定或钓获得)
冰冻漂浮木↑
尖牙↓
(远古岛瀑布钓)
脊柱↑
---------------
圣诞节任务↓
先找圣诞老人接任务↓
钓20条圣诞鱼(地图限定)↓
(新增任务)
需在糖果工厂购买糖果竿↓
奖励↓
称号:圣诞老人的帮手
新船:雪橇
鱼飘:雪花玻璃球
初始代币Token
---------------
跟着糖果找到精灵
需要初始代币
任务二段↓
任务一↓
启动礼物机器
任务二↓
把礼物送给九位精灵
位置↓
moose
(圣诞签到活动旁)
Ancient
(正对瀑布左边)
Terrapin
(岛右方)
Snowcap
(商人npc附近)
Roslit
(跟糖果爬火山)
Forsaken
(码头甲板上)
Sunstone
(商人npc附近)
Statue
(入口梯子位置)
Mushgrove
(建船npc附近)
任务三↓
钓圣诞鱼45件(地图限定)
回去找精灵完成任务
奖励↓
称号:精灵帮手
新船:驯鹿巡航舰
鱼飘:圣诞精华
精英代币:Token
---------------
雪山版本1.11更新
天堂竿位置↓
(需前往四色宝石位置)
(四色宝石位置下去用滑翔机)
(需放置四色宝石打开大门)
保暖服位置↓
(三号补给点五号npc处)
(20176 783 5725)↑
稿子位置↓
(二号补给点内)
(19783 412 5391)↑
宝石获得位置
(所有宝石位置固定)
蓝色宝石
(20130 208 5447)↑
(需购买稿子挖出来) 
绿色宝石
(19877 448 5558)↑
(在二号补给点洞中npc获得)
黄色宝石
(19499 335 5556)↑
(在雪崩期间在地上捡起)
红色宝石
(19925 1137  5353)↑
(需做任务获得)↑
(红色宝石任务)↓
(需接任务后按按钮)
(按钮不可以先按)
(在山顶和12号npc说话)
任务1↓
(需获得其他三颗宝石)
任务2↓
(按下五处按钮)
位置↓
罗利斯特
(买降落伞那个木头上)
(-1717 148 733)↑
雪帽↓
(丢竿人左边的灯) 
(2926 281 2591)↑
海盗↓
(右岛其中一个瞭望塔上)
(-2556 181 1350)↑
初始岛↓
(牌子后方)
(402 136 267)↑
古岛↓
(石竿购买处)
(5504 143 -316)↑
(按下后返回雪山和12号沟通)
(聊天结束花25w购买)
雪山开关位置↓
开关1↓
(19880 424 5377)
开关2↓
(19593 543 5615)
开关3↓
(19436 690 5859)
开关4↓
(19848 476 4967)
开关5↓
(20199 854 5646)
开关6↓
(19963 586 5570)
雪山图腾位置↓
暴风雪图腾↓
(三号补给点保暖衣左边)
(20142 743 5805)
雪崩图腾↓
(合作竿继续爬到桥附近)
(19710 467 6053)
珊瑚礁版本更新1.13
位于正对海盗右边
周围会出现闪电特效
四个小岛可钓任意鱼
位置↓
-3575 151 524
(岛内大概率上雷暴词条)
水下封闭的大门
(里面空的)
位置↓
-3829 -102 524
(钓鱼可使用垃圾饵)
(大概率上传说以下鱼)]],
})
GuideTab:Code({
  Title = "红宝石",
  Code = [[
红宝石隐藏任务5个按钮的位置
接任务的npc(前提获得其他3个宝石)(对话完不用管)
19925,1127,5360
按钮1
402,137,267
按钮2
-1717,148,732
按钮3
2930,281,2592
按钮5
5505,143,-316
按钮4
-2565,181,1350]],
})
GuideTab:Code({
  Title = "攻略",
  Code = [[
蓝色宝石
(需购买稿子挖出来)
绿色宝石
(在二号补给点洞中npc获得)
黄色宝石
(在雪崩期间在地上捡起)
红色宝石
(需获得其他三颗宝石)
(然后按按钮)
罗利斯特
(买降落伞那个木头上)
雪山
(丢竿人左边的灯)
海盗
(右岛其中一个瞭望塔上)
初始岛
(牌子后方)
古岛
(石竿购买处)
(按下后反回花25w购买)]],
})
GuideTab:Code({
  Title = "雪山攻略",
  Code = [[
绿色氧气瓶
19523,132,5325
黄色氧气瓶和镐子
19781,415,5387
红色氧气瓶和Summit Rob
20210,739,5713
橙色氧气瓶和滑翔翼
19947,1142,5543
Winter Cloak(冬季斗篷/保温服)(位置不一样，东西一样)
199955,1142,5579或
20175,780,5724
拉杆1(用镐子砸开进去拉)
19841,424,5358
拉杆2
20193,854,5646
拉杆3
19599,543,5621
拉杆4
19433,690,5854
拉杆5
19857,476,4968
拉杆6(全部拉完Ice Warpers Rod会出现)
19968,586,5572
一个不知道有啥用的祭坛还有一根杆
19245,396,6045
一个水池(目前不知道有啥用)
19840,438,5612
蓝宝石(买镐子挖)
20130,208,5446]],
})
GuideTab:Code({
  Title = "攻略",
  Code = [[
虚空树枝(主权祭坛钓)
地狱树枝(火山钓)
古老树枝(太阳岛钓)
月亮树枝(雪帽晚上或日食钓)
月亮线(开宝藏) ↓
魔法线(开宝藏)(概率钓出)
古代线(开宝藏) ↑
太阳碎片(日食古代岛最高处拿)
(需在日食天气↑)
深海碎片(瀑布最下面水里获得)
地球碎片(古代岛高处山洞获得)
古代碎片(古代岛瀑布钓)
月长石↓
天青石↓
红宝石(五颗全在陨石获得)
紫宝石↑
蛋白石↑
金色海洋珍珠(海湾钓clam获得)
漂浮木(海湾下笼子大概率获得)
神话漂浮木↓(使用垃圾饵)
(使用神话竿钓↑)
亚特兰蒂斯漂浮木↓(用垃圾饵)
(使用三叉戟竿钓↑)
月光漂浮木(通过鉴定或钓获得)
冰冻漂浮木↑
尖牙↓
(远古岛瀑布钓)
脊柱↑
---------------
圣诞节任务↓
先找圣诞老人接任务↓
钓20条圣诞鱼(地图限定)↓
奖励↓
称号:圣诞老人的帮手
新船:雪橇
鱼飘:雪花玻璃球
初始代币Token
---------------
跟着糖果找到精灵
需要初始代币
任务二段↓
任务一↓
启动礼物机器
任务二↓
把礼物送给九位精灵
位置↓
moose
(圣诞签到活动旁)
Ancient
(正对瀑布左边)
Terrapin
(岛右方)
Snowcap
(商人npc附近)
Roslit
(跟糖果爬火山)
Forsaken
(码头甲板上)
Sunstone
(商人npc附近)
Statue
(入口梯子位置)
Mushgrove
(建船npc附近)
任务三↓
钓圣诞鱼45条(地图限定)
回去找精灵完成任务
奖励↓
称号:精灵帮手
新船:驯鹿巡航舰
鱼飘:圣诞精华
精英代币:Token
竿↓
Event Horizon rod
视界杆(黑洞竿))]],
})
GuideTab:Code({
  Title = "宝箱里的各个物品",
  Code = [[
金币 100-2000
稀有海藻x6
松露虫x6
优质鱼饵箱x3
鱼飘 金币 指南针 鲸鱼 红玛瑙魔方
Sunken 突变
刮刮乐
天气图腾 太阳 雨 风 北极光
沉没竿]],
})
GuideTab:Code({
  Title = "合成材料",
  Code = [[
精确杆(precison rod)
饵速20%
运气150%
控制0%
恢复力5%
最大公斤12000kg
技能介绍
与快速杆相对应但具有更好的弹性(counterpart to rapid rod with much better resiliench)
材料
紫宝石(Amethyst)*1
神话漂浮木(Mythical Driftwood)*2
魔法线(Magic Thread)*1
---------------
智慧棒(Wisdom  Rod)
饵速0%
运气20%
控制0.05%
恢复力0%
最大公斤800kg
技能介绍
一根神秘的棍子 奖励连续5次钓鱼成功接住后给予70-100%的经验值奖励(A mystical rod that rewards consecutive catches granting a 70-100% XP bonus after 5 successful catches in a row)
材料
紫宝石(Amethyst)*1
神话漂浮木(Mythical Driftwood)*2
魔法线(Magic Thread)*1
---------------
资源丰富棒(Resourceful Rod)
两种名字不清楚(足智多谋棒)
饵速15%
运气20%
控制-0.01%
恢复力0%
最大公斤1000kg%
技能介绍
加倍所有诱饵的效果 增强你的钓鱼经验 提高每次捕鱼的效率(Doubles the effects of all bait enhancing your fishing experience and increasing the effciency of every catch)
材料
紫宝石(Amethyst)*1
月光漂浮木(Lunar Driftwood)*2
魔法线(Magic Thread)*1
]],
})
GuideTab:Code({
  Title = "鱼竿介绍",
  Code = [[
天界杆 价格100000 远古岛锻造台 被动:捕获85条鱼后召唤"神力"提升50%运气和30%引诱速度并带有天界突变鱼（x2倍值）

永恒之王杆 价格250000 同上 被动:每隔30秒有10%概率召唤"皇家护卫"在30秒内提升150%运气且当错失1条鱼时15%概率立即捕获高一等阶的鱼 20%概率捕捉贪婪突变鱼（x4倍值）

被遗忘的尖牙之杆 价格300000 同上 被动:三次完美捕鱼后召唤一只巨齿鲨带有一只随机复制本次钓的鱼从背包内并提供15%-20%尺寸

鹿角杆 价格0 圣诞签到获得 被动:25%概率捕获快乐突变鱼（x1.2倍值）（绝版）

北极星杆 价格0 同上 （绝版）

拐杖糖杆 价格1500 圣诞冰雪镇购买 被动:10%概率捕获节庆突变鱼（x1.4倍值）（绝版）

冰霜杆 价格0 799robux圣诞礼包（绝版）

遗迹杆 价格8000 收集十种化石获取图纸去远古岛解密获得（绝版）

石杆 价格3000 在远古岛旁边小岛

凤凰杆 价格40000 在远古岛洞穴里 被动:40%概率捕获烧焦突变鱼（x1.3倍值）

精密杆 价格7500 远古岛锻造台 被动:更高的控制力

智慧杆 价格50000 同上 被动:五次成功捕捉后的下一条鱼增加70%-100%经验值

机智杆 价格15000 同上 被动:所有诱饵效果加倍（负面效果不变）

季节竿 价格35000 同上 被动:捕获当前季节鱼运气增加20% 还可能捕获春季突变鱼（x3倍值）夏季突变鱼+25%体型 冬季突变鱼（x2.5倍值）

激流杆 价格40000 同上 被动:完美捕鱼计入20%潮汐进度条 达到最大值时接下来三次捕鱼增加30%稀有概率和25%引诱速度

航海竿 价格40000 同上 被动:召唤一个激光使捕获鱼速度加快并25%概率捕获石化突变鱼（x2.5倍值）

迷失杆 价格30000 同上  被动:六次完美捕鱼后的三次捕鱼增加150%运气（换其他鱼竿效果失效）

极光杆 价格90000 极光天气下的漩涡处购买 被动:15%概率捕获奥罗拉突变鱼（x6.5倍值）极光期间25%

神话杆 价格110000 流浪商人处购买 被动:30%概率捕获神话突变鱼（x4.5倍值）

海王杆 价格120000 主权雕像下面出电梯后左处河边购买 被动:捕获的鱼大15%

命运杆 价格190000 图鉴70%时去拱门岛上的npc对话购买 被动:5%概率捕获闪亮的/闪闪发光的鱼

三叉戟 价格150000 深渊图鉴100%时在荒凉深渊隐藏入口里用5个附魔石开门购买 被动:有概率在捕获鱼过程中打晕鱼并增加进度条 被动2:30%概率捕获亚特兰蒂斯突变鱼（x3倍值）

沉沦杆 价格0 钓鱼中1/160获得藏宝图在遗忘海岸找海盗修复藏宝图在宝箱内概率获得 被动:每捕获10个鱼有25%概率获得藏宝图

深度杆 价格750000 深度中用Hexed和Abyssal附魔石开门后过迷宫购买 被动:召唤一个幻影每当玩家捕获3条鱼获得当前海域的1条鱼

无生命杆 价格0 500级获得 被动:有概率在捕获鱼过程中打晕鱼并增加进度条 被动2:增加捕获魔法突变鱼（x1.5倍）

---各个杆附魔推荐---
季节杆
1.hasty（增加55%上钩速度）
2.Abyssal（10%概率深海附魔 20%概率鱼变小80%概率鱼变大）


永恒之王杆
1..Quality（增加15%运气 5%控制力 15%引诱速度）
1.Hasty（增加55%引诱速度）


被遗忘的尖牙之杆
1.Abyssal（10%概率深海附魔 20%概率鱼变小80%概率鱼变大）
2.Clever （x2倍经验值）

无生命杆
1.Abyssal（10%概率深海附魔 20%概率鱼变小80%概率鱼变大）
2.Quality（增加15%运气 5%控制力 15%引诱速度）

深渊杆
1.Abyssal（10%概率深海附魔 20%概率鱼变小80%概率鱼变大）
2.Hasty（增加55%引诱速度）

三叉戟
1.Hasty（增加55%引诱速度）
2.Steady（减少25%进度丢失）

极光杆
1.Hasty（增加55%引诱速度）
2.Resilient（增加35%控制力）

神话杆
1.Resilient（增加35%控制力）
2.Hasty（增加55%引诱速度）

命运杆
1.Resilient（增加35%控制力）
2.Steady（减少25%进度丢失）

海王杆
1.Hasty（增加55%引诱速度）
2.Sea king（增加10%鱼体型）

智慧杆
1.Hasty（增加55%引诱速度）
2.Clever（x2倍经验值）]],
})
GuideTab:Code({
  Title = "各个附魔效果",
  Code = [[
Sea King +10%鱼体型
Swift +30%上钩速度
Hasty +55%上钩速度
Long +50鱼竿长度
Ghastly 20%概率钓上半透明突变鱼
Lucky +20%运气
Divine +45%运气
Mutated +7%捕获突变鱼概率
Unbreakable +10000鱼竿承重
Steady -25%失去进度速度
Blessed +2%闪亮的/闪闪发光的鱼概率
Wormhole 45%概率钓上随机海域的鱼
Resilient +35%恢复力
Controlled +0.05控制
Storming +95%雨天运气
Breezed +65%风天运气
Insight 捕获的鱼经验x1.5倍
Clever 捕获的鱼经验x2.25倍
Scrapper 60%概率不消耗诱饵
Noir 10%概率捕获白化或黑暗突变鱼
Quality +15%上钩速度 +15%运气 +5%恢复力
Abyssal 10%概率捕获深海突变鱼（x3.5倍值）80%概率增加30%鱼体型 20%概率减少40%鱼体型]],
})
local chatMessageInput = ChatTab:Input({
  Title = "输入你的文字",
  Desc = "请输入你想要说的话",
  Value = "输入",
  PlaceholderText = "你在看什么嘛",
  Callback = function(input)
    chatMessage = input
  end,
})
local sendCountInput = ChatTab:Input({
  Title = "输入次数",
  Desc = "次数",
  Value = "输入",
  PlaceholderText = "输入发送次数",
  Callback = function(input)
    local count = tonumber(input)
    if count and count > 0 then
      sendCount = count
    else
      warn("请输入有效的数字")
    end
  end,
})
ChatTab:Button({
  Title = "发送",
  Callback = function()
    sendChatMessage(chatMessage)
  end,
})
ChatTab:Button({
  Title = "停止自动发送",
  Callback = function()
    isAutoSendingEnabled = false
    print("已停止自动发送")
  end,
})
ChatTab:Toggle({
  Title = "自动发送",
  Callback = function(enabled)
    isAutoSendingEnabled = enabled
    if enabled then
      print("自动发送已启用")
      task.spawn(function()
        for i = 1, sendCount do
          if isAutoSendingEnabled then
            sendChatMessage(chatMessage)
            task.wait(sendInterval)
          else
            break
          end
        end
        isAutoSendingEnabled = false
      end)
    else
      print("自动发送已禁用")
    end
  end,
})
BuyTab:Button({Title = "力量", Callback = function() buyFromMerlin("power") end})
BuyTab:Button({Title = "幸运", Callback = function() buyFromMerlin("luck") end})
BuyTab:Dropdown({
  Title = "选择物品",
  Multi = false,
  AllowNone = false,
  Value = buySelectedItem,
  Values = buyItemList,
  Callback = function(s) buySelectedItem = s end,
})
BuyTab:Input({
  Title = "输入购买数量",
  Desc = "输入数量",
  Value = "1",
  PlaceholderText = "输入购买数量",
  Callback = function(input)
    local q = tonumber(input)
    if q and q > 0 then buyItemQuantity = q else
      WindUI:Notify({Title = "错误", Content = "请输入有效的正整数！", Icon = "error", Duration = 3})
    end
  end,
})
BuyTab:Button({
  Title = "购买物品",
  Callback = function()
    if buySelectedItem == "None" then
      WindUI:Notify({Title = "错误", Content = "请先选择物品！", Icon = "error", Duration = 3})
      return 
    end
    if buyPurchaseEvent then
      for i = 1, buyItemQuantity do buyPurchaseEvent:FireServer(buySelectedItem, "Item", nil, 1) end
      WindUI:Notify({Title = "成功", Content = "已购买 " .. buyItemQuantity .. " 个 " .. buySelectedItem .. "！", Icon = "check", Duration = 3})
    else
      WindUI:Notify({Title = "错误", Content = "未找到购买事件！", Icon = "error", Duration = 3})
    end
  end,
})
BuyTab:Section({Title = "杆子", TextXAlignment = "Left"})
BuyTab:Dropdown({
  Title = "选择杆子",
  Multi = false,
  AllowNone = false,
  Value = buySelectedRod,
  Values = buyRodList,
  Callback = function(s) buySelectedRod = s end,
})
BuyTab:Button({
  Title = "购买杆子",
  Callback = function()
    if buySelectedRod == "None" then
      WindUI:Notify({Title = "错误", Content = "请先选择杆子！", Icon = "error", Duration = 3})
      return 
    end
    if buyPurchaseEvent then
      buyPurchaseEvent:FireServer(buySelectedRod, "Rod", nil, 1)
      WindUI:Notify({Title = "成功", Content = "已购买 1 根 " .. buySelectedRod .. "！", Icon = "check", Duration = 3})
    else
      WindUI:Notify({Title = "错误", Content = "未找到购买事件！", Icon = "error", Duration = 3})
    end
  end,
})
local function cleanupConnections()
  if dataTable then
    for _, connection in ipairs(dataTable) do
      if connection and typeof(connection) == "RBXScriptConnection" then
        connection:Disconnect()
      end
    end
    dataTable = {}
  end
end
Players.PlayerRemoving:Connect(function(player)
  if player == LocalPlayer then
    cleanupConnections()
  end
end)
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})

local MyButton = LeftGroupBox:AddButton({
    Text = '极速传奇',---服务器名称
    Func = function()
    local originalUI = Library
        
wait(3)
local redzlib = loadstring(game:HttpGet("https://raw.github.com/f20i30s40h/Library/main/Redz"))()
local Window = redzlib:New("YG SCRIPT", "极速传奇", false)

local Tab1 = Window:Tab("主要功能", "cool")

Tab1:Textbox("速度", function(Value)

game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
end)

Tab1:Toggle("自动重生",false,function(state)
while state == true do wait()
game:GetService("ReplicatedStorage").rEvents.
rebirthEvent:FireServer("rebirthRequest")
   end
end)

Tab1:Toggle("自动刷经验", false, function(state)
           if state then
           _G.loop = true
           while _G.loop == true do wait()
                 game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") game:GetService('ReplicatedStorage').rEvents.orbEvent:FireServer("collectOrb", "Yellow Orb", "City") 
           end
        else
           _G.loop = false
        end
end)



Tab1:Toggle("自动卡宠", false, function(state)
    if state then
        spawn(function() 
            while wait() do 
                game:GetService("ReplicatedStorage").rEvents.rebirthEvent:FireServer("rebirthRequest") 
            end 
        end) 
        
        while wait(0.1) do 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
            local A_1 = "collectOrb" 
            local A_2 = "Yellow Orb" 
            local A_3 = "City" 
            local Event = game:GetService("ReplicatedStorage").rEvents.orbEvent 
            Event:FireServer(A_1, A_2, A_3) 
        end
    end
end)

local JS = Window:Tab("传送","ZX")

JS:Button("城市", function()
	game.Players.LocalPlayer.Character:MoveTo(Vector3.new(-559.2, -7.45058e-08, 417.4))  
end)

JS:Button("白雪城", function()
game.Players.LocalPlayer.Character:MoveTo(Vector3.new(-858.358, 0.5, 2170.35))
end)

JS:Button("熔岩城", function()
game.Players.LocalPlayer.Character:MoveTo(Vector3.new(1707.25, 0.550008, 4331.05))     
end)

JS:Button("传奇公路", function()
  game.Players.LocalPlayer.Character:MoveTo(Vector3.new(3594.68, 214.804, 7274.56))  
end)

JS:Button("欧米茄水晶", function()
game.Players.LocalPlayer.Character:MoveTo(Vector3.new(4530.78, 75.31, 6405.20))
end)

JS:Button("沙漠赛跑(城市)",function()
    game.Players.LocalPlayer.Character:MoveTo(Vector3.new(58.8, 1.007, -8684.72))
end)

JS:Button("岩浆种族(城市)",function()
    game.Players.LocalPlayer.Character:MoveTo(Vector3.new(1013.4, 1.007, -10997))
end)

JS:Button("草原赛跑(城市)",function()
    game.Players.LocalPlayer.Character:MoveTo(Vector3.new(1687.65, 1.007, -5943.91))
end)

destroyUI()
         
       
    end
})
    
rz:Button({
    Title = "忍者传奇",---服务器名称
    Icon = "play",
    Color = "Red",
    Callback = function()
    
-- 忍者传奇脚本 - 功能修复版
local redzlib = loadstring(game:HttpGet("https://pastefy.app/5PiSO8oW/raw"))()

local Window = redzlib:MakeWindow({
    Title = "YG SCRIPT - 忍者传奇",
    SubTitle = "by YG - 修复版",
    SaveFolder = "NinjaLegendsYG"
})

-- 所有选项卡
local FarmingTab = Window:MakeTab({"自动刷取", "zap"})
local AutoBuyTab = Window:MakeTab({"自动购买", "shopping-cart"})
local PetsTab = Window:MakeTab({"宠物管理", "paw"})
local PetShopTab = Window:MakeTab({"元素", "fire"})
local TeleportsTab = Window:MakeTab({"传送", "map"})
local MiscTab = Window:MakeTab({"杂项", "tool"})
local MoneyTab = Window:MakeTab({"刷金币", "dollar-sign"})

-- 全局变量初始化
local player = game.Players.LocalPlayer
local isRunning = true

-- 初始化所有开关变量
local Toggles = {
    AutoSwing = false,
    AutoSell = false,
    AutoFullSell = false,
    AutoCollect = false,
    AutoRobotBoss = false,
    AutoEternalBoss = false,
    AutoAncientBoss = false,
    AutoSantaBoss = false,
    AutoAllBosses = false,
    AutoRank = false,
    AutoSword = false,
    AutoBelt = false,
    AutoSkill = false,
    AutoShuriken = false,
    AutoOpenEgg = false,
    AutoEvolve = false,
    AutoBuyTwinBirdies = false,
    FastShuriken = false,
    SlowShuriken = false,
    Invisible = false,
    AntiAFK = true,
    AutoFarmMoney = false
}

-- 存储设置
local Settings = {
    SelectedCrystal = "Crystal",
    SelectedIsland = "Spawn",
    GemValue = 100000,
    CurrentIslandIndex = 1
}

-- ============ 自动刷取选项卡 ============
FarmingTab:AddSection({"基础功能"})

FarmingTab:AddToggle({
    Name = "自动挥刀",
    Description = "自动攻击敌人",
    Default = false,
    Callback = function(Value)
        Toggles.AutoSwing = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoSwing and isRunning do
                    pcall(function()
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            -- 查找正确的攻击事件
                            local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                            local swingEvent = rEvents:FindFirstChild("swingKatanaEvent")
                            
                            if swingEvent then
                                swingEvent:FireServer()
                            elseif player:FindFirstChild("ninjaEvent") then
                                player.ninjaEvent:FireServer("swingKatana")
                            end
                        end
                    end)
                    task.wait(0.1)
                end
            end)
        end
    end
})

FarmingTab:AddToggle({
    Name = "自动出售",
    Description = "自动出售物品",
    Default = false,
    Callback = function(Value)
        Toggles.AutoSell = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoSell and isRunning do
                    pcall(function()
                        if player.Character then
                            -- 寻找出售区域
                            local sellArea = game.Workspace:FindFirstChild("sellAreaCircles")
                            if not sellArea then
                                sellArea = game.Workspace:FindFirstChild("sellAreas")
                            end
                            
                            if sellArea then
                                -- 尝试找到出售区域
                                local area = sellArea:FindFirstChild("sellAreaCircle7")
                                if not area then
                                    area = sellArea:FindFirstChild("sellAreaCircle6")
                                end
                                if not area then
                                    area = sellArea:FindFirstChild("sellAreaCircle5")
                                end
                                
                                if area then
                                    local inner = area:FindFirstChild("circleInner") or area
                                    if inner then
                                        player.Character.HumanoidRootPart.CFrame = inner.CFrame
                                    end
                                end
                            end
                        end
                    end)
                    task.wait(0.2)
                end
            end)
        end
    end
})

FarmingTab:AddToggle({
    Name = "自动收集",
    Description = "自动收集气、金币和宝石",
    Default = false,
    Callback = function(Value)
        Toggles.AutoCollect = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoCollect and isRunning do
                    pcall(function()
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            -- 收集金币和宝石
                            local spawnedCoins = game.Workspace:FindFirstChild("spawnedCoins")
                            if spawnedCoins then
                                for _, islandCoins in pairs(spawnedCoins:GetChildren()) do
                                    if islandCoins:IsA("Folder") then
                                        for _, coin in pairs(islandCoins:GetChildren()) do
                                            if coin:IsA("Model") then
                                                local primaryPart = coin.PrimaryPart
                                                if primaryPart then
                                                    player.Character.HumanoidRootPart.CFrame = primaryPart.CFrame
                                                    task.wait(0.05)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            
                            -- 收集气（蓝瓶）
                            local hoops = game.Workspace:FindFirstChild("Hoops")
                            if hoops then
                                for _, hoop in pairs(hoops:GetChildren()) do
                                    if hoop:IsA("Model") and hoop.Name:find("Chi") then
                                        local primaryPart = hoop.PrimaryPart
                                        if primaryPart then
                                            player.Character.HumanoidRootPart.CFrame = primaryPart.CFrame
                                            task.wait(0.05)
                                        end
                                    end
                                end
                            end
                        end
                    end)
                    task.wait(0.1)
                end
            end)
        end
    end
})

FarmingTab:AddSection({"Boss击杀"})

local Bosses = {
    {Name = "机器人Boss", Value = "AutoRobotBoss", BossName = "RobotBoss"},
    {Name = "不朽Boss", Value = "AutoEternalBoss", BossName = "EternalBoss"},
    {Name = "古代Boss", Value = "AutoAncientBoss", BossName = "AncientMagmaBoss"}, -- 修复：正确的Boss名称
    {Name = "圣诞老人Boss", Value = "AutoSantaBoss", BossName = "Samurai Santa"}, -- 修复：正确的Boss名称
}

for _, boss in ipairs(Bosses) do
    FarmingTab:AddToggle({
        Name = "自动杀" .. boss.Name,
        Default = false,
        Callback = function(Value)
            Toggles[boss.Value] = Value
        end
    })
end

FarmingTab:AddToggle({
    Name = "自动杀全部Boss",
    Description = "循环击杀所有可用的Boss",
    Default = false,
    Callback = function(Value)
        Toggles.AutoAllBosses = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoAllBosses and isRunning do
                    pcall(function()
                        local bossFolder = game.Workspace:FindFirstChild("bossFolder")
                        if bossFolder and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            -- 正确的Boss顺序
                            local bossNames = {"Samurai Santa", "AncientMagmaBoss", "EternalBoss", "RobotBoss"}
                            
                            for _, bossName in ipairs(bossNames) do
                                local boss = bossFolder:FindFirstChild(bossName)
                                if boss and boss:FindFirstChild("HumanoidRootPart") then
                                    player.Character.HumanoidRootPart.CFrame = boss.HumanoidRootPart.CFrame
                                    
                                    -- 攻击Boss
                                    local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                                    local swingEvent = rEvents:FindFirstChild("swingKatanaEvent")
                                    if swingEvent then
                                        swingEvent:FireServer()
                                    end
                                    
                                    task.wait(1)
                                end
                            end
                        end
                    end)
                    task.wait(3)
                end
            end)
        end
    end
})

-- ============ 自动购买选项卡 ============
AutoBuyTab:AddSection({"自动购买"})

local BuyOptions = {
    {Name = "自动买等级", Value = "AutoRank", Event = "buyRank"},
    {Name = "自动买剑", Value = "AutoSword", Event = "buyAllSwords"},
    {Name = "自动买腰带", Value = "AutoBelt", Event = "buyAllBelts"},
    {Name = "自动买技能", Value = "AutoSkill", Event = "buyAllSkills"},
    {Name = "自动买飞镖", Value = "AutoShuriken", Event = "buyAllShurikens"},
}

for _, option in ipairs(BuyOptions) do
    AutoBuyTab:AddToggle({
        Name = option.Name,
        Description = "自动购买" .. option.Name:sub(5),
        Default = false,
        Callback = function(Value)
            Toggles[option.Value] = Value
            if Value then
                task.spawn(function()
                    while Toggles[option.Value] and isRunning do
                        pcall(function()
                            local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                            
                            if option.Event == "buyRank" then
                                -- 购买等级的特殊处理
                                local buyRankEvent = rEvents:FindFirstChild("buyRankEvent")
                                if buyRankEvent then
                                    local islands = {"Ground", "Astral", "Space", "Tundra", "Eternal", "Sandstorm", "Thunderstorm", "Ancient"}
                                    for _, island in ipairs(islands) do
                                        buyRankEvent:FireServer(island)
                                        task.wait(0.1)
                                    end
                                end
                            else
                                -- 其他购买事件
                                local eventName = option.Event .. "Event"
                                local event = rEvents:FindFirstChild(eventName)
                                if event then
                                    event:FireServer()
                                end
                            end
                        end)
                        task.wait(0.5)
                    end
                end)
            end
        end
    })
end

-- ============ 宠物管理选项卡 ============
PetsTab:AddSection({"宠物蛋"})

-- 获取水晶列表（修复：使用游戏中的实际水晶名称）
local crystalOptions = {}
local mapCrystalsFolder = game.Workspace:FindFirstChild("mapCrystalsFolder")
if mapCrystalsFolder then
    for _, crystal in pairs(mapCrystalsFolder:GetChildren()) do
        if crystal:IsA("Model") then
            table.insert(crystalOptions, crystal.Name)
        end
    end
end

if #crystalOptions == 0 then
    crystalOptions = {"Basic", "Legendary", "Mythical", "Eternal", "Golden"}
end

PetsTab:AddDropdown({
    Name = "选择水晶",
    Description = "选择要开启的水晶类型",
    Options = crystalOptions,
    Default = crystalOptions[1],
    Callback = function(Value)
        Settings.SelectedCrystal = Value
    end
})

PetsTab:AddToggle({
    Name = "自动开蛋",
    Description = "自动开启选中的水晶蛋",
    Default = false,
    Callback = function(Value)
        Toggles.AutoOpenEgg = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoOpenEgg and isRunning do
                    pcall(function()
                        local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                        local openCrystalRemote = rEvents:FindFirstChild("openCrystalRemote")
                        
                        if openCrystalRemote then
                            openCrystalRemote:InvokeServer("openCrystal", Settings.SelectedCrystal)
                        end
                    end)
                    task.wait(1)
                end
            end)
        end
    end
})

PetsTab:AddToggle({
    Name = "自动进化",
    Description = "自动进化所有宠物",
    Default = false,
    Callback = function(Value)
        Toggles.AutoEvolve = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoEvolve and isRunning do
                    pcall(function()
                        local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                        local petEvolveEvent = rEvents:FindFirstChild("petEvolveEvent")
                        
                        if petEvolveEvent and player:FindFirstChild("petsFolder") then
                            for _, petType in pairs(player.petsFolder:GetChildren()) do
                                for _, pet in pairs(petType:GetChildren()) do
                                    petEvolveEvent:FireServer("evolvePet", pet.Name)
                                    task.wait(0.2)
                                end
                            end
                        end
                    end)
                    task.wait(5)
                end
            end)
        end
    end
})

PetsTab:AddToggle({
    Name = "自动孵化双元素鸟",
    Description = "自动孵化双元素小鸟",
    Default = false,
    Callback = function(Value)
        Toggles.AutoBuyTwinBirdies = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoBuyTwinBirdies and isRunning do
                    pcall(function()
                        local repStorage = game:GetService("ReplicatedStorage")
                        local cPetShopRemote = repStorage:FindFirstChild("cPetShopRemote")
                        local cPetShopFolder = repStorage:FindFirstChild("cPetShopFolder")
                        
                        if cPetShopRemote and cPetShopFolder then
                            local twinBirdies = cPetShopFolder:FindFirstChild("Twin Element Birdies")
                            if twinBirdies then
                                cPetShopRemote:InvokeServer(twinBirdies)
                            end
                        end
                    end)
                    task.wait(5)
                end
            end)
        end
    end
})

-- ============ 元素选项卡 ============
PetShopTab:AddSection({"元素解锁"})

local Elements = {
    "Inferno",
    "Frost", 
    "Lightning",
    "Shadow",
    "Chaos",
    "Masterful",
    "Eternity",
    "Blazing"
}

for _, element in ipairs(Elements) do
    PetShopTab:AddButton({
        Name = "解锁 " .. element .. " 元素",
        Callback = function()
            pcall(function()
                local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                local elementMasteryEvent = rEvents:FindFirstChild("elementMasteryEvent")
                
                if elementMasteryEvent then
                    elementMasteryEvent:FireServer("buyMastery", element)
                end
            end)
        end
    })
end

-- ============ 传送选项卡 ============
TeleportsTab:AddSection({"岛屿传送"})

-- 获取岛屿列表（修复：使用游戏中的实际岛屿名称）
local islandOptions = {}
local islandUnlockParts = game.Workspace:FindFirstChild("islandUnlockParts")
if islandUnlockParts then
    for _, island in pairs(islandUnlockParts:GetChildren()) do
        if island:IsA("Model") then
            table.insert(islandOptions, island.Name)
        end
    end
end

if #islandOptions == 0 then
    islandOptions = {"Ground", "Astral Island", "Space Island", "Tundra Island", 
                     "Eternal Island", "Sandstorm", "Thunderstorm", "Ancient Inferno Island"}
end

TeleportsTab:AddDropdown({
    Name = "选择岛屿",
    Description = "传送到指定岛屿",
    Options = islandOptions,
    Default = islandOptions[1],
    Callback = function(Value)
        Settings.SelectedIsland = Value
    end
})

TeleportsTab:AddButton({
    Name = "传送到选中的岛屿",
    Callback = function()
        pcall(function()
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local islandUnlockParts = game.Workspace:FindFirstChild("islandUnlockParts")
                if islandUnlockParts then
                    local island = islandUnlockParts:FindFirstChild(Settings.SelectedIsland)
                    if island then
                        local sign = island:FindFirstChild("islandSignPart")
                        if sign then
                            player.Character.HumanoidRootPart.CFrame = sign.CFrame
                            return
                        end
                    end
                end
                
                -- 备用位置
                local backupPositions = {
                    ["Ground"] = CFrame.new(0, 10, 0),
                    ["Astral Island"] = CFrame.new(500, 50, 0),
                    ["Space Island"] = CFrame.new(1000, 100, 0),
                    ["Tundra Island"] = CFrame.new(0, 50, 500),
                    ["Eternal Island"] = CFrame.new(0, 75, 1000),
                    ["Sandstorm"] = CFrame.new(-500, 60, 0),
                    ["Thunderstorm"] = CFrame.new(-1000, 80, 0),
                    ["Ancient Inferno Island"] = CFrame.new(0, 90, -500)
                }
                
                local position = backupPositions[Settings.SelectedIsland]
                if position then
                    player.Character.HumanoidRootPart.CFrame = position
                end
            end
        end)
    end
})

-- ============ 杂项选项卡 ============
MiscTab:AddSection({"游戏功能"})

MiscTab:AddToggle({
    Name = "快速手里剑",
    Description = "增加手里剑飞行速度",
    Default = false,
    Callback = function(Value)
        Toggles.FastShuriken = Value
        if Value then
            task.spawn(function()
                while Toggles.FastShuriken and isRunning do
                    pcall(function()
                        local shurikensFolder = game.Workspace:FindFirstChild("shurikensFolder")
                        if shurikensFolder then
                            for _, shuriken in pairs(shurikensFolder:GetChildren()) do
                                if shuriken.Name == "Handle" then
                                    local bodyVelocity = shuriken:FindFirstChildOfClass("BodyVelocity")
                                    if bodyVelocity then
                                        bodyVelocity.Velocity = bodyVelocity.Velocity * 2
                                    end
                                end
                            end
                        end
                    end)
                    task.wait(0.1)
                end
            end)
        end
    end
})

MiscTab:AddToggle({
    Name = "隐身模式",
    Description = "进入隐身状态",
    Default = false,
    Callback = function(Value)
        Toggles.Invisible = Value
        if Value then
            task.spawn(function()
                while Toggles.Invisible and isRunning do
                    pcall(function()
                        local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                        local invisibilityEvent = rEvents:FindFirstChild("invisibilityEvent")
                        
                        if invisibilityEvent then
                            invisibilityEvent:FireServer("activate")
                        end
                    end)
                    task.wait(10)
                end
            end)
        end
    end
})

MiscTab:AddToggle({
    Name = "防AFK",
    Description = "防止因挂机被踢出",
    Default = true,
    Callback = function(Value)
        Toggles.AntiAFK = Value
    end
})

MiscTab:AddButton({
    Name = "收集所有宝箱",
    Callback = function()
        pcall(function()
            if player.Character then
                local chestTypes = {
                    "mythicalChest", "goldenChest", "enchantedChest", "magmaChest",
                    "legendsChest", "eternalChest", "saharaChest", "thunderChest",
                    "ancientChest", "midnightShadowChest"
                }
                
                for _, chestName in ipairs(chestTypes) do
                    local chest = game.Workspace:FindFirstChild(chestName)
                    if chest then
                        local circleInner = chest:FindFirstChild("circleInner")
                        if circleInner then
                            player.Character.HumanoidRootPart.CFrame = circleInner.CFrame
                            task.wait(2.5)
                        end
                    end
                end
            end
        end)
    end
})

-- ============ 刷金币选项卡 ============
MoneyTab:AddParagraph({"使用说明", "第一步：点击初始化\n第二步：设置金币数值\n第三步：开启自动刷取"})
MoneyTab:AddParagraph({"警告", "使用此功能可能导致账号异常，请谨慎使用！"})

MoneyTab:AddButton({
    Name = "金币系统初始化",
    Callback = function()
        pcall(function()
            local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
            local zenMasterEvent = rEvents:FindFirstChild("zenMasterEvent")
            
            if zenMasterEvent then
                zenMasterEvent:FireServer("convertGems", -999999999)
            end
        end)
    end
})

MoneyTab:AddTextBox({
    Name = "设置金币数值",
    Default = "100000",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            Settings.GemValue = num
        end
    end
})

MoneyTab:AddToggle({
    Name = "自动刷金币",
    Description = "自动转换宝石为金币",
    Default = false,
    Callback = function(Value)
        Toggles.AutoFarmMoney = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoFarmMoney and isRunning do
                    pcall(function()
                        local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                        local zenMasterEvent = rEvents:FindFirstChild("zenMasterEvent")
                        
                        if zenMasterEvent then
                            zenMasterEvent:FireServer("convertGems", Settings.GemValue)
                        end
                    end)
                    task.wait(0.5)
                end
            end)
        end
    end
})

-- ============ 防AFK系统 ============
task.spawn(function()
    while isRunning do
        if Toggles.AntiAFK then
            pcall(function()
                local vu = game:GetService("VirtualUser")
                vu:CaptureController()
                vu:ClickButton2(Vector2.new())
            end)
        end
        task.wait(60)
    end
end)

-- ============ Boss自动击杀系统 ============
for _, boss in ipairs(Bosses) do
    task.spawn(function()
        while isRunning do
            if Toggles[boss.Value] then
                pcall(function()
                    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local bossFolder = game.Workspace:FindFirstChild("bossFolder")
                        if bossFolder then
                            local bossObj = bossFolder:FindFirstChild(boss.BossName)
                            if bossObj and bossObj:FindFirstChild("HumanoidRootPart") then
                                player.Character.HumanoidRootPart.CFrame = bossObj.HumanoidRootPart.CFrame
                                
                                -- 攻击Boss
                                local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                                local swingEvent = rEvents:FindFirstChild("swingKatanaEvent")
                                if swingEvent then
                                    swingEvent:FireServer()
                                end
                                
                                task.wait(0.5)
                            end
                        end
                    end
                end)
            end
            task.wait(0.1)
        end
    end)
end

-- 游戏关闭时清理
game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        isRunning = false
    end
end)

print("========== YG脚本已加载完成 ==========")
print("脚本版本: 修复版")
print("作者: YG")
print("祝您游戏愉快！")

destroyUI()
         
       
    end
})


ty:Button({
    Title = "通用自瞄",---服务器名称
    Icon = "play",
    Color = "Red",
    Callback = function()
    
    
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Pixeluted/adoniscries/main/Source.lua", true))()

if not game:IsLoaded() then
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

local SilentAimSettings = {
    Enabled = false,
    ClassName = "Universal Silent Aim",
    ToggleKey = "RightAlt",
    TeamCheck = false,
    VisibleCheck = false,
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    FOVVisible = true,
    ShowSilentAimTarget = false,
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100,
    HeadshotChanceEnabled = false,
    HeadshotChance = 0,
    FixedFOV = true,
    TargetIndicatorRadius = 20,
    CrosshairLength = 30,
    CrosshairGap = 5,
    IndicatorRotationEnabled = false,
    IndicatorRotationSpeed = 1,
    IndicatorRainbowEnabled = false,
    IndicatorRainbowSpeed = 1,
    MaxDistance = 500,
    PriorityMode = "准星最近",
    TargetInfoStyle = "面板",
    ShowTargetName = true,
    ShowTargetHealth = true,
    ShowTargetDistance = true,
    ShowTargetCategory = false,
    ShowDamageNotifier = false,
    HighlightEnabled = false,
    HighlightRainbowEnabled = false,
    HighlightColor = Color3.fromRGB(255, 255, 0),
    IndependentPanelPosition = "200,200",
    IndependentPanelPinned = false,
    LeakAndHitMode = false,
    Wallbang = false,
    EnableNameTargeting = false,
    WhitelistedNames = {},
    BlacklistedNames = {},
    ShowTracer = false,
    Tracer_Y_Offset = 0,
    WhitelistPath = {},
    IndicatorBreathingEnabled = true,
    IndicatorBreathingSpeed = 1,
    IndicatorBreathingMin = 0.8,
    IndicatorBreathingMax = 1.2,
    ThreeLineCrosshairEnabled = true,
    ThreeLineCrosshairLength = 30,
    ThreeLineCrosshairGap = 5
}

getgenv().SilentAimSettings = SilentAimSettings
local MainFileName = "UniversalSilentAim"

local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local Debris = game:GetService("Debris")
local CoreGui = game:GetService("CoreGui")
local PathfindingService = game:GetService("PathfindingService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetPlayers = Players.GetPlayers
local WorldToViewportPoint = Camera.WorldToViewportPoint
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume
local create = coroutine.create

local ValidTargetParts = {"Head", "HumanoidRootPart"}
local PredictionAmount = 0.165

local currentTargetPart = nil
local currentHighlight = nil
local currentRotationAngle = 0
local currentIndicatorHue = 0
local npcList = {}
local targetMap = {}
local avatarCache = {}
local recentShots = {}
local pendingDamage = {}

local lockedTargetObject = nil

local target_indicator_circle = Drawing.new("Circle")
target_indicator_circle.Visible = false; target_indicator_circle.ZIndex = 1000; target_indicator_circle.Thickness = 2; target_indicator_circle.Filled = false
local target_indicator_lines = {}
for i = 1, 5 do local line = Drawing.new("Line"); line.Visible = false; line.ZIndex = 1000; line.Thickness = 2; table.insert(target_indicator_lines, line) end
local tracer_line = Drawing.new("Line")
tracer_line.Visible = false; tracer_line.ZIndex = 998; tracer_line.Color = Color3.fromRGB(255, 255, 0); tracer_line.Thickness = 1; tracer_line.Transparency = 1

local overhead_info_texts = {
    Name = Drawing.new("Text"),
    Health = Drawing.new("Text"),
    Distance = Drawing.new("Text"),
    Category = Drawing.new("Text")
}
for _, text in pairs(overhead_info_texts) do
    text.Visible = false; text.ZIndex = 1001; text.Font = Drawing.Fonts.Plex; text.Size = 14; text.Color = Color3.fromRGB(255, 255, 255); text.Center = true; text.Outline = true
end

local panel_info_bg = Drawing.new("Square")
panel_info_bg.Visible = false; panel_info_bg.ZIndex = 1002; panel_info_bg.Color = Color3.fromRGB(0, 0, 0); panel_info_bg.Thickness = 0; panel_info_bg.Filled = true; panel_info_bg.Transparency = 0.5
local panel_info_texts = {
    Name = Drawing.new("Text"),
    Health = Drawing.new("Text"),
    Distance = Drawing.new("Text"),
    Category = Drawing.new("Text")
}
for _, text in pairs(panel_info_texts) do
    text.Visible = false; text.ZIndex = 1003; text.Font = Drawing.Fonts.Plex; text.Size = 14; text.Color = Color3.fromRGB(255, 255, 255); text.Center = false; text.Outline = true
end

local FOVCircleGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
FOVCircleGui.Name = "FOVCircleGui"; FOVCircleGui.ResetOnSpawn = false; FOVCircleGui.IgnoreGuiInset = true; FOVCircleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
local FOVCircleFrame = Instance.new("Frame", FOVCircleGui)
FOVCircleFrame.Name = "FOVCircleFrame"; FOVCircleFrame.AnchorPoint = Vector2.new(0.5, 0.5); FOVCircleFrame.Position = UDim2.fromScale(0.5, 0.5); FOVCircleFrame.BackgroundTransparency = 1
local FOVStroke = Instance.new("UIStroke", FOVCircleFrame)
FOVStroke.Name = "FOVStroke"; FOVStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; FOVStroke.Thickness = 1; FOVStroke.Transparency = 0.5
local FOVCorner = Instance.new("UICorner", FOVCircleFrame)
FOVCorner.Name = "FOVCorner"; FOVCorner.CornerRadius = UDim.new(1, 0)

local IndependentPanelGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
IndependentPanelGui.Name = "IndependentPanelGui"; IndependentPanelGui.ResetOnSpawn = false; IndependentPanelGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
local IndependentPanelFrame = Instance.new("Frame", IndependentPanelGui)
IndependentPanelFrame.Name = "PanelFrame"; IndependentPanelFrame.Size = UDim2.fromOffset(160, 100);
IndependentPanelFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30); IndependentPanelFrame.BackgroundTransparency = 0.3; IndependentPanelFrame.BorderSizePixel = 1; IndependentPanelFrame.BorderColor3 = Color3.new(1,1,1)
IndependentPanelFrame.Visible = false; IndependentPanelFrame.Active = true
local IPCorner = Instance.new("UICorner", IndependentPanelFrame); IPCorner.CornerRadius = UDim.new(0, 4)
local IPListLayout = Instance.new("UIListLayout", IndependentPanelFrame)
IPListLayout.Padding = UDim.new(0, 5); IPListLayout.SortOrder = Enum.SortOrder.LayoutOrder; IPListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; IPListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

local independent_panel_texts = {}
for i, name in ipairs({"Name", "Health", "Distance", "Category"}) do
    local label = Instance.new("TextLabel", IndependentPanelFrame)
    label.Name = name; label.Size = UDim2.new(1, -10, 0, 15); label.BackgroundTransparency = 1
    label.Font = Enum.Font.SourceSans; label.TextSize = 14; label.TextColor3 = Color3.new(1,1,1); label.TextXAlignment = Enum.TextXAlignment.Left; label.LayoutOrder = i
    independent_panel_texts[name] = label
end
IndependentPanelFrame.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 and IndependentPanelFrame.Draggable then IndependentPanelFrame.Position = UDim2.fromOffset(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) end end)
IndependentPanelFrame.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 and IndependentPanelFrame.Draggable then SilentAimSettings.IndependentPanelPosition = IndependentPanelFrame.Position.X.Offset .. "," .. IndependentPanelFrame.Position.Y.Offset end end)

local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean", "boolean"} },
    FindPartOnRayWithWhitelist = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean"} },
    FindPartOnRay = { ArgCountRequired = 2, Args = {"Instance", "Ray", "Instance", "boolean", "boolean"} },
    Raycast = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }
}

local HitSounds = {
    ["bell"] = "rbxassetid://8679627751",
    ["metal"] = "rbxassetid://3125624765",
    ["click"] = "rbxassetid://17755696142",
    ["exp"] = "rbxassetid://10070796384"
}

local rainbowColor = Color3.fromHSV(0, 1, 1)
task.spawn(function()
    while task.wait() do
        if Library and Library.Unloaded then break end
        local hue = (tick() % 6) / 6
        rainbowColor = Color3.fromHSV(hue, 1, 1)
    end
end)

local function playHitSound(soundId)
    local sound = Instance.new("Sound")
    sound.Parent = CoreGui
    sound.SoundId = soundId
    sound.Volume = 0.6
    sound:Play()
    Debris:AddItem(sound, sound.TimeLength + 0.2)
end

function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    return math.random() <= Percentage / 100
end

do
    if not isfolder(MainFileName) then makefolder(MainFileName) end
    if not isfolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) then makefolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) end
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToViewportPoint(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then return false end
    for Pos, Argument in next, Args do if typeof(Argument) == RayMethod.Args[Pos] then Matches = Matches + 1 end end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function isNPC(obj)
    return obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj.Humanoid.Health > 0 and obj:FindFirstChild("HumanoidRootPart") and not Players:GetPlayerFromCharacter(obj)
end

function getTargetCategory(character)
    if not character then return "无" end

    if Players:GetPlayerFromCharacter(character) then
        return "玩家"
    end

    if SilentAimSettings.EnableNameTargeting then
        local name = character.Name:lower()
        for _, whitelistedName in ipairs(SilentAimSettings.WhitelistedNames) do
            if whitelistedName and whitelistedName ~= "" and string.find(name, whitelistedName:lower(), 1, true) then
                return "添加的"
            end
        end
    end
    
    for _, path in ipairs(SilentAimSettings.WhitelistPath) do
        local obj = workspace:FindFirstChild(path)
        if obj and obj == character then
            return "路径白名单"
        end
    end
    
    if character:FindFirstChild("Humanoid") then
         return "NPC"
    end

    return "未知"
end

local function updateNPCs()
    local newNpcList = {}
    local addedNpcs = {}

    if SilentAimSettings.EnableNameTargeting and #SilentAimSettings.WhitelistedNames > 0 then
        for _, model in ipairs(workspace:GetDescendants()) do
            if isNPC(model) then
                for _, substring in ipairs(SilentAimSettings.WhitelistedNames) do
                    if substring and substring ~= "" and string.find(model.Name:lower(), substring:lower(), 1, true) then
                        if not addedNpcs[model] then
                            table.insert(newNpcList, model)
                            addedNpcs[model] = true
                            break
                        end
                    end
                end
            end
        end
    end

    for _, path in ipairs(SilentAimSettings.WhitelistPath) do
        local obj = workspace:FindFirstChild(path)
        if obj and isNPC(obj) and not addedNpcs[obj] then
            table.insert(newNpcList, obj)
            addedNpcs[obj] = true
        end
    end

    for _, v in ipairs(workspace:GetChildren()) do
        if isNPC(v) then
            if not addedNpcs[v] then
                table.insert(newNpcList, v)
                addedNpcs[v] = true
            end
        end
    end
    
    npcList = newNpcList
end

local function isBlacklisted(name)
    local lowerName = name:lower()
    for _, blacklistedName in ipairs(SilentAimSettings.BlacklistedNames) do
        if blacklistedName:lower() == lowerName then
            return true
        end
    end
    return false
end

local function isPartVisible(part, customOrigin)
    if not part then return false end
    local localCharacter = LocalPlayer.Character
    if not localCharacter then return false end
    local origin = customOrigin or Camera.CFrame.Position
    local direction = part.Position - origin
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {localCharacter, part.Parent}
    local raycastResult = workspace:Raycast(origin, direction.Unit * direction.Magnitude, raycastParams)
    return not raycastResult
end

local function getClosestPlayer()
    local LocalPlayerCharacter = LocalPlayer.Character
    if not LocalPlayerCharacter or not LocalPlayerCharacter:FindFirstChild("HumanoidRootPart") then return nil end
    local localRoot = LocalPlayerCharacter.HumanoidRootPart
    
    local AimPoint = SilentAimSettings.FixedFOV and (Camera.ViewportSize / 2) or GetMouseLocation(UserInputService)
    local candidates = {}
    
    for _, Player in ipairs(GetPlayers(Players)) do
        if Player ~= LocalPlayer and not (SilentAimSettings.TeamCheck and Player.Team == LocalPlayer.Team) and not isBlacklisted(Player.Name) then
            local Character = Player.Character
            local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
            if Character and Humanoid and Humanoid.Health > 0 then
                local partForChecks = Character:FindFirstChild(SilentAimSettings.TargetPart) or Character:FindFirstChild("HumanoidRootPart")
                if not partForChecks then continue end

                if not (SilentAimSettings.VisibleCheck and not isPartVisible(partForChecks, LocalPlayerCharacter.Head.Position)) then
                    local physicalDist = (localRoot.Position - partForChecks.Position).Magnitude
                    if physicalDist <= SilentAimSettings.MaxDistance then
                        if SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
                            table.insert(candidates, {character = Character, fov = math.huge, dist = physicalDist, health = Humanoid.Health})
                        else
                            local ScreenPosition, OnScreen = getPositionOnScreen(partForChecks.Position)
                            if OnScreen then
                                local fovDist = (AimPoint - ScreenPosition).Magnitude
                                if fovDist <= SilentAimSettings.FOVRadius then
                                    table.insert(candidates, {character = Character, fov = fovDist, dist = physicalDist, health = Humanoid.Health})
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if #candidates == 0 then return nil end
    table.sort(candidates, function(a, b)
        if SilentAimSettings.PriorityMode == "最低血量" then
            return a.health < b.health
        elseif SilentAimSettings.PriorityMode == "距离最近" or SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
            return a.dist < b.dist
        else
            return a.fov < b.fov
        end
    end)
    return candidates[1].character
end

local function getNPCTarget()
    local LocalPlayerCharacter = LocalPlayer.Character
    if not LocalPlayerCharacter or not LocalPlayerCharacter:FindFirstChild("HumanoidRootPart") then return nil end
    local localRoot = LocalPlayerCharacter.HumanoidRootPart

    local AimPoint = SilentAimSettings.FixedFOV and (Camera.ViewportSize / 2) or GetMouseLocation(UserInputService)
    local candidates = {}

    for _, NPCModel in ipairs(npcList) do
        if not (SilentAimSettings.TeamCheck and NPCModel.Team and NPCModel.Team == LocalPlayer.Team) and not isBlacklisted(NPCModel.Name) then
            local Humanoid = NPCModel and NPCModel:FindFirstChildOfClass("Humanoid")
            if NPCModel and Humanoid and Humanoid.Health > 0 then
                local partForChecks = NPCModel:FindFirstChild(SilentAimSettings.TargetPart) or NPCModel.PrimaryPart or NPCModel:FindFirstChild("HumanoidRootPart")
                if not partForChecks then continue end

                if not (SilentAimSettings.VisibleCheck and not isPartVisible(partForChecks, LocalPlayerCharacter.Head.Position)) then
                    local physicalDist = (localRoot.Position - partForChecks.Position).Magnitude
                    if physicalDist <= SilentAimSettings.MaxDistance then
                         if SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
                            table.insert(candidates, {character = NPCModel, fov = math.huge, dist = physicalDist, health = Humanoid.Health})
                        else
                            local ScreenPosition, OnScreen = getPositionOnScreen(partForChecks.Position)
                            if OnScreen then
                                local fovDist = (AimPoint - ScreenPosition).Magnitude
                                if fovDist <= SilentAimSettings.FOVRadius then
                                    table.insert(candidates, {character = NPCModel, fov = fovDist, dist = physicalDist, health = Humanoid.Health})
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if #candidates == 0 then return nil end
    table.sort(candidates, function(a, b)
        if SilentAimSettings.PriorityMode == "最低血量" then
            return a.health < b.health
        elseif SilentAimSettings.PriorityMode == "距离最近" or SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
            return a.dist < b.dist
        else
            return a.fov < b.fov
        end
    end)
    return candidates[1].character
end

function getPolygonPoints(center, radius, sides)
    local points = {}
    local rotationOffset = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
    for i = 1, sides do
        local angle = (i - 1) * (2 * math.pi / sides) - (math.pi / 2) + rotationOffset
        table.insert(points, Vector2.new(center.X + radius * math.cos(angle), center.Y + radius * math.sin(angle)))
    end
    return points
end

function hideAllVisuals()
    target_indicator_circle.Visible = false
    for _, line in ipairs(target_indicator_lines) do line.Visible = false end
    for _, text in pairs(overhead_info_texts) do text.Visible = false end
    panel_info_bg.Visible = false
    for _, text in pairs(panel_info_texts) do text.Visible = false end
    if IndependentPanelFrame then IndependentPanelFrame.Visible = false end
end

local repo = "https://raw.githubusercontent.com/SyndromeXph/NOL-Obsidian/refs/heads/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

local Window = Library:CreateWindow({ Title = "通用 Slient Aim", Footer = "Yuxin", Center = true, AutoShow = true })

local Tabs = {
    Main = Window:AddTab("主页", "user"),
    Visuals = Window:AddTab("视觉", "camera"),
    Management = Window:AddTab("管理", "users"),
    Misc = Window:AddTab("杂项", "box"),
    ["UI Settings"] = Window:AddTab("UI设置", "settings"),
}

local MainSettingsBox = Tabs.Main:AddLeftGroupbox("主设置")
MainSettingsBox:AddToggle("EnabledToggle", { Text = "启用", Default = SilentAimSettings.Enabled }):AddKeyPicker("EnabledKeybind", { Default = SilentAimSettings.ToggleKey, SyncToggleState = true, Mode = "Toggle" })
Toggles.EnabledToggle:OnChanged(function(Value) SilentAimSettings.Enabled = Value end)
MainSettingsBox:AddToggle("TeamCheckToggle", { Text = "队伍检查", Default = SilentAimSettings.TeamCheck }):OnChanged(function(Value) SilentAimSettings.TeamCheck = Value end)
MainSettingsBox:AddToggle("VisibleCheckToggle", { Text = "可见性检查", Default = SilentAimSettings.VisibleCheck }):OnChanged(function(Value) SilentAimSettings.VisibleCheck = Value end)
MainSettingsBox:AddToggle("WallbangToggle", { Text = "穿墙", Default = SilentAimSettings.Wallbang}):OnChanged(function(Value) SilentAimSettings.Wallbang = Value end)
MainSettingsBox:AddToggle("LeakAndHitToggle", { Text = "漏打模式", Default = SilentAimSettings.LeakAndHitMode}):OnChanged(function(Value) SilentAimSettings.LeakAndHitMode = Value end)
MainSettingsBox:AddSlider('HitChanceSlider', { Text = '命中率', Default = SilentAimSettings.HitChance, Min = 0, Max = 100, Rounding = 1, Suffix = "%" }):OnChanged(function(Value) SilentAimSettings.HitChance = Value end)

local TargetingBox = Tabs.Main:AddRightGroupbox("目标")
TargetingBox:AddDropdown("TargetModeDropdown", { Text = "目标种类", Default = "请选择", Values = {"玩家", "NPC", "所有"} }):OnChanged(function(Value) SilentAimSettings.TargetMode = Value end)
TargetingBox:AddDropdown("TargetPartDropdown", { Values = {"Head", "HumanoidRootPart", "Random"}, Default = SilentAimSettings.TargetPart, Text = "目标部位" }):OnChanged(function(Value) SilentAimSettings.TargetPart = Value end)
TargetingBox:AddDropdown("PriorityModeDropdown", { Text = "优先模式", Default = SilentAimSettings.PriorityMode, Values = {"准星最近", "距离最近", "最低血量", "最近的人(无FOV)"} }):OnChanged(function(Value) SilentAimSettings.PriorityMode = Value end)
TargetingBox:AddSlider('MaxDistanceSlider', { Text = '最大距离', Default = SilentAimSettings.MaxDistance, Min = 10, Max = 2000, Rounding = 0, Suffix = "studs" }):OnChanged(function(Value) SilentAimSettings.MaxDistance = Value end)

local MethodBox = Tabs.Main:AddRightGroupbox("方法")
MethodBox:AddDropdown("MethodDropdown", { Text = "静默瞄准方式", Default = SilentAimSettings.SilentAimMethod, Values = { "Raycast","FindPartOnRay", "FindPartOnRayWithWhitelist", "FindPartOnRayWithIgnoreList", "ScreenPointToRay", "ViewportPointToRay", "Ray", "Mouse.Hit/Target" } }):OnChanged(function(Value) SilentAimSettings.SilentAimMethod = Value end)
MethodBox:AddToggle("PredictionToggle", { Text = "Mouse.Hit/Target 预判", Default = SilentAimSettings.MouseHitPrediction }):OnChanged(function(Value) SilentAimSettings.MouseHitPrediction = Value end)
MethodBox:AddSlider("PredictionAmountSlider", { Text = "预判量", Min = 0, Max = 1, Default = SilentAimSettings.MouseHitPredictionAmount, Rounding = 3 }):OnChanged(function(Value) SilentAimSettings.MouseHitPredictionAmount = Value; PredictionAmount = Value end)
MethodBox:AddToggle("HeadshotChanceToggle", { Text = "启用爆头几率", Default = SilentAimSettings.HeadshotChanceEnabled }):OnChanged(function(Value) SilentAimSettings.HeadshotChanceEnabled = Value end)
MethodBox:AddSlider('HeadshotChanceSlider', { Text = '爆头概率', Default = SilentAimSettings.HeadshotChance, Min = 0, Max = 100, Rounding = 1, Suffix = "%" }):OnChanged(function(Value) SilentAimSettings.HeadshotChance = Value end)

local FovIndicatorBox = Tabs.Visuals:AddLeftGroupbox("范围与指示器")
FovIndicatorBox:AddToggle("FOVVisibleToggle", { Text = "显示FOV圈", Default = SilentAimSettings.FOVVisible }):AddColorPicker("FOVColorPicker", { Default = Color3.fromRGB(54, 57, 241), Title = "FOV圈颜色" })
Toggles.FOVVisibleToggle:OnChanged(function(Value) FOVCircleGui.Enabled = Value; SilentAimSettings.FOVVisible = Value end)
Options.FOVColorPicker:OnChanged(function(Value) FOVStroke.Color = Value end)
FovIndicatorBox:AddSlider("FOVRadiusSlider", { Text = "FOV圈半径", Min = 10, Max = 1000, Default = SilentAimSettings.FOVRadius, Rounding = 0 }):OnChanged(function(Value) FOVCircleFrame.Size = UDim2.fromOffset(Value * 2, Value * 2); SilentAimSettings.FOVRadius = Value end)
FovIndicatorBox:AddToggle("FixedFOVToggle", { Text = "固定FOV (移动端)", Default = SilentAimSettings.FixedFOV }):OnChanged(function(Value) SilentAimSettings.FixedFOV = Value end)
FovIndicatorBox:AddToggle("ShowTargetToggle", { Text = "显示目标", Default = SilentAimSettings.ShowSilentAimTarget }):AddColorPicker("TargetIndicatorColorPicker", { Default = Color3.fromRGB(255,0,0), Title = "指示器颜色" })
Toggles.ShowTargetToggle:OnChanged(function(Value) SilentAimSettings.ShowSilentAimTarget = Value end)
Options.TargetIndicatorColorPicker:OnChanged(function(Value) target_indicator_circle.Color = Value; for _, line in ipairs(target_indicator_lines) do line.Color = Value end end)
FovIndicatorBox:AddDropdown("IndicatorStyleDropdown", { Text = "指示器样式", Values = {"Circle", "Triangle", "Pentagram", "十字准星", "三线准星"}, Default = "Circle" })
FovIndicatorBox:AddSlider("TargetIndicatorRadiusSlider", { Text = "指示器大小(通用)", Min = 5, Max = 50, Default = SilentAimSettings.TargetIndicatorRadius, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.TargetIndicatorRadius = Value end)
FovIndicatorBox:AddSlider("CrosshairLengthSlider", { Text = "十字准星长度", Min = 5, Max = 100, Default = SilentAimSettings.CrosshairLength, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.CrosshairLength = Value end)
FovIndicatorBox:AddSlider("CrosshairGapSlider", { Text = "十字准星间隙", Min = 0, Max = 50, Default = SilentAimSettings.CrosshairGap, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.CrosshairGap = Value end)
FovIndicatorBox:AddToggle("IndicatorRotationToggle", { Text = "指示器旋转", Default = SilentAimSettings.IndicatorRotationEnabled }):OnChanged(function(Value) SilentAimSettings.IndicatorRotationEnabled = Value end)
FovIndicatorBox:AddSlider("IndicatorRotationSpeedSlider", { Text = "旋转速度", Min = 0, Max = 10, Default = SilentAimSettings.IndicatorRotationSpeed, Rounding = 1 }):OnChanged(function(Value) SilentAimSettings.IndicatorRotationSpeed = Value end)
FovIndicatorBox:AddToggle("IndicatorRainbowToggle", { Text = "启用彩虹色", Default = SilentAimSettings.IndicatorRainbowEnabled }):OnChanged(function(Value) SilentAimSettings.IndicatorRainbowEnabled = Value end)
FovIndicatorBox:AddSlider("IndicatorRainbowSpeedSlider", { Text = "颜色变换速度", Min = 0, Max = 10, Default = SilentAimSettings.IndicatorRainbowSpeed, Rounding = 1 }):OnChanged(function(Value) SilentAimSettings.IndicatorRainbowSpeed = Value end)
FovIndicatorBox:AddToggle("IndicatorBreathingToggle", { Text = "启用呼吸效果", Default = SilentAimSettings.IndicatorBreathingEnabled }):OnChanged(function(Value) SilentAimSettings.IndicatorBreathingEnabled = Value end)
FovIndicatorBox:AddSlider("IndicatorBreathingSpeedSlider", { Text = "呼吸速度", Min = 0.1, Max = 5, Default = SilentAimSettings.IndicatorBreathingSpeed, Rounding = 1 }):OnChanged(function(Value) SilentAimSettings.IndicatorBreathingSpeed = Value end)
FovIndicatorBox:AddSlider("IndicatorBreathingMinSlider", { Text = "呼吸最小比例", Min = 0.1, Max = 1, Default = SilentAimSettings.IndicatorBreathingMin, Rounding = 2 }):OnChanged(function(Value) SilentAimSettings.IndicatorBreathingMin = Value end)
FovIndicatorBox:AddSlider("IndicatorBreathingMaxSlider", { Text = "呼吸最大比例", Min = 1, Max = 3, Default = SilentAimSettings.IndicatorBreathingMax, Rounding = 2 }):OnChanged(function(Value) SilentAimSettings.IndicatorBreathingMax = Value end)
FovIndicatorBox:AddToggle("ThreeLineCrosshairToggle", { Text = "启用三线准星", Default = SilentAimSettings.ThreeLineCrosshairEnabled }):OnChanged(function(Value) SilentAimSettings.ThreeLineCrosshairEnabled = Value end)
FovIndicatorBox:AddSlider("ThreeLineCrosshairLengthSlider", { Text = "三线准星长度", Min = 5, Max = 100, Default = SilentAimSettings.ThreeLineCrosshairLength, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.ThreeLineCrosshairLength = Value end)
FovIndicatorBox:AddSlider("ThreeLineCrosshairGapSlider", { Text = "三线准星间隙", Min = 0, Max = 50, Default = SilentAimSettings.ThreeLineCrosshairGap, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.ThreeLineCrosshairGap = Value end)

local InfoBox = Tabs.Visuals:AddRightGroupbox("信息")
InfoBox:AddDropdown("TargetInfoStyleDropdown", { Text = "信息显示样式", Default = SilentAimSettings.TargetInfoStyle, Values = {"面板", "头顶", "独立面板"} }):OnChanged(function(Value) SilentAimSettings.TargetInfoStyle = Value end)
InfoBox:AddToggle("ShowTargetNameToggle", { Text = "显示目标名字", Default = SilentAimSettings.ShowTargetName }):OnChanged(function(Value) SilentAimSettings.ShowTargetName = Value end)
InfoBox:AddToggle("ShowTargetHealthToggle", { Text = "显示目标血量", Default = SilentAimSettings.ShowTargetHealth }):OnChanged(function(Value) SilentAimSettings.ShowTargetHealth = Value end)
InfoBox:AddToggle("ShowTargetDistanceToggle", { Text = "显示目标距离", Default = SilentAimSettings.ShowTargetDistance }):OnChanged(function(Value) SilentAimSettings.ShowTargetDistance = Value end)
InfoBox:AddToggle("ShowTargetCategoryToggle", { Text = "显示目标类别", Default = SilentAimSettings.ShowTargetCategory }):OnChanged(function(Value) SilentAimSettings.ShowTargetCategory = Value end)
InfoBox:AddButton("重置独立面板位置", function()
    SilentAimSettings.IndependentPanelPosition = "200,200"
    local pos = SilentAimSettings.IndependentPanelPosition:split(",")
    IndependentPanelFrame.Position = UDim2.fromOffset(tonumber(pos[1]), tonumber(pos[2]))
end)
InfoBox:AddToggle("PinPanelToggle", {Text = "固定面板", Default = SilentAimSettings.IndependentPanelPinned}):OnChanged(function(value)
    SilentAimSettings.IndependentPanelPinned = value
    IndependentPanelFrame.Draggable = not value
end)

local ExtrasBox = Tabs.Visuals:AddRightGroupbox("额外")
ExtrasBox:AddToggle("HighlightToggle", { Text = "启用高亮", Default = SilentAimSettings.HighlightEnabled }):AddColorPicker("HighlightColorPicker", { Default = SilentAimSettings.HighlightColor, Title = "高亮颜色" })
Toggles.HighlightToggle:OnChanged(function(Value) SilentAimSettings.HighlightEnabled = Value end)
Options.HighlightColorPicker:OnChanged(function(Value) SilentAimSettings.HighlightColor = Value end)
ExtrasBox:AddToggle("HighlightRainbowToggle", { Text = "高亮彩虹色", Default = SilentAimSettings.HighlightRainbowEnabled }):OnChanged(function(Value) SilentAimSettings.HighlightRainbowEnabled = Value end)
ExtrasBox:AddToggle("DamageNotifierToggle", { Text = "显示伤害通知", Default = SilentAimSettings.ShowDamageNotifier }):OnChanged(function(Value) SilentAimSettings.ShowDamageNotifier = Value end)
ExtrasBox:AddDropdown('HitSound', { Text = '击中音效', Default = '关闭', Values = {'关闭', 'bell', 'metal', 'click', 'exp'} })
ExtrasBox:AddToggle("ShowTracerToggle", { Text = "显示目标追踪线", Default = SilentAimSettings.ShowTracer }):AddColorPicker("TracerColorPicker", { Default = tracer_line.Color, Title = "追踪线颜色" })
Toggles.ShowTracerToggle:OnChanged(function(Value) SilentAimSettings.ShowTracer = Value end)
Options.TracerColorPicker:OnChanged(function(Value) tracer_line.Color = Value end)
ExtrasBox:AddSlider('TracerYOffsetSlider', { Text = '追踪线Y轴偏移', Default = SilentAimSettings.Tracer_Y_Offset, Min = -10, Max = 10, Rounding = 3, Suffix = " studs" }):OnChanged(function(Value) SilentAimSettings.Tracer_Y_Offset = Value end)

local ManualLockGroupBox = Tabs.Management:AddLeftGroupbox("手动锁定")
ManualLockGroupBox:AddDropdown("TargetSelectorDropdown", { Text = "锁定目标 (无=自动)", Default = "无", Values = {"无"} }):OnChanged(function(selectedName)
    if selectedName == "无" then
        lockedTargetObject = nil
    else
        lockedTargetObject = targetMap[selectedName]
    end
end)
ManualLockGroupBox:AddButton("刷新列表", function()
    targetMap = {}
    local targetNames = {"无"}
    local targetMode = SilentAimSettings.TargetMode
    
    if targetMode == "NPC" or targetMode == "所有" then
        updateNPCs()
    end
    
    if targetMode == "玩家" or targetMode == "所有" then
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                if not (SilentAimSettings.TeamCheck and player.Team == LocalPlayer.Team) then
                    table.insert(targetNames, player.Name)
                    targetMap[player.Name] = player
                end
            end
        end
    end
    
    if targetMode == "NPC" or targetMode == "所有" then
        for _, npc in ipairs(npcList) do
            if npc and npc.Name and npc.PrimaryPart then
                table.insert(targetNames, npc.Name)
                targetMap[npc.Name] = npc
            end
        end
    end

    Options.TargetSelectorDropdown:SetValues(targetNames, "无")
    lockedTargetObject = nil
end)

local NameTargetingGroup = Tabs.Management:AddLeftGroupbox("名称索敌")
NameTargetingGroup:AddToggle("EnableNameTargetingToggle", { Text = "启用名称索敌", Default = SilentAimSettings.EnableNameTargeting }):OnChanged(function(Value)
    SilentAimSettings.EnableNameTargeting = Value
end)
local whitelistDataOption = NameTargetingGroup:AddInput("WhitelistData", { Text = "Whitelist Internal Data", Default = "[]" })
whitelistDataOption.Visible = false
local function updateWhitelistData()
    local jsonString = HttpService:JSONEncode(SilentAimSettings.WhitelistedNames)
    whitelistDataOption:SetValue(jsonString)
end
NameTargetingGroup:AddInput("WhitelistNameInput", { Text = "名称", PlaceholderText = "输入要锁定的NPC名称关键字" })
NameTargetingGroup:AddButton("添加到列表", function()
    local name = Options.WhitelistNameInput.Value
    if name and name ~= "" then
        table.insert(SilentAimSettings.WhitelistedNames, name)
        Options.WhitelistDropdown:SetValues(SilentAimSettings.WhitelistedNames)
        Options.WhitelistNameInput:SetValue("")
        updateWhitelistData()
    end
end)
NameTargetingGroup:AddDropdown("WhitelistDropdown", { Text = "名称列表", Values = SilentAimSettings.WhitelistedNames or {} })
NameTargetingGroup:AddButton("从列表中删除", function()
    local selectedName = Options.WhitelistDropdown.Value
    if selectedName then
        for i, name in ipairs(SilentAimSettings.WhitelistedNames) do
            if name == selectedName then
                table.remove(SilentAimSettings.WhitelistedNames, i)
                break
            end
        end
        Options.WhitelistDropdown:SetValues(SilentAimSettings.WhitelistedNames)
        updateWhitelistData()
    end
end)
whitelistDataOption:OnChanged(function(jsonString)
    if not jsonString or jsonString == "" then jsonString = "[]" end
    local success, decoded = pcall(HttpService.JSONDecode, HttpService, jsonString)
    if success and type(decoded) == 'table' then
        SilentAimSettings.WhitelistedNames = decoded
        Options.WhitelistDropdown:SetValues(SilentAimSettings.WhitelistedNames)
    end
end)

local WhitelistPathGroup = Tabs.Management:AddLeftGroupbox("白名单路径管理")
WhitelistPathGroup:AddInput("WhitelistPathInput", { Text = "路径", PlaceholderText = "输入从Workspace开始的路径" })
WhitelistPathGroup:AddButton("添加路径", function()
    local path = Options.WhitelistPathInput.Value
    if path and path ~= "" then
        table.insert(SilentAimSettings.WhitelistPath, path)
        Options.WhitelistPathDropdown:SetValues(SilentAimSettings.WhitelistPath)
        Options.WhitelistPathInput:SetValue("")
    end
end)
WhitelistPathGroup:AddDropdown("WhitelistPathDropdown", { Text = "路径列表", Values = SilentAimSettings.WhitelistPath or {} })
WhitelistPathGroup:AddButton("删除路径", function()
    local selectedPath = Options.WhitelistPathDropdown.Value
    if selectedPath then
        for i, p in ipairs(SilentAimSettings.WhitelistPath) do
            if p == selectedPath then
                table.remove(SilentAimSettings.WhitelistPath, i)
                break
            end
        end
        Options.WhitelistPathDropdown:SetValues(SilentAimSettings.WhitelistPath)
    end
end)

local BlacklistGroup = Tabs.Management:AddRightGroupbox("黑名单管理")
local blacklistDataOption = BlacklistGroup:AddInput("BlacklistData", { Text = "Blacklist Internal Data", Default = "[]" })
blacklistDataOption.Visible = false
local function updateBlacklistData()
    local jsonString = HttpService:JSONEncode(SilentAimSettings.BlacklistedNames)
    blacklistDataOption:SetValue(jsonString)
end
BlacklistGroup:AddInput("BlacklistNameInput", { Text = "名称", PlaceholderText = "输入要拉黑的精确名称" })
BlacklistGroup:AddButton("添加到黑名单", function()
    local name = Options.BlacklistNameInput.Value
    if name and name ~= "" and not isBlacklisted(name) then
        table.insert(SilentAimSettings.BlacklistedNames, name)
        Options.BlacklistDropdown:SetValues(SilentAimSettings.BlacklistedNames)
        Options.BlacklistNameInput:SetValue("")
        updateBlacklistData()
    end
end)
BlacklistGroup:AddDropdown("BlacklistDropdown", { Text = "黑名单列表", Values = SilentAimSettings.BlacklistedNames or {} })
BlacklistGroup:AddButton("从黑名单中删除", function()
    local selectedName = Options.BlacklistDropdown.Value
    if selectedName then
        for i, name in ipairs(SilentAimSettings.BlacklistedNames) do
            if name == selectedName then
                table.remove(SilentAimSettings.BlacklistedNames, i)
                break
            end
        end
        Options.BlacklistDropdown:SetValues(SilentAimSettings.BlacklistedNames)
        updateBlacklistData()
    end
end)
blacklistDataOption:OnChanged(function(jsonString)
    if not jsonString or jsonString == "" then jsonString = "[]" end
    local success, decoded = pcall(HttpService.JSONDecode, HttpService, jsonString)
    if success and type(decoded) == 'table' then
        SilentAimSettings.BlacklistedNames = decoded
        Options.BlacklistDropdown:SetValues(SilentAimSettings.BlacklistedNames)
    end
end)

local CharacterModGroup = Tabs.Misc:AddLeftGroupbox("角色修改")
local originalCharacterData = {}
local transparencyLoopConnection = nil
local function restoreCharacterAppearance()
    for part, data in pairs(originalCharacterData) do
        if part and part.Parent then
            part.Material = data.material
            part.Color = data.color
            part.Transparency = data.transparency
        end
    end
    originalCharacterData = {}
end
local function transparencyLoop()
    if not LocalPlayer.Character then
        if next(originalCharacterData) then
            originalCharacterData = {}
        end
        return
    end
    local isRainbowEnabled = Toggles.TransparentCharacterRainbow.Value
    for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") then
            if not originalCharacterData[part] then
                originalCharacterData[part] = {
                    material = part.Material,
                    color = part.Color,
                    transparency = part.Transparency
                }
            end
            part.Material = Enum.Material.ForceField
            if isRainbowEnabled then
                part.Color = rainbowColor
            else
                part.Color = originalCharacterData[part].color
            end
        end
    end
end
CharacterModGroup:AddToggle("TransparentCharacterEnabled", { Text = "人物透明", Default = false }):OnChanged(function(value)
    if value then
        transparencyLoopConnection = RunService.Heartbeat:Connect(transparencyLoop)
    else
        if transparencyLoopConnection then
            transparencyLoopConnection:Disconnect()
            transparencyLoopConnection = nil
        end
        restoreCharacterAppearance()
    end
end)
CharacterModGroup:AddToggle("TransparentCharacterRainbow", { Text = "人物变色", Default = false }):OnChanged(function(value)
    if not value and Toggles.TransparentCharacterEnabled.Value then
        restoreCharacterAppearance()
        task.wait()
        transparencyLoop()
    end
end)

local EntertainmentGroup = Tabs.Misc:AddLeftGroupbox("娱乐")
local spinThread = nil
local spinEnabled = false
local spinSpeed = math.rad(10)
local function spinCharacter()
    while spinEnabled and task.wait() do
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, spinSpeed, 0)
        else
            break
        end
    end
    spinThread = nil
end
EntertainmentGroup:AddToggle("SpinToggle", { Text = "启用旋转", Default = false }):OnChanged(function(value)
    spinEnabled = value
    if spinEnabled and not spinThread then
        spinThread = coroutine.create(spinCharacter)
        coroutine.resume(spinThread)
    end
end)
EntertainmentGroup:AddSlider("SpinSpeedSlider", { Text = "旋转速度", Default = 10, Min = 1, Max = 100, Rounding = 0 }):OnChanged(function(value)
    spinSpeed = math.rad(value)
end)

FOVCircleGui.Enabled = Toggles.FOVVisibleToggle.Value
FOVStroke.Color = Options.FOVColorPicker.Value
FOVCircleFrame.Size = UDim2.fromOffset(Options.FOVRadiusSlider.Value * 2, Options.FOVRadiusSlider.Value * 2)
IndependentPanelFrame.Draggable = not SilentAimSettings.IndependentPanelPinned

task.spawn(function()
    while task.wait(2) do
        if SilentAimSettings.TargetMode == "NPC" or SilentAimSettings.TargetMode == "所有" then
            updateNPCs()
        end
    end
end)

local lastHealthValues = {}
local damageIndicators = {}
local DAMAGE_INDICATOR_FADE_TIME = 1

local pos = SilentAimSettings.IndependentPanelPosition:split(",")
IndependentPanelFrame.Position = UDim2.fromOffset(tonumber(pos[1]), tonumber(pos[2]))

local lastTargetCharacter = nil
local lockedRandomPart = nil

resume(create(function()
    RenderStepped:Connect(function()
        if SilentAimSettings.IndicatorRotationEnabled then currentRotationAngle = (currentRotationAngle + (SilentAimSettings.IndicatorRotationSpeed / 50)) % (math.pi * 2) end
        if SilentAimSettings.IndicatorRainbowEnabled or SilentAimSettings.HighlightRainbowEnabled or (Toggles.TransparentCharacterRainbow and Toggles.TransparentCharacterRainbow.Value) then currentIndicatorHue = (currentIndicatorHue + (SilentAimSettings.IndicatorRainbowSpeed / 200)) % 1 end
        
        local currentTime = tick()
        for i = #recentShots, 1, -1 do
            if currentTime - recentShots[i].time > 1 then
                table.remove(recentShots, i)
            end
        end

        local isEnabled = Toggles.EnabledToggle.Value
        currentTargetPart = nil
        local currentTargetCharacter = nil

        if isEnabled then
            if lockedTargetObject then
                 if lockedTargetObject.Parent and not isBlacklisted(lockedTargetObject.Name) then
                    if lockedTargetObject:IsA("Player") then
                        currentTargetCharacter = lockedTargetObject.Character
                    elseif lockedTargetObject:IsA("Model") then
                        currentTargetCharacter = lockedTargetObject
                    end
                else
                    lockedTargetObject = nil
                    Options.TargetSelectorDropdown:SetValue("无")
                end
            else
                local targetMode = SilentAimSettings.TargetMode
                local playerTarget, npcTarget
                if targetMode == "玩家" or targetMode == "所有" then playerTarget = getClosestPlayer() end
                if targetMode == "NPC" or targetMode == "所有" then npcTarget = getNPCTarget() end

                if playerTarget and npcTarget then
                    local priority = SilentAimSettings.PriorityMode
                    if priority == "最低血量" then
                        local pHumanoid = playerTarget:FindFirstChildOfClass("Humanoid")
                        local nHumanoid = npcTarget:FindFirstChildOfClass("Humanoid")
                        currentTargetCharacter = (pHumanoid and nHumanoid and pHumanoid.Health <= nHumanoid.Health) and playerTarget or npcTarget
                    else
                        local pDist = (LocalPlayer.Character.HumanoidRootPart.Position - playerTarget.HumanoidRootPart.Position).Magnitude
                        local nDist = (LocalPlayer.Character.HumanoidRootPart.Position - npcTarget.HumanoidRootPart.Position).Magnitude
                        currentTargetCharacter = pDist < nDist and playerTarget or npcTarget
                    end
                else
                    currentTargetCharacter = playerTarget or npcTarget
                end
            end
        end

        if currentTargetCharacter ~= lastTargetCharacter then
            lockedRandomPart = nil
        end
        lastTargetCharacter = currentTargetCharacter

        if currentTargetCharacter then
            local humanoid = currentTargetCharacter:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                if lockedTargetObject and lockedTargetObject:IsA("Model") and lockedTargetObject == currentTargetCharacter then
                    lockedTargetObject = nil
                    Options.TargetSelectorDropdown:SetValue("无")
                end
                currentTargetCharacter = nil
                currentTargetPart = nil
            else
                local baseTargetPart = nil
                if SilentAimSettings.LeakAndHitMode then
                    for _, part in ipairs(currentTargetCharacter:GetDescendants()) do
                        if part:IsA("BasePart") and part.Parent == currentTargetCharacter then
                            if isPartVisible(part) then
                                baseTargetPart = part
                                break
                            end
                        end
                    end
                else
                    local targetPartName = SilentAimSettings.TargetPart
                    if targetPartName == "Random" then
                        if not lockedRandomPart or not lockedRandomPart.Parent or lockedRandomPart.Parent ~= currentTargetCharacter then
                            lockedRandomPart = currentTargetCharacter[ValidTargetParts[math.random(1, #ValidTargetParts)]]
                        end
                        baseTargetPart = lockedRandomPart
                    else
                        baseTargetPart = currentTargetCharacter:FindFirstChild(targetPartName) or currentTargetCharacter:FindFirstChild("HumanoidRootPart")
                    end
                end

                if baseTargetPart then
                    if SilentAimSettings.HeadshotChanceEnabled and CalculateChance(SilentAimSettings.HeadshotChance) then
                        local headPart = currentTargetCharacter:FindFirstChild("Head")
                        if headPart then
                            currentTargetPart = headPart
                        else
                            currentTargetPart = baseTargetPart
                        end
                    else
                        currentTargetPart = baseTargetPart
                    end
                else
                    currentTargetPart = nil
                end
            end
        end

        if isEnabled and currentTargetPart then
            local humanoid = currentTargetPart.Parent:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local currentHealth = humanoid.Health
                local lastHealth = lastHealthValues[humanoid]
                if lastHealth and currentHealth < lastHealth then
                    local damage = math.floor(lastHealth - currentHealth)
                    if damage > 0 then
                        if not pendingDamage[humanoid] then
                            pendingDamage[humanoid] = { damage = 0, lastUpdate = tick(), position = currentTargetPart.Position }
                        end
                        pendingDamage[humanoid].damage = pendingDamage[humanoid].damage + damage
                        pendingDamage[humanoid].lastUpdate = tick()
                        pendingDamage[humanoid].position = currentTargetPart.Position

                        local selectedSoundName = Options.HitSound.Value
                        if selectedSoundName ~= '关闭' then
                            local soundId = HitSounds[selectedSoundName]
                            if soundId then
                                playHitSound(soundId)
                            end
                        end
                    end
                end
                lastHealthValues[humanoid] = currentHealth
            end
        end
        
        local DAMAGE_ACCUMULATION_WINDOW = 0.15
        for humanoid, data in pairs(pendingDamage) do
            if currentTime - data.lastUpdate > DAMAGE_ACCUMULATION_WINDOW then
                if SilentAimSettings.ShowDamageNotifier and data.damage > 0 then
                    local screenPos, onScreen = getPositionOnScreen(data.position)
                    if onScreen then
                        local indicator = {};
                        indicator.Created = tick();
                        indicator.Position = screenPos;
                        indicator.TextObject = Drawing.new("Text")
                        indicator.TextObject.Font = Drawing.Fonts.Monospace;
                        indicator.TextObject.Text = string.format("-%d", data.damage)
                        indicator.TextObject.Color = Color3.fromRGB(255, 50, 50);
                        indicator.TextObject.Size = 20
                        indicator.TextObject.Center = true;
                        indicator.TextObject.Outline = true
                        table.insert(damageIndicators, indicator)
                    end
                end
                pendingDamage[humanoid] = nil
            end
        end

        for i = #damageIndicators, 1, -1 do
            local indicator = damageIndicators[i]; local age = tick() - indicator.Created
            if age > DAMAGE_INDICATOR_FADE_TIME then
                indicator.TextObject:Remove(); table.remove(damageIndicators, i)
            else
                local progress = age / DAMAGE_INDICATOR_FADE_TIME
                indicator.TextObject.Position = indicator.Position - Vector2.new(0, progress * 40)
                indicator.TextObject.Transparency = progress; indicator.TextObject.Visible = true
            end
        end

        hideAllVisuals()
        
        if currentHighlight and (not currentTargetCharacter or not SilentAimSettings.HighlightEnabled) then
            currentHighlight:Destroy()
            currentHighlight = nil
        end

        if isEnabled and currentTargetCharacter and SilentAimSettings.HighlightEnabled then
             if not currentHighlight then
                currentHighlight = Instance.new("Highlight")
                currentHighlight.Parent = currentTargetCharacter
            end
            currentHighlight.Adornee = currentTargetCharacter
            currentHighlight.Enabled = true
            currentHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            if SilentAimSettings.HighlightRainbowEnabled then
                local rainbowColor = Color3.fromHSV(currentIndicatorHue, 1, 1)
                currentHighlight.FillColor = rainbowColor
                currentHighlight.OutlineColor = rainbowColor
                currentHighlight.FillTransparency = 0.5
                currentHighlight.OutlineTransparency = 0
            else
                currentHighlight.FillColor = SilentAimSettings.HighlightColor
                currentHighlight.OutlineColor = SilentAimSettings.HighlightColor
                currentHighlight.FillTransparency = 0.5
                currentHighlight.OutlineTransparency = 0
            end
        end

        if isEnabled and currentTargetPart then
            local RootToViewportPoint, IsOnScreen = getPositionOnScreen(currentTargetPart.Position)

            if IsOnScreen and Toggles.ShowTargetToggle.Value then
                local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                local indicatorStyle = Options.IndicatorStyleDropdown.Value
                local finalIndicatorColor; local isTargetVisible = isPartVisible(currentTargetPart)
                if isTargetVisible then finalIndicatorColor = Color3.fromRGB(0, 255, 0); indicatorRadius = indicatorRadius * 0.6
                elseif SilentAimSettings.IndicatorRainbowEnabled then finalIndicatorColor = Color3.fromHSV(currentIndicatorHue, 1, 1)
                else finalIndicatorColor = Options.TargetIndicatorColorPicker.Value end
                
                local breathingScale = 1
                if SilentAimSettings.IndicatorBreathingEnabled then
                    breathingScale = SilentAimSettings.IndicatorBreathingMin + 
                                     (SilentAimSettings.IndicatorBreathingMax - SilentAimSettings.IndicatorBreathingMin) * 
                                     (math.sin(tick() * SilentAimSettings.IndicatorBreathingSpeed * math.pi * 2) * 0.5 + 0.5)
                end
                
                if indicatorStyle == "Circle" then
                    target_indicator_circle.Visible = true; target_indicator_circle.Color = finalIndicatorColor; target_indicator_circle.Radius = indicatorRadius * breathingScale; target_indicator_circle.Position = RootToViewportPoint
                elseif indicatorStyle == "Triangle" then
                    local points = getPolygonPoints(RootToViewportPoint, indicatorRadius * breathingScale, 3)
                    for i = 1, 3 do local line = target_indicator_lines[i]; line.Visible = true; line.Color = finalIndicatorColor; line.From = points[i]; line.To = points[i % 3 + 1] end
                elseif indicatorStyle == "Pentagram" then
                    local points = getPolygonPoints(RootToViewportPoint, indicatorRadius * breathingScale, 5)
                    local pentagram_order = {1, 3, 5, 2, 4}
                    for i = 1, 5 do local line = target_indicator_lines[i]; line.Visible = true; line.Color = finalIndicatorColor; line.From = points[pentagram_order[i]]; line.To = points[pentagram_order[i % 5 + 1]] end
                elseif indicatorStyle == "十字准星" then
                    local length = SilentAimSettings.CrosshairLength * breathingScale
                    local gap = SilentAimSettings.CrosshairGap * breathingScale
                    local center = RootToViewportPoint
                    local rotation = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
                    local cos, sin = math.cos(rotation), math.sin(rotation)

                    local function rotate(v)
                        return Vector2.new(v.X * cos - v.Y * sin, v.X * sin + v.Y * cos)
                    end

                    local points = {
                        {From = rotate(Vector2.new(0, -length)) + center, To = rotate(Vector2.new(0, -gap)) + center},
                        {From = rotate(Vector2.new(0, length)) + center, To = rotate(Vector2.new(0, gap)) + center},
                        {From = rotate(Vector2.new(-length, 0)) + center, To = rotate(Vector2.new(-gap, 0)) + center},
                        {From = rotate(Vector2.new(length, 0)) + center, To = rotate(Vector2.new(gap, 0)) + center}
                    }

                    for i = 1, 4 do
                        target_indicator_lines[i].Visible = true
                        target_indicator_lines[i].Color = finalIndicatorColor
                        target_indicator_lines[i].From = points[i].From
                        target_indicator_lines[i].To = points[i].To
                    end
                elseif indicatorStyle == "三线准星" and SilentAimSettings.ThreeLineCrosshairEnabled then
                    local length = SilentAimSettings.ThreeLineCrosshairLength * breathingScale
                    local gap = SilentAimSettings.ThreeLineCrosshairGap * breathingScale
                    local center = RootToViewportPoint
                    local rotation = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
                    
                    for i = 1, 3 do
                        local angle = rotation + (i - 1) * (math.pi * 2 / 3)
                        local dir = Vector2.new(math.cos(angle), math.sin(angle))
                        local start = center + dir * gap
                        local endPos = center + dir * length
                        
                        target_indicator_lines[i].Visible = true
                        target_indicator_lines[i].Color = finalIndicatorColor
                        target_indicator_lines[i].From = start
                        target_indicator_lines[i].To = endPos
                    end
                end
            end

            local showAnyInfo = Toggles.ShowTargetNameToggle.Value or Toggles.ShowTargetHealthToggle.Value or Toggles.ShowTargetDistanceToggle.Value or Toggles.ShowTargetCategoryToggle.Value
            if showAnyInfo then
                local player = Players:GetPlayerFromCharacter(currentTargetCharacter)
                local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = currentTargetCharacter:FindFirstChildOfClass("Humanoid")
                if humanoid and localRoot then
                    local targetName = player and player.DisplayName or currentTargetCharacter.Name
                    local health = math.floor(humanoid.Health)
                    local maxHealth = humanoid.MaxHealth
                    local dist = math.floor((localRoot.Position - currentTargetPart.Position).Magnitude)
                    local category = getTargetCategory(currentTargetCharacter)
                    local infoStyle = SilentAimSettings.TargetInfoStyle
                    
                    if infoStyle == "独立面板" then
                        IndependentPanelFrame.Visible = true
                        independent_panel_texts.Name.Visible = Toggles.ShowTargetNameToggle.Value
                        independent_panel_texts.Health.Visible = Toggles.ShowTargetHealthToggle.Value
                        independent_panel_texts.Distance.Visible = Toggles.ShowTargetDistanceToggle.Value
                        independent_panel_texts.Category.Visible = Toggles.ShowTargetCategoryToggle.Value
                        if Toggles.ShowTargetNameToggle.Value then independent_panel_texts.Name.Text = "目标: " .. targetName end
                        if Toggles.ShowTargetHealthToggle.Value then independent_panel_texts.Health.Text = string.format("血量: %d", health) end
                        if Toggles.ShowTargetDistanceToggle.Value then independent_panel_texts.Distance.Text = string.format("距离: %dm", dist) end
                        if Toggles.ShowTargetCategoryToggle.Value then independent_panel_texts.Category.Text = "类别: " .. category end
                    elseif infoStyle == "面板" and IsOnScreen then
                        local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                        local linesDrawn = 0; local lineHeight = 15; local infoPos = RootToViewportPoint + Vector2.new(indicatorRadius + 5, -22)
                        if Toggles.ShowTargetNameToggle.Value then local textObj = panel_info_texts.Name; textObj.Text = targetName; textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetHealthToggle.Value then local textObj = panel_info_texts.Health; textObj.Text = string.format("血量: %d", health); textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetDistanceToggle.Value then local textObj = panel_info_texts.Distance; textObj.Text = string.format("距离: %dm", dist); textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetCategoryToggle.Value then local textObj = panel_info_texts.Category; textObj.Text = "类别: " .. category; textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if linesDrawn > 0 then panel_info_bg.Position = infoPos; panel_info_bg.Size = Vector2.new(120, 10 + (linesDrawn * lineHeight)); panel_info_bg.Visible = true end
                    elseif infoStyle == "头顶" and IsOnScreen then
                        local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                        local linesDrawn = 0; local lineHeight = 15; local base_y = RootToViewportPoint.Y - indicatorRadius - 10
                        if Toggles.ShowTargetNameToggle.Value then local textObj = overhead_info_texts.Name; textObj.Text = string.format("[%s]", targetName); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetHealthToggle.Value then local textObj = overhead_info_texts.Health; textObj.Text = string.format("[%d]", health); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetDistanceToggle.Value then local textObj = overhead_info_texts.Distance; textObj.Text = string.format("[%dm]", dist); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetCategoryToggle.Value then local textObj = overhead_info_texts.Category; textObj.Text = string.format("[%s]", category); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                    end
                end
            end
        elseif isEnabled then
            local infoStyle = SilentAimSettings.TargetInfoStyle
            if infoStyle == "独立面板" then
                IndependentPanelFrame.Visible = true
                independent_panel_texts.Name.Visible = true
                independent_panel_texts.Health.Visible = true
                independent_panel_texts.Distance.Visible = false
                independent_panel_texts.Category.Visible = false
                independent_panel_texts.Name.Text = "状态: 自动索敌中..."
                independent_panel_texts.Health.Text = "目标: 无"
            end
        end

        if Toggles.ShowTracerToggle.Value and isEnabled and currentTargetPart then
            local targetHead = currentTargetCharacter and currentTargetCharacter:FindFirstChild("Head")
            local tracerTargetPosition = (targetHead and targetHead.Position) or currentTargetPart.Position
            local y_offset = SilentAimSettings.Tracer_Y_Offset
            local finalTracerPosition = tracerTargetPosition - Vector3.new(0, y_offset, 0)
            local targetScreenPos, IsOnScreen = getPositionOnScreen(finalTracerPosition)
            tracer_line.Visible = IsOnScreen
            if IsOnScreen then tracer_line.From = Camera.ViewportSize / 2; tracer_line.To = targetScreenPos; tracer_line.Color = Options.TracerColorPicker.Value end
        else
            tracer_line.Visible = false
        end
        
        if Toggles.FOVVisibleToggle.Value then
            if Toggles.FixedFOVToggle.Value then FOVCircleFrame.Position = UDim2.fromScale(0.5, 0.5) else local mousePos = GetMouseLocation(UserInputService); FOVCircleFrame.Position = UDim2.fromOffset(mousePos.X, mousePos.Y) end
        end
    end)
end))

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    if SilentAimSettings.Enabled and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) and currentTargetPart then
        local currentMethod = SilentAimSettings.SilentAimMethod
        local shotOrigin = nil

        if (Method == "FindPartOnRayWithIgnoreList" and currentMethod == Method) or
           (Method == "FindPartOnRayWithWhitelist" and currentMethod == Method) or
           ((Method == "FindPartOnRay" or Method == "findPartOnRay") and currentMethod:lower() == Method:lower()) then
            
            if ValidateArguments(Arguments, ExpectedArguments[Method] or ExpectedArguments["FindPartOnRay"]) then
                shotOrigin = Arguments[2].Origin
                table.insert(recentShots, {origin = shotOrigin, time = tick()})
                if SilentAimSettings.Wallbang then
                    return currentTargetPart, currentTargetPart.Position, currentTargetPart.CFrame.LookVector, currentTargetPart.Material
                end
                Arguments[2] = Ray.new(Arguments[2].Origin, getDirection(Arguments[2].Origin, currentTargetPart.Position))
                return oldNamecall(unpack(Arguments))
            end
        elseif Method == "Raycast" and currentMethod == Method then
            if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                shotOrigin = Arguments[2]
                table.insert(recentShots, {origin = shotOrigin, time = tick()})
                if SilentAimSettings.Wallbang then
                    local direction = getDirection(shotOrigin, currentTargetPart.Position)
                    local wallbangParams = RaycastParams.new()
                    wallbangParams.FilterType = Enum.RaycastFilterType.Include
                    wallbangParams.FilterDescendantsInstances = {currentTargetPart.Parent}
                    local newArgs = {self, shotOrigin, direction, wallbangParams}
                    return oldNamecall(unpack(newArgs))
                end
                Arguments[3] = getDirection(Arguments[2], currentTargetPart.Position)
                return oldNamecall(unpack(Arguments))
            end
        elseif (Method == "ScreenPointToRay" or Method == "ViewportPointToRay") and currentMethod == Method and self == Camera then
            shotOrigin = Camera.CFrame.Position
            local direction = (currentTargetPart.Position - shotOrigin).Unit
            table.insert(recentShots, {origin = shotOrigin, time = tick()})
            return Ray.new(shotOrigin, direction)
        end
    end
    return oldNamecall(...)
end))

local oldIndex
local oldRayNew
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    if self == Mouse and not checkcaller() and SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Mouse.Hit/Target" then
        if currentTargetPart then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
                table.insert(recentShots, {origin = LocalPlayer.Character.Head.Position, time = tick()})
            end
            if Index == "Target" or Index == "target" then
                return currentTargetPart
            elseif Index == "Hit" or Index == "hit" then
                return (SilentAimSettings.MouseHitPrediction and (currentTargetPart.CFrame + (currentTargetPart.Velocity * currentTargetPart.Velocity.magnitude * SilentAimSettings.MouseHitPredictionAmount))) or currentTargetPart.CFrame
            elseif Index == "X" or Index == "x" then
                return self.X
            elseif Index == "Y" or Index == "y" then
                return self.Y
            elseif Index == "UnitRay" then
                return Ray.new(self.Origin, (self.Hit.p - self.Origin.p).Unit)
            end
        end
    end
    return oldIndex(self, Index)
end))

oldRayNew = hookfunction(Ray.new, newcclosure(function(origin, direction)
    if SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Ray" and currentTargetPart and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) then
        table.insert(recentShots, {origin = origin, time = tick()})
        local newDirectionVector = getDirection(origin, currentTargetPart.Position)
        return oldRayNew(origin, newDirectionVector)
    end
    return oldRayNew(origin, direction)
end))

Library:OnUnload(function()
    FOVCircleGui:Destroy()
    if IndependentPanelGui then
        IndependentPanelGui:Destroy()
    end
    if currentHighlight then
        currentHighlight:Destroy()
    end
    if transparencyLoopConnection then
        transparencyLoopConnection:Disconnect()
        transparencyLoopConnection = nil
        restoreCharacterAppearance()
    end
    hideAllVisuals()
    oldNamecall:UnHook()
    oldIndex:UnHook()
    oldRayNew:UnHook()
end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder("UniversalSilentAim/Configs")
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

SaveManager:LoadAutoloadConfig()
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})


local MyButton = LeftGroupBox:AddButton({
    Text = '忍者传奇',---服务器名称
    Func = function()
    local originalUI = Library
        
-- 忍者传奇脚本 - 功能修复版
local redzlib = loadstring(game:HttpGet("https://pastefy.app/5PiSO8oW/raw"))()

local Window = redzlib:MakeWindow({
    Title = "YG SCRIPT - 忍者传奇",
    SubTitle = "by YG - 修复版",
    SaveFolder = "NinjaLegendsYG"
})

-- 所有选项卡
local FarmingTab = Window:MakeTab({"自动刷取", "zap"})
local AutoBuyTab = Window:MakeTab({"自动购买", "shopping-cart"})
local PetsTab = Window:MakeTab({"宠物管理", "paw"})
local PetShopTab = Window:MakeTab({"元素", "fire"})
local TeleportsTab = Window:MakeTab({"传送", "map"})
local MiscTab = Window:MakeTab({"杂项", "tool"})
local MoneyTab = Window:MakeTab({"刷金币", "dollar-sign"})

-- 全局变量初始化
local player = game.Players.LocalPlayer
local isRunning = true

-- 初始化所有开关变量
local Toggles = {
    AutoSwing = false,
    AutoSell = false,
    AutoFullSell = false,
    AutoCollect = false,
    AutoRobotBoss = false,
    AutoEternalBoss = false,
    AutoAncientBoss = false,
    AutoSantaBoss = false,
    AutoAllBosses = false,
    AutoRank = false,
    AutoSword = false,
    AutoBelt = false,
    AutoSkill = false,
    AutoShuriken = false,
    AutoOpenEgg = false,
    AutoEvolve = false,
    AutoBuyTwinBirdies = false,
    FastShuriken = false,
    SlowShuriken = false,
    Invisible = false,
    AntiAFK = true,
    AutoFarmMoney = false
}

-- 存储设置
local Settings = {
    SelectedCrystal = "Crystal",
    SelectedIsland = "Spawn",
    GemValue = 100000,
    CurrentIslandIndex = 1
}

-- ============ 自动刷取选项卡 ============
FarmingTab:AddSection({"基础功能"})

FarmingTab:AddToggle({
    Name = "自动挥刀",
    Description = "自动攻击敌人",
    Default = false,
    Callback = function(Value)
        Toggles.AutoSwing = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoSwing and isRunning do
                    pcall(function()
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            -- 查找正确的攻击事件
                            local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                            local swingEvent = rEvents:FindFirstChild("swingKatanaEvent")
                            
                            if swingEvent then
                                swingEvent:FireServer()
                            elseif player:FindFirstChild("ninjaEvent") then
                                player.ninjaEvent:FireServer("swingKatana")
                            end
                        end
                    end)
                    task.wait(0.1)
                end
            end)
        end
    end
})

FarmingTab:AddToggle({
    Name = "自动出售",
    Description = "自动出售物品",
    Default = false,
    Callback = function(Value)
        Toggles.AutoSell = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoSell and isRunning do
                    pcall(function()
                        if player.Character then
                            -- 寻找出售区域
                            local sellArea = game.Workspace:FindFirstChild("sellAreaCircles")
                            if not sellArea then
                                sellArea = game.Workspace:FindFirstChild("sellAreas")
                            end
                            
                            if sellArea then
                                -- 尝试找到出售区域
                                local area = sellArea:FindFirstChild("sellAreaCircle7")
                                if not area then
                                    area = sellArea:FindFirstChild("sellAreaCircle6")
                                end
                                if not area then
                                    area = sellArea:FindFirstChild("sellAreaCircle5")
                                end
                                
                                if area then
                                    local inner = area:FindFirstChild("circleInner") or area
                                    if inner then
                                        player.Character.HumanoidRootPart.CFrame = inner.CFrame
                                    end
                                end
                            end
                        end
                    end)
                    task.wait(0.2)
                end
            end)
        end
    end
})

FarmingTab:AddToggle({
    Name = "自动收集",
    Description = "自动收集气、金币和宝石",
    Default = false,
    Callback = function(Value)
        Toggles.AutoCollect = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoCollect and isRunning do
                    pcall(function()
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            -- 收集金币和宝石
                            local spawnedCoins = game.Workspace:FindFirstChild("spawnedCoins")
                            if spawnedCoins then
                                for _, islandCoins in pairs(spawnedCoins:GetChildren()) do
                                    if islandCoins:IsA("Folder") then
                                        for _, coin in pairs(islandCoins:GetChildren()) do
                                            if coin:IsA("Model") then
                                                local primaryPart = coin.PrimaryPart
                                                if primaryPart then
                                                    player.Character.HumanoidRootPart.CFrame = primaryPart.CFrame
                                                    task.wait(0.05)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            
                            -- 收集气（蓝瓶）
                            local hoops = game.Workspace:FindFirstChild("Hoops")
                            if hoops then
                                for _, hoop in pairs(hoops:GetChildren()) do
                                    if hoop:IsA("Model") and hoop.Name:find("Chi") then
                                        local primaryPart = hoop.PrimaryPart
                                        if primaryPart then
                                            player.Character.HumanoidRootPart.CFrame = primaryPart.CFrame
                                            task.wait(0.05)
                                        end
                                    end
                                end
                            end
                        end
                    end)
                    task.wait(0.1)
                end
            end)
        end
    end
})

FarmingTab:AddSection({"Boss击杀"})

local Bosses = {
    {Name = "机器人Boss", Value = "AutoRobotBoss", BossName = "RobotBoss"},
    {Name = "不朽Boss", Value = "AutoEternalBoss", BossName = "EternalBoss"},
    {Name = "古代Boss", Value = "AutoAncientBoss", BossName = "AncientMagmaBoss"}, -- 修复：正确的Boss名称
    {Name = "圣诞老人Boss", Value = "AutoSantaBoss", BossName = "Samurai Santa"}, -- 修复：正确的Boss名称
}

for _, boss in ipairs(Bosses) do
    FarmingTab:AddToggle({
        Name = "自动杀" .. boss.Name,
        Default = false,
        Callback = function(Value)
            Toggles[boss.Value] = Value
        end
    })
end

FarmingTab:AddToggle({
    Name = "自动杀全部Boss",
    Description = "循环击杀所有可用的Boss",
    Default = false,
    Callback = function(Value)
        Toggles.AutoAllBosses = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoAllBosses and isRunning do
                    pcall(function()
                        local bossFolder = game.Workspace:FindFirstChild("bossFolder")
                        if bossFolder and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            -- 正确的Boss顺序
                            local bossNames = {"Samurai Santa", "AncientMagmaBoss", "EternalBoss", "RobotBoss"}
                            
                            for _, bossName in ipairs(bossNames) do
                                local boss = bossFolder:FindFirstChild(bossName)
                                if boss and boss:FindFirstChild("HumanoidRootPart") then
                                    player.Character.HumanoidRootPart.CFrame = boss.HumanoidRootPart.CFrame
                                    
                                    -- 攻击Boss
                                    local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                                    local swingEvent = rEvents:FindFirstChild("swingKatanaEvent")
                                    if swingEvent then
                                        swingEvent:FireServer()
                                    end
                                    
                                    task.wait(1)
                                end
                            end
                        end
                    end)
                    task.wait(3)
                end
            end)
        end
    end
})

-- ============ 自动购买选项卡 ============
AutoBuyTab:AddSection({"自动购买"})

local BuyOptions = {
    {Name = "自动买等级", Value = "AutoRank", Event = "buyRank"},
    {Name = "自动买剑", Value = "AutoSword", Event = "buyAllSwords"},
    {Name = "自动买腰带", Value = "AutoBelt", Event = "buyAllBelts"},
    {Name = "自动买技能", Value = "AutoSkill", Event = "buyAllSkills"},
    {Name = "自动买飞镖", Value = "AutoShuriken", Event = "buyAllShurikens"},
}

for _, option in ipairs(BuyOptions) do
    AutoBuyTab:AddToggle({
        Name = option.Name,
        Description = "自动购买" .. option.Name:sub(5),
        Default = false,
        Callback = function(Value)
            Toggles[option.Value] = Value
            if Value then
                task.spawn(function()
                    while Toggles[option.Value] and isRunning do
                        pcall(function()
                            local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                            
                            if option.Event == "buyRank" then
                                -- 购买等级的特殊处理
                                local buyRankEvent = rEvents:FindFirstChild("buyRankEvent")
                                if buyRankEvent then
                                    local islands = {"Ground", "Astral", "Space", "Tundra", "Eternal", "Sandstorm", "Thunderstorm", "Ancient"}
                                    for _, island in ipairs(islands) do
                                        buyRankEvent:FireServer(island)
                                        task.wait(0.1)
                                    end
                                end
                            else
                                -- 其他购买事件
                                local eventName = option.Event .. "Event"
                                local event = rEvents:FindFirstChild(eventName)
                                if event then
                                    event:FireServer()
                                end
                            end
                        end)
                        task.wait(0.5)
                    end
                end)
            end
        end
    })
end

-- ============ 宠物管理选项卡 ============
PetsTab:AddSection({"宠物蛋"})

-- 获取水晶列表（修复：使用游戏中的实际水晶名称）
local crystalOptions = {}
local mapCrystalsFolder = game.Workspace:FindFirstChild("mapCrystalsFolder")
if mapCrystalsFolder then
    for _, crystal in pairs(mapCrystalsFolder:GetChildren()) do
        if crystal:IsA("Model") then
            table.insert(crystalOptions, crystal.Name)
        end
    end
end

if #crystalOptions == 0 then
    crystalOptions = {"Basic", "Legendary", "Mythical", "Eternal", "Golden"}
end

PetsTab:AddDropdown({
    Name = "选择水晶",
    Description = "选择要开启的水晶类型",
    Options = crystalOptions,
    Default = crystalOptions[1],
    Callback = function(Value)
        Settings.SelectedCrystal = Value
    end
})

PetsTab:AddToggle({
    Name = "自动开蛋",
    Description = "自动开启选中的水晶蛋",
    Default = false,
    Callback = function(Value)
        Toggles.AutoOpenEgg = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoOpenEgg and isRunning do
                    pcall(function()
                        local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                        local openCrystalRemote = rEvents:FindFirstChild("openCrystalRemote")
                        
                        if openCrystalRemote then
                            openCrystalRemote:InvokeServer("openCrystal", Settings.SelectedCrystal)
                        end
                    end)
                    task.wait(1)
                end
            end)
        end
    end
})

PetsTab:AddToggle({
    Name = "自动进化",
    Description = "自动进化所有宠物",
    Default = false,
    Callback = function(Value)
        Toggles.AutoEvolve = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoEvolve and isRunning do
                    pcall(function()
                        local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                        local petEvolveEvent = rEvents:FindFirstChild("petEvolveEvent")
                        
                        if petEvolveEvent and player:FindFirstChild("petsFolder") then
                            for _, petType in pairs(player.petsFolder:GetChildren()) do
                                for _, pet in pairs(petType:GetChildren()) do
                                    petEvolveEvent:FireServer("evolvePet", pet.Name)
                                    task.wait(0.2)
                                end
                            end
                        end
                    end)
                    task.wait(5)
                end
            end)
        end
    end
})

PetsTab:AddToggle({
    Name = "自动孵化双元素鸟",
    Description = "自动孵化双元素小鸟",
    Default = false,
    Callback = function(Value)
        Toggles.AutoBuyTwinBirdies = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoBuyTwinBirdies and isRunning do
                    pcall(function()
                        local repStorage = game:GetService("ReplicatedStorage")
                        local cPetShopRemote = repStorage:FindFirstChild("cPetShopRemote")
                        local cPetShopFolder = repStorage:FindFirstChild("cPetShopFolder")
                        
                        if cPetShopRemote and cPetShopFolder then
                            local twinBirdies = cPetShopFolder:FindFirstChild("Twin Element Birdies")
                            if twinBirdies then
                                cPetShopRemote:InvokeServer(twinBirdies)
                            end
                        end
                    end)
                    task.wait(5)
                end
            end)
        end
    end
})

-- ============ 元素选项卡 ============
PetShopTab:AddSection({"元素解锁"})

local Elements = {
    "Inferno",
    "Frost", 
    "Lightning",
    "Shadow",
    "Chaos",
    "Masterful",
    "Eternity",
    "Blazing"
}

for _, element in ipairs(Elements) do
    PetShopTab:AddButton({
        Name = "解锁 " .. element .. " 元素",
        Callback = function()
            pcall(function()
                local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                local elementMasteryEvent = rEvents:FindFirstChild("elementMasteryEvent")
                
                if elementMasteryEvent then
                    elementMasteryEvent:FireServer("buyMastery", element)
                end
            end)
        end
    })
end

-- ============ 传送选项卡 ============
TeleportsTab:AddSection({"岛屿传送"})

-- 获取岛屿列表（修复：使用游戏中的实际岛屿名称）
local islandOptions = {}
local islandUnlockParts = game.Workspace:FindFirstChild("islandUnlockParts")
if islandUnlockParts then
    for _, island in pairs(islandUnlockParts:GetChildren()) do
        if island:IsA("Model") then
            table.insert(islandOptions, island.Name)
        end
    end
end

if #islandOptions == 0 then
    islandOptions = {"Ground", "Astral Island", "Space Island", "Tundra Island", 
                     "Eternal Island", "Sandstorm", "Thunderstorm", "Ancient Inferno Island"}
end

TeleportsTab:AddDropdown({
    Name = "选择岛屿",
    Description = "传送到指定岛屿",
    Options = islandOptions,
    Default = islandOptions[1],
    Callback = function(Value)
        Settings.SelectedIsland = Value
    end
})

TeleportsTab:AddButton({
    Name = "传送到选中的岛屿",
    Callback = function()
        pcall(function()
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local islandUnlockParts = game.Workspace:FindFirstChild("islandUnlockParts")
                if islandUnlockParts then
                    local island = islandUnlockParts:FindFirstChild(Settings.SelectedIsland)
                    if island then
                        local sign = island:FindFirstChild("islandSignPart")
                        if sign then
                            player.Character.HumanoidRootPart.CFrame = sign.CFrame
                            return
                        end
                    end
                end
                
                -- 备用位置
                local backupPositions = {
                    ["Ground"] = CFrame.new(0, 10, 0),
                    ["Astral Island"] = CFrame.new(500, 50, 0),
                    ["Space Island"] = CFrame.new(1000, 100, 0),
                    ["Tundra Island"] = CFrame.new(0, 50, 500),
                    ["Eternal Island"] = CFrame.new(0, 75, 1000),
                    ["Sandstorm"] = CFrame.new(-500, 60, 0),
                    ["Thunderstorm"] = CFrame.new(-1000, 80, 0),
                    ["Ancient Inferno Island"] = CFrame.new(0, 90, -500)
                }
                
                local position = backupPositions[Settings.SelectedIsland]
                if position then
                    player.Character.HumanoidRootPart.CFrame = position
                end
            end
        end)
    end
})

-- ============ 杂项选项卡 ============
MiscTab:AddSection({"游戏功能"})

MiscTab:AddToggle({
    Name = "快速手里剑",
    Description = "增加手里剑飞行速度",
    Default = false,
    Callback = function(Value)
        Toggles.FastShuriken = Value
        if Value then
            task.spawn(function()
                while Toggles.FastShuriken and isRunning do
                    pcall(function()
                        local shurikensFolder = game.Workspace:FindFirstChild("shurikensFolder")
                        if shurikensFolder then
                            for _, shuriken in pairs(shurikensFolder:GetChildren()) do
                                if shuriken.Name == "Handle" then
                                    local bodyVelocity = shuriken:FindFirstChildOfClass("BodyVelocity")
                                    if bodyVelocity then
                                        bodyVelocity.Velocity = bodyVelocity.Velocity * 2
                                    end
                                end
                            end
                        end
                    end)
                    task.wait(0.1)
                end
            end)
        end
    end
})

MiscTab:AddToggle({
    Name = "隐身模式",
    Description = "进入隐身状态",
    Default = false,
    Callback = function(Value)
        Toggles.Invisible = Value
        if Value then
            task.spawn(function()
                while Toggles.Invisible and isRunning do
                    pcall(function()
                        local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                        local invisibilityEvent = rEvents:FindFirstChild("invisibilityEvent")
                        
                        if invisibilityEvent then
                            invisibilityEvent:FireServer("activate")
                        end
                    end)
                    task.wait(10)
                end
            end)
        end
    end
})

MiscTab:AddToggle({
    Name = "防AFK",
    Description = "防止因挂机被踢出",
    Default = true,
    Callback = function(Value)
        Toggles.AntiAFK = Value
    end
})

MiscTab:AddButton({
    Name = "收集所有宝箱",
    Callback = function()
        pcall(function()
            if player.Character then
                local chestTypes = {
                    "mythicalChest", "goldenChest", "enchantedChest", "magmaChest",
                    "legendsChest", "eternalChest", "saharaChest", "thunderChest",
                    "ancientChest", "midnightShadowChest"
                }
                
                for _, chestName in ipairs(chestTypes) do
                    local chest = game.Workspace:FindFirstChild(chestName)
                    if chest then
                        local circleInner = chest:FindFirstChild("circleInner")
                        if circleInner then
                            player.Character.HumanoidRootPart.CFrame = circleInner.CFrame
                            task.wait(2.5)
                        end
                    end
                end
            end
        end)
    end
})

-- ============ 刷金币选项卡 ============
MoneyTab:AddParagraph({"使用说明", "第一步：点击初始化\n第二步：设置金币数值\n第三步：开启自动刷取"})
MoneyTab:AddParagraph({"警告", "使用此功能可能导致账号异常，请谨慎使用！"})

MoneyTab:AddButton({
    Name = "金币系统初始化",
    Callback = function()
        pcall(function()
            local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
            local zenMasterEvent = rEvents:FindFirstChild("zenMasterEvent")
            
            if zenMasterEvent then
                zenMasterEvent:FireServer("convertGems", -999999999)
            end
        end)
    end
})

MoneyTab:AddTextBox({
    Name = "设置金币数值",
    Default = "100000",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            Settings.GemValue = num
        end
    end
})

MoneyTab:AddToggle({
    Name = "自动刷金币",
    Description = "自动转换宝石为金币",
    Default = false,
    Callback = function(Value)
        Toggles.AutoFarmMoney = Value
        if Value then
            task.spawn(function()
                while Toggles.AutoFarmMoney and isRunning do
                    pcall(function()
                        local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                        local zenMasterEvent = rEvents:FindFirstChild("zenMasterEvent")
                        
                        if zenMasterEvent then
                            zenMasterEvent:FireServer("convertGems", Settings.GemValue)
                        end
                    end)
                    task.wait(0.5)
                end
            end)
        end
    end
})

-- ============ 防AFK系统 ============
task.spawn(function()
    while isRunning do
        if Toggles.AntiAFK then
            pcall(function()
                local vu = game:GetService("VirtualUser")
                vu:CaptureController()
                vu:ClickButton2(Vector2.new())
            end)
        end
        task.wait(60)
    end
end)

-- ============ Boss自动击杀系统 ============
for _, boss in ipairs(Bosses) do
    task.spawn(function()
        while isRunning do
            if Toggles[boss.Value] then
                pcall(function()
                    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local bossFolder = game.Workspace:FindFirstChild("bossFolder")
                        if bossFolder then
                            local bossObj = bossFolder:FindFirstChild(boss.BossName)
                            if bossObj and bossObj:FindFirstChild("HumanoidRootPart") then
                                player.Character.HumanoidRootPart.CFrame = bossObj.HumanoidRootPart.CFrame
                                
                                -- 攻击Boss
                                local rEvents = game:GetService("ReplicatedStorage"):WaitForChild("rEvents")
                                local swingEvent = rEvents:FindFirstChild("swingKatanaEvent")
                                if swingEvent then
                                    swingEvent:FireServer()
                                end
                                
                                task.wait(0.5)
                            end
                        end
                    end
                end)
            end
            task.wait(0.1)
        end
    end)
end

-- 游戏关闭时清理
game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        isRunning = false
    end
end)

print("========== YG脚本已加载完成 ==========")
print("脚本版本: 修复版")
print("作者: YG")
print("祝您游戏愉快！")
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})

local MyButton = LeftGroupBox:AddButton({
    Text = '通用自瞄',---服务器名称
    Func = function()
    local originalUI = Library
        
loadstring(game:HttpGet("https://raw.githubusercontent.com/Pixeluted/adoniscries/main/Source.lua", true))()

if not game:IsLoaded() then
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

local SilentAimSettings = {
    Enabled = false,
    ClassName = "Universal Silent Aim",
    ToggleKey = "RightAlt",
    TeamCheck = false,
    VisibleCheck = false,
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    FOVVisible = true,
    ShowSilentAimTarget = false,
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100,
    HeadshotChanceEnabled = false,
    HeadshotChance = 0,
    FixedFOV = true,
    TargetIndicatorRadius = 20,
    CrosshairLength = 30,
    CrosshairGap = 5,
    IndicatorRotationEnabled = false,
    IndicatorRotationSpeed = 1,
    IndicatorRainbowEnabled = false,
    IndicatorRainbowSpeed = 1,
    MaxDistance = 500,
    PriorityMode = "准星最近",
    TargetInfoStyle = "面板",
    ShowTargetName = true,
    ShowTargetHealth = true,
    ShowTargetDistance = true,
    ShowTargetCategory = false,
    ShowDamageNotifier = false,
    HighlightEnabled = false,
    HighlightRainbowEnabled = false,
    HighlightColor = Color3.fromRGB(255, 255, 0),
    IndependentPanelPosition = "200,200",
    IndependentPanelPinned = false,
    LeakAndHitMode = false,
    Wallbang = false,
    EnableNameTargeting = false,
    WhitelistedNames = {},
    BlacklistedNames = {},
    ShowTracer = false,
    Tracer_Y_Offset = 0,
    WhitelistPath = {},
    IndicatorBreathingEnabled = true,
    IndicatorBreathingSpeed = 1,
    IndicatorBreathingMin = 0.8,
    IndicatorBreathingMax = 1.2,
    ThreeLineCrosshairEnabled = true,
    ThreeLineCrosshairLength = 30,
    ThreeLineCrosshairGap = 5
}

getgenv().SilentAimSettings = SilentAimSettings
local MainFileName = "UniversalSilentAim"

local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local Debris = game:GetService("Debris")
local CoreGui = game:GetService("CoreGui")
local PathfindingService = game:GetService("PathfindingService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetPlayers = Players.GetPlayers
local WorldToViewportPoint = Camera.WorldToViewportPoint
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume
local create = coroutine.create

local ValidTargetParts = {"Head", "HumanoidRootPart"}
local PredictionAmount = 0.165

local currentTargetPart = nil
local currentHighlight = nil
local currentRotationAngle = 0
local currentIndicatorHue = 0
local npcList = {}
local targetMap = {}
local avatarCache = {}
local recentShots = {}
local pendingDamage = {}

local lockedTargetObject = nil

local target_indicator_circle = Drawing.new("Circle")
target_indicator_circle.Visible = false; target_indicator_circle.ZIndex = 1000; target_indicator_circle.Thickness = 2; target_indicator_circle.Filled = false
local target_indicator_lines = {}
for i = 1, 5 do local line = Drawing.new("Line"); line.Visible = false; line.ZIndex = 1000; line.Thickness = 2; table.insert(target_indicator_lines, line) end
local tracer_line = Drawing.new("Line")
tracer_line.Visible = false; tracer_line.ZIndex = 998; tracer_line.Color = Color3.fromRGB(255, 255, 0); tracer_line.Thickness = 1; tracer_line.Transparency = 1

local overhead_info_texts = {
    Name = Drawing.new("Text"),
    Health = Drawing.new("Text"),
    Distance = Drawing.new("Text"),
    Category = Drawing.new("Text")
}
for _, text in pairs(overhead_info_texts) do
    text.Visible = false; text.ZIndex = 1001; text.Font = Drawing.Fonts.Plex; text.Size = 14; text.Color = Color3.fromRGB(255, 255, 255); text.Center = true; text.Outline = true
end

local panel_info_bg = Drawing.new("Square")
panel_info_bg.Visible = false; panel_info_bg.ZIndex = 1002; panel_info_bg.Color = Color3.fromRGB(0, 0, 0); panel_info_bg.Thickness = 0; panel_info_bg.Filled = true; panel_info_bg.Transparency = 0.5
local panel_info_texts = {
    Name = Drawing.new("Text"),
    Health = Drawing.new("Text"),
    Distance = Drawing.new("Text"),
    Category = Drawing.new("Text")
}
for _, text in pairs(panel_info_texts) do
    text.Visible = false; text.ZIndex = 1003; text.Font = Drawing.Fonts.Plex; text.Size = 14; text.Color = Color3.fromRGB(255, 255, 255); text.Center = false; text.Outline = true
end

local FOVCircleGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
FOVCircleGui.Name = "FOVCircleGui"; FOVCircleGui.ResetOnSpawn = false; FOVCircleGui.IgnoreGuiInset = true; FOVCircleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
local FOVCircleFrame = Instance.new("Frame", FOVCircleGui)
FOVCircleFrame.Name = "FOVCircleFrame"; FOVCircleFrame.AnchorPoint = Vector2.new(0.5, 0.5); FOVCircleFrame.Position = UDim2.fromScale(0.5, 0.5); FOVCircleFrame.BackgroundTransparency = 1
local FOVStroke = Instance.new("UIStroke", FOVCircleFrame)
FOVStroke.Name = "FOVStroke"; FOVStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; FOVStroke.Thickness = 1; FOVStroke.Transparency = 0.5
local FOVCorner = Instance.new("UICorner", FOVCircleFrame)
FOVCorner.Name = "FOVCorner"; FOVCorner.CornerRadius = UDim.new(1, 0)

local IndependentPanelGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
IndependentPanelGui.Name = "IndependentPanelGui"; IndependentPanelGui.ResetOnSpawn = false; IndependentPanelGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
local IndependentPanelFrame = Instance.new("Frame", IndependentPanelGui)
IndependentPanelFrame.Name = "PanelFrame"; IndependentPanelFrame.Size = UDim2.fromOffset(160, 100);
IndependentPanelFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30); IndependentPanelFrame.BackgroundTransparency = 0.3; IndependentPanelFrame.BorderSizePixel = 1; IndependentPanelFrame.BorderColor3 = Color3.new(1,1,1)
IndependentPanelFrame.Visible = false; IndependentPanelFrame.Active = true
local IPCorner = Instance.new("UICorner", IndependentPanelFrame); IPCorner.CornerRadius = UDim.new(0, 4)
local IPListLayout = Instance.new("UIListLayout", IndependentPanelFrame)
IPListLayout.Padding = UDim.new(0, 5); IPListLayout.SortOrder = Enum.SortOrder.LayoutOrder; IPListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; IPListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

local independent_panel_texts = {}
for i, name in ipairs({"Name", "Health", "Distance", "Category"}) do
    local label = Instance.new("TextLabel", IndependentPanelFrame)
    label.Name = name; label.Size = UDim2.new(1, -10, 0, 15); label.BackgroundTransparency = 1
    label.Font = Enum.Font.SourceSans; label.TextSize = 14; label.TextColor3 = Color3.new(1,1,1); label.TextXAlignment = Enum.TextXAlignment.Left; label.LayoutOrder = i
    independent_panel_texts[name] = label
end
IndependentPanelFrame.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 and IndependentPanelFrame.Draggable then IndependentPanelFrame.Position = UDim2.fromOffset(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) end end)
IndependentPanelFrame.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 and IndependentPanelFrame.Draggable then SilentAimSettings.IndependentPanelPosition = IndependentPanelFrame.Position.X.Offset .. "," .. IndependentPanelFrame.Position.Y.Offset end end)

local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean", "boolean"} },
    FindPartOnRayWithWhitelist = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean"} },
    FindPartOnRay = { ArgCountRequired = 2, Args = {"Instance", "Ray", "Instance", "boolean", "boolean"} },
    Raycast = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }
}

local HitSounds = {
    ["bell"] = "rbxassetid://8679627751",
    ["metal"] = "rbxassetid://3125624765",
    ["click"] = "rbxassetid://17755696142",
    ["exp"] = "rbxassetid://10070796384"
}

local rainbowColor = Color3.fromHSV(0, 1, 1)
task.spawn(function()
    while task.wait() do
        if Library and Library.Unloaded then break end
        local hue = (tick() % 6) / 6
        rainbowColor = Color3.fromHSV(hue, 1, 1)
    end
end)

local function playHitSound(soundId)
    local sound = Instance.new("Sound")
    sound.Parent = CoreGui
    sound.SoundId = soundId
    sound.Volume = 0.6
    sound:Play()
    Debris:AddItem(sound, sound.TimeLength + 0.2)
end

function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    return math.random() <= Percentage / 100
end

do
    if not isfolder(MainFileName) then makefolder(MainFileName) end
    if not isfolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) then makefolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) end
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToViewportPoint(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then return false end
    for Pos, Argument in next, Args do if typeof(Argument) == RayMethod.Args[Pos] then Matches = Matches + 1 end end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function isNPC(obj)
    return obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj.Humanoid.Health > 0 and obj:FindFirstChild("HumanoidRootPart") and not Players:GetPlayerFromCharacter(obj)
end

function getTargetCategory(character)
    if not character then return "无" end

    if Players:GetPlayerFromCharacter(character) then
        return "玩家"
    end

    if SilentAimSettings.EnableNameTargeting then
        local name = character.Name:lower()
        for _, whitelistedName in ipairs(SilentAimSettings.WhitelistedNames) do
            if whitelistedName and whitelistedName ~= "" and string.find(name, whitelistedName:lower(), 1, true) then
                return "添加的"
            end
        end
    end
    
    for _, path in ipairs(SilentAimSettings.WhitelistPath) do
        local obj = workspace:FindFirstChild(path)
        if obj and obj == character then
            return "路径白名单"
        end
    end
    
    if character:FindFirstChild("Humanoid") then
         return "NPC"
    end

    return "未知"
end

local function updateNPCs()
    local newNpcList = {}
    local addedNpcs = {}

    if SilentAimSettings.EnableNameTargeting and #SilentAimSettings.WhitelistedNames > 0 then
        for _, model in ipairs(workspace:GetDescendants()) do
            if isNPC(model) then
                for _, substring in ipairs(SilentAimSettings.WhitelistedNames) do
                    if substring and substring ~= "" and string.find(model.Name:lower(), substring:lower(), 1, true) then
                        if not addedNpcs[model] then
                            table.insert(newNpcList, model)
                            addedNpcs[model] = true
                            break
                        end
                    end
                end
            end
        end
    end

    for _, path in ipairs(SilentAimSettings.WhitelistPath) do
        local obj = workspace:FindFirstChild(path)
        if obj and isNPC(obj) and not addedNpcs[obj] then
            table.insert(newNpcList, obj)
            addedNpcs[obj] = true
        end
    end

    for _, v in ipairs(workspace:GetChildren()) do
        if isNPC(v) then
            if not addedNpcs[v] then
                table.insert(newNpcList, v)
                addedNpcs[v] = true
            end
        end
    end
    
    npcList = newNpcList
end

local function isBlacklisted(name)
    local lowerName = name:lower()
    for _, blacklistedName in ipairs(SilentAimSettings.BlacklistedNames) do
        if blacklistedName:lower() == lowerName then
            return true
        end
    end
    return false
end

local function isPartVisible(part, customOrigin)
    if not part then return false end
    local localCharacter = LocalPlayer.Character
    if not localCharacter then return false end
    local origin = customOrigin or Camera.CFrame.Position
    local direction = part.Position - origin
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {localCharacter, part.Parent}
    local raycastResult = workspace:Raycast(origin, direction.Unit * direction.Magnitude, raycastParams)
    return not raycastResult
end

local function getClosestPlayer()
    local LocalPlayerCharacter = LocalPlayer.Character
    if not LocalPlayerCharacter or not LocalPlayerCharacter:FindFirstChild("HumanoidRootPart") then return nil end
    local localRoot = LocalPlayerCharacter.HumanoidRootPart
    
    local AimPoint = SilentAimSettings.FixedFOV and (Camera.ViewportSize / 2) or GetMouseLocation(UserInputService)
    local candidates = {}
    
    for _, Player in ipairs(GetPlayers(Players)) do
        if Player ~= LocalPlayer and not (SilentAimSettings.TeamCheck and Player.Team == LocalPlayer.Team) and not isBlacklisted(Player.Name) then
            local Character = Player.Character
            local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
            if Character and Humanoid and Humanoid.Health > 0 then
                local partForChecks = Character:FindFirstChild(SilentAimSettings.TargetPart) or Character:FindFirstChild("HumanoidRootPart")
                if not partForChecks then continue end

                if not (SilentAimSettings.VisibleCheck and not isPartVisible(partForChecks, LocalPlayerCharacter.Head.Position)) then
                    local physicalDist = (localRoot.Position - partForChecks.Position).Magnitude
                    if physicalDist <= SilentAimSettings.MaxDistance then
                        if SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
                            table.insert(candidates, {character = Character, fov = math.huge, dist = physicalDist, health = Humanoid.Health})
                        else
                            local ScreenPosition, OnScreen = getPositionOnScreen(partForChecks.Position)
                            if OnScreen then
                                local fovDist = (AimPoint - ScreenPosition).Magnitude
                                if fovDist <= SilentAimSettings.FOVRadius then
                                    table.insert(candidates, {character = Character, fov = fovDist, dist = physicalDist, health = Humanoid.Health})
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if #candidates == 0 then return nil end
    table.sort(candidates, function(a, b)
        if SilentAimSettings.PriorityMode == "最低血量" then
            return a.health < b.health
        elseif SilentAimSettings.PriorityMode == "距离最近" or SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
            return a.dist < b.dist
        else
            return a.fov < b.fov
        end
    end)
    return candidates[1].character
end

local function getNPCTarget()
    local LocalPlayerCharacter = LocalPlayer.Character
    if not LocalPlayerCharacter or not LocalPlayerCharacter:FindFirstChild("HumanoidRootPart") then return nil end
    local localRoot = LocalPlayerCharacter.HumanoidRootPart

    local AimPoint = SilentAimSettings.FixedFOV and (Camera.ViewportSize / 2) or GetMouseLocation(UserInputService)
    local candidates = {}

    for _, NPCModel in ipairs(npcList) do
        if not (SilentAimSettings.TeamCheck and NPCModel.Team and NPCModel.Team == LocalPlayer.Team) and not isBlacklisted(NPCModel.Name) then
            local Humanoid = NPCModel and NPCModel:FindFirstChildOfClass("Humanoid")
            if NPCModel and Humanoid and Humanoid.Health > 0 then
                local partForChecks = NPCModel:FindFirstChild(SilentAimSettings.TargetPart) or NPCModel.PrimaryPart or NPCModel:FindFirstChild("HumanoidRootPart")
                if not partForChecks then continue end

                if not (SilentAimSettings.VisibleCheck and not isPartVisible(partForChecks, LocalPlayerCharacter.Head.Position)) then
                    local physicalDist = (localRoot.Position - partForChecks.Position).Magnitude
                    if physicalDist <= SilentAimSettings.MaxDistance then
                         if SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
                            table.insert(candidates, {character = NPCModel, fov = math.huge, dist = physicalDist, health = Humanoid.Health})
                        else
                            local ScreenPosition, OnScreen = getPositionOnScreen(partForChecks.Position)
                            if OnScreen then
                                local fovDist = (AimPoint - ScreenPosition).Magnitude
                                if fovDist <= SilentAimSettings.FOVRadius then
                                    table.insert(candidates, {character = NPCModel, fov = fovDist, dist = physicalDist, health = Humanoid.Health})
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if #candidates == 0 then return nil end
    table.sort(candidates, function(a, b)
        if SilentAimSettings.PriorityMode == "最低血量" then
            return a.health < b.health
        elseif SilentAimSettings.PriorityMode == "距离最近" or SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
            return a.dist < b.dist
        else
            return a.fov < b.fov
        end
    end)
    return candidates[1].character
end

function getPolygonPoints(center, radius, sides)
    local points = {}
    local rotationOffset = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
    for i = 1, sides do
        local angle = (i - 1) * (2 * math.pi / sides) - (math.pi / 2) + rotationOffset
        table.insert(points, Vector2.new(center.X + radius * math.cos(angle), center.Y + radius * math.sin(angle)))
    end
    return points
end

function hideAllVisuals()
    target_indicator_circle.Visible = false
    for _, line in ipairs(target_indicator_lines) do line.Visible = false end
    for _, text in pairs(overhead_info_texts) do text.Visible = false end
    panel_info_bg.Visible = false
    for _, text in pairs(panel_info_texts) do text.Visible = false end
    if IndependentPanelFrame then IndependentPanelFrame.Visible = false end
end

local repo = "https://raw.githubusercontent.com/SyndromeXph/NOL-Obsidian/refs/heads/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

local Window = Library:CreateWindow({ Title = "通用 Slient Aim", Footer = "Yuxin", Center = true, AutoShow = true })

local Tabs = {
    Main = Window:AddTab("主页", "user"),
    Visuals = Window:AddTab("视觉", "camera"),
    Management = Window:AddTab("管理", "users"),
    Misc = Window:AddTab("杂项", "box"),
    ["UI Settings"] = Window:AddTab("UI设置", "settings"),
}

local MainSettingsBox = Tabs.Main:AddLeftGroupbox("主设置")
MainSettingsBox:AddToggle("EnabledToggle", { Text = "启用", Default = SilentAimSettings.Enabled }):AddKeyPicker("EnabledKeybind", { Default = SilentAimSettings.ToggleKey, SyncToggleState = true, Mode = "Toggle" })
Toggles.EnabledToggle:OnChanged(function(Value) SilentAimSettings.Enabled = Value end)
MainSettingsBox:AddToggle("TeamCheckToggle", { Text = "队伍检查", Default = SilentAimSettings.TeamCheck }):OnChanged(function(Value) SilentAimSettings.TeamCheck = Value end)
MainSettingsBox:AddToggle("VisibleCheckToggle", { Text = "可见性检查", Default = SilentAimSettings.VisibleCheck }):OnChanged(function(Value) SilentAimSettings.VisibleCheck = Value end)
MainSettingsBox:AddToggle("WallbangToggle", { Text = "穿墙", Default = SilentAimSettings.Wallbang}):OnChanged(function(Value) SilentAimSettings.Wallbang = Value end)
MainSettingsBox:AddToggle("LeakAndHitToggle", { Text = "漏打模式", Default = SilentAimSettings.LeakAndHitMode}):OnChanged(function(Value) SilentAimSettings.LeakAndHitMode = Value end)
MainSettingsBox:AddSlider('HitChanceSlider', { Text = '命中率', Default = SilentAimSettings.HitChance, Min = 0, Max = 100, Rounding = 1, Suffix = "%" }):OnChanged(function(Value) SilentAimSettings.HitChance = Value end)

local TargetingBox = Tabs.Main:AddRightGroupbox("目标")
TargetingBox:AddDropdown("TargetModeDropdown", { Text = "目标种类", Default = "请选择", Values = {"玩家", "NPC", "所有"} }):OnChanged(function(Value) SilentAimSettings.TargetMode = Value end)
TargetingBox:AddDropdown("TargetPartDropdown", { Values = {"Head", "HumanoidRootPart", "Random"}, Default = SilentAimSettings.TargetPart, Text = "目标部位" }):OnChanged(function(Value) SilentAimSettings.TargetPart = Value end)
TargetingBox:AddDropdown("PriorityModeDropdown", { Text = "优先模式", Default = SilentAimSettings.PriorityMode, Values = {"准星最近", "距离最近", "最低血量", "最近的人(无FOV)"} }):OnChanged(function(Value) SilentAimSettings.PriorityMode = Value end)
TargetingBox:AddSlider('MaxDistanceSlider', { Text = '最大距离', Default = SilentAimSettings.MaxDistance, Min = 10, Max = 2000, Rounding = 0, Suffix = "studs" }):OnChanged(function(Value) SilentAimSettings.MaxDistance = Value end)

local MethodBox = Tabs.Main:AddRightGroupbox("方法")
MethodBox:AddDropdown("MethodDropdown", { Text = "静默瞄准方式", Default = SilentAimSettings.SilentAimMethod, Values = { "Raycast","FindPartOnRay", "FindPartOnRayWithWhitelist", "FindPartOnRayWithIgnoreList", "ScreenPointToRay", "ViewportPointToRay", "Ray", "Mouse.Hit/Target" } }):OnChanged(function(Value) SilentAimSettings.SilentAimMethod = Value end)
MethodBox:AddToggle("PredictionToggle", { Text = "Mouse.Hit/Target 预判", Default = SilentAimSettings.MouseHitPrediction }):OnChanged(function(Value) SilentAimSettings.MouseHitPrediction = Value end)
MethodBox:AddSlider("PredictionAmountSlider", { Text = "预判量", Min = 0, Max = 1, Default = SilentAimSettings.MouseHitPredictionAmount, Rounding = 3 }):OnChanged(function(Value) SilentAimSettings.MouseHitPredictionAmount = Value; PredictionAmount = Value end)
MethodBox:AddToggle("HeadshotChanceToggle", { Text = "启用爆头几率", Default = SilentAimSettings.HeadshotChanceEnabled }):OnChanged(function(Value) SilentAimSettings.HeadshotChanceEnabled = Value end)
MethodBox:AddSlider('HeadshotChanceSlider', { Text = '爆头概率', Default = SilentAimSettings.HeadshotChance, Min = 0, Max = 100, Rounding = 1, Suffix = "%" }):OnChanged(function(Value) SilentAimSettings.HeadshotChance = Value end)

local FovIndicatorBox = Tabs.Visuals:AddLeftGroupbox("范围与指示器")
FovIndicatorBox:AddToggle("FOVVisibleToggle", { Text = "显示FOV圈", Default = SilentAimSettings.FOVVisible }):AddColorPicker("FOVColorPicker", { Default = Color3.fromRGB(54, 57, 241), Title = "FOV圈颜色" })
Toggles.FOVVisibleToggle:OnChanged(function(Value) FOVCircleGui.Enabled = Value; SilentAimSettings.FOVVisible = Value end)
Options.FOVColorPicker:OnChanged(function(Value) FOVStroke.Color = Value end)
FovIndicatorBox:AddSlider("FOVRadiusSlider", { Text = "FOV圈半径", Min = 10, Max = 1000, Default = SilentAimSettings.FOVRadius, Rounding = 0 }):OnChanged(function(Value) FOVCircleFrame.Size = UDim2.fromOffset(Value * 2, Value * 2); SilentAimSettings.FOVRadius = Value end)
FovIndicatorBox:AddToggle("FixedFOVToggle", { Text = "固定FOV (移动端)", Default = SilentAimSettings.FixedFOV }):OnChanged(function(Value) SilentAimSettings.FixedFOV = Value end)
FovIndicatorBox:AddToggle("ShowTargetToggle", { Text = "显示目标", Default = SilentAimSettings.ShowSilentAimTarget }):AddColorPicker("TargetIndicatorColorPicker", { Default = Color3.fromRGB(255,0,0), Title = "指示器颜色" })
Toggles.ShowTargetToggle:OnChanged(function(Value) SilentAimSettings.ShowSilentAimTarget = Value end)
Options.TargetIndicatorColorPicker:OnChanged(function(Value) target_indicator_circle.Color = Value; for _, line in ipairs(target_indicator_lines) do line.Color = Value end end)
FovIndicatorBox:AddDropdown("IndicatorStyleDropdown", { Text = "指示器样式", Values = {"Circle", "Triangle", "Pentagram", "十字准星", "三线准星"}, Default = "Circle" })
FovIndicatorBox:AddSlider("TargetIndicatorRadiusSlider", { Text = "指示器大小(通用)", Min = 5, Max = 50, Default = SilentAimSettings.TargetIndicatorRadius, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.TargetIndicatorRadius = Value end)
FovIndicatorBox:AddSlider("CrosshairLengthSlider", { Text = "十字准星长度", Min = 5, Max = 100, Default = SilentAimSettings.CrosshairLength, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.CrosshairLength = Value end)
FovIndicatorBox:AddSlider("CrosshairGapSlider", { Text = "十字准星间隙", Min = 0, Max = 50, Default = SilentAimSettings.CrosshairGap, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.CrosshairGap = Value end)
FovIndicatorBox:AddToggle("IndicatorRotationToggle", { Text = "指示器旋转", Default = SilentAimSettings.IndicatorRotationEnabled }):OnChanged(function(Value) SilentAimSettings.IndicatorRotationEnabled = Value end)
FovIndicatorBox:AddSlider("IndicatorRotationSpeedSlider", { Text = "旋转速度", Min = 0, Max = 10, Default = SilentAimSettings.IndicatorRotationSpeed, Rounding = 1 }):OnChanged(function(Value) SilentAimSettings.IndicatorRotationSpeed = Value end)
FovIndicatorBox:AddToggle("IndicatorRainbowToggle", { Text = "启用彩虹色", Default = SilentAimSettings.IndicatorRainbowEnabled }):OnChanged(function(Value) SilentAimSettings.IndicatorRainbowEnabled = Value end)
FovIndicatorBox:AddSlider("IndicatorRainbowSpeedSlider", { Text = "颜色变换速度", Min = 0, Max = 10, Default = SilentAimSettings.IndicatorRainbowSpeed, Rounding = 1 }):OnChanged(function(Value) SilentAimSettings.IndicatorRainbowSpeed = Value end)
FovIndicatorBox:AddToggle("IndicatorBreathingToggle", { Text = "启用呼吸效果", Default = SilentAimSettings.IndicatorBreathingEnabled }):OnChanged(function(Value) SilentAimSettings.IndicatorBreathingEnabled = Value end)
FovIndicatorBox:AddSlider("IndicatorBreathingSpeedSlider", { Text = "呼吸速度", Min = 0.1, Max = 5, Default = SilentAimSettings.IndicatorBreathingSpeed, Rounding = 1 }):OnChanged(function(Value) SilentAimSettings.IndicatorBreathingSpeed = Value end)
FovIndicatorBox:AddSlider("IndicatorBreathingMinSlider", { Text = "呼吸最小比例", Min = 0.1, Max = 1, Default = SilentAimSettings.IndicatorBreathingMin, Rounding = 2 }):OnChanged(function(Value) SilentAimSettings.IndicatorBreathingMin = Value end)
FovIndicatorBox:AddSlider("IndicatorBreathingMaxSlider", { Text = "呼吸最大比例", Min = 1, Max = 3, Default = SilentAimSettings.IndicatorBreathingMax, Rounding = 2 }):OnChanged(function(Value) SilentAimSettings.IndicatorBreathingMax = Value end)
FovIndicatorBox:AddToggle("ThreeLineCrosshairToggle", { Text = "启用三线准星", Default = SilentAimSettings.ThreeLineCrosshairEnabled }):OnChanged(function(Value) SilentAimSettings.ThreeLineCrosshairEnabled = Value end)
FovIndicatorBox:AddSlider("ThreeLineCrosshairLengthSlider", { Text = "三线准星长度", Min = 5, Max = 100, Default = SilentAimSettings.ThreeLineCrosshairLength, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.ThreeLineCrosshairLength = Value end)
FovIndicatorBox:AddSlider("ThreeLineCrosshairGapSlider", { Text = "三线准星间隙", Min = 0, Max = 50, Default = SilentAimSettings.ThreeLineCrosshairGap, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.ThreeLineCrosshairGap = Value end)

local InfoBox = Tabs.Visuals:AddRightGroupbox("信息")
InfoBox:AddDropdown("TargetInfoStyleDropdown", { Text = "信息显示样式", Default = SilentAimSettings.TargetInfoStyle, Values = {"面板", "头顶", "独立面板"} }):OnChanged(function(Value) SilentAimSettings.TargetInfoStyle = Value end)
InfoBox:AddToggle("ShowTargetNameToggle", { Text = "显示目标名字", Default = SilentAimSettings.ShowTargetName }):OnChanged(function(Value) SilentAimSettings.ShowTargetName = Value end)
InfoBox:AddToggle("ShowTargetHealthToggle", { Text = "显示目标血量", Default = SilentAimSettings.ShowTargetHealth }):OnChanged(function(Value) SilentAimSettings.ShowTargetHealth = Value end)
InfoBox:AddToggle("ShowTargetDistanceToggle", { Text = "显示目标距离", Default = SilentAimSettings.ShowTargetDistance }):OnChanged(function(Value) SilentAimSettings.ShowTargetDistance = Value end)
InfoBox:AddToggle("ShowTargetCategoryToggle", { Text = "显示目标类别", Default = SilentAimSettings.ShowTargetCategory }):OnChanged(function(Value) SilentAimSettings.ShowTargetCategory = Value end)
InfoBox:AddButton("重置独立面板位置", function()
    SilentAimSettings.IndependentPanelPosition = "200,200"
    local pos = SilentAimSettings.IndependentPanelPosition:split(",")
    IndependentPanelFrame.Position = UDim2.fromOffset(tonumber(pos[1]), tonumber(pos[2]))
end)
InfoBox:AddToggle("PinPanelToggle", {Text = "固定面板", Default = SilentAimSettings.IndependentPanelPinned}):OnChanged(function(value)
    SilentAimSettings.IndependentPanelPinned = value
    IndependentPanelFrame.Draggable = not value
end)

local ExtrasBox = Tabs.Visuals:AddRightGroupbox("额外")
ExtrasBox:AddToggle("HighlightToggle", { Text = "启用高亮", Default = SilentAimSettings.HighlightEnabled }):AddColorPicker("HighlightColorPicker", { Default = SilentAimSettings.HighlightColor, Title = "高亮颜色" })
Toggles.HighlightToggle:OnChanged(function(Value) SilentAimSettings.HighlightEnabled = Value end)
Options.HighlightColorPicker:OnChanged(function(Value) SilentAimSettings.HighlightColor = Value end)
ExtrasBox:AddToggle("HighlightRainbowToggle", { Text = "高亮彩虹色", Default = SilentAimSettings.HighlightRainbowEnabled }):OnChanged(function(Value) SilentAimSettings.HighlightRainbowEnabled = Value end)
ExtrasBox:AddToggle("DamageNotifierToggle", { Text = "显示伤害通知", Default = SilentAimSettings.ShowDamageNotifier }):OnChanged(function(Value) SilentAimSettings.ShowDamageNotifier = Value end)
ExtrasBox:AddDropdown('HitSound', { Text = '击中音效', Default = '关闭', Values = {'关闭', 'bell', 'metal', 'click', 'exp'} })
ExtrasBox:AddToggle("ShowTracerToggle", { Text = "显示目标追踪线", Default = SilentAimSettings.ShowTracer }):AddColorPicker("TracerColorPicker", { Default = tracer_line.Color, Title = "追踪线颜色" })
Toggles.ShowTracerToggle:OnChanged(function(Value) SilentAimSettings.ShowTracer = Value end)
Options.TracerColorPicker:OnChanged(function(Value) tracer_line.Color = Value end)
ExtrasBox:AddSlider('TracerYOffsetSlider', { Text = '追踪线Y轴偏移', Default = SilentAimSettings.Tracer_Y_Offset, Min = -10, Max = 10, Rounding = 3, Suffix = " studs" }):OnChanged(function(Value) SilentAimSettings.Tracer_Y_Offset = Value end)

local ManualLockGroupBox = Tabs.Management:AddLeftGroupbox("手动锁定")
ManualLockGroupBox:AddDropdown("TargetSelectorDropdown", { Text = "锁定目标 (无=自动)", Default = "无", Values = {"无"} }):OnChanged(function(selectedName)
    if selectedName == "无" then
        lockedTargetObject = nil
    else
        lockedTargetObject = targetMap[selectedName]
    end
end)
ManualLockGroupBox:AddButton("刷新列表", function()
    targetMap = {}
    local targetNames = {"无"}
    local targetMode = SilentAimSettings.TargetMode
    
    if targetMode == "NPC" or targetMode == "所有" then
        updateNPCs()
    end
    
    if targetMode == "玩家" or targetMode == "所有" then
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                if not (SilentAimSettings.TeamCheck and player.Team == LocalPlayer.Team) then
                    table.insert(targetNames, player.Name)
                    targetMap[player.Name] = player
                end
            end
        end
    end
    
    if targetMode == "NPC" or targetMode == "所有" then
        for _, npc in ipairs(npcList) do
            if npc and npc.Name and npc.PrimaryPart then
                table.insert(targetNames, npc.Name)
                targetMap[npc.Name] = npc
            end
        end
    end

    Options.TargetSelectorDropdown:SetValues(targetNames, "无")
    lockedTargetObject = nil
end)

local NameTargetingGroup = Tabs.Management:AddLeftGroupbox("名称索敌")
NameTargetingGroup:AddToggle("EnableNameTargetingToggle", { Text = "启用名称索敌", Default = SilentAimSettings.EnableNameTargeting }):OnChanged(function(Value)
    SilentAimSettings.EnableNameTargeting = Value
end)
local whitelistDataOption = NameTargetingGroup:AddInput("WhitelistData", { Text = "Whitelist Internal Data", Default = "[]" })
whitelistDataOption.Visible = false
local function updateWhitelistData()
    local jsonString = HttpService:JSONEncode(SilentAimSettings.WhitelistedNames)
    whitelistDataOption:SetValue(jsonString)
end
NameTargetingGroup:AddInput("WhitelistNameInput", { Text = "名称", PlaceholderText = "输入要锁定的NPC名称关键字" })
NameTargetingGroup:AddButton("添加到列表", function()
    local name = Options.WhitelistNameInput.Value
    if name and name ~= "" then
        table.insert(SilentAimSettings.WhitelistedNames, name)
        Options.WhitelistDropdown:SetValues(SilentAimSettings.WhitelistedNames)
        Options.WhitelistNameInput:SetValue("")
        updateWhitelistData()
    end
end)
NameTargetingGroup:AddDropdown("WhitelistDropdown", { Text = "名称列表", Values = SilentAimSettings.WhitelistedNames or {} })
NameTargetingGroup:AddButton("从列表中删除", function()
    local selectedName = Options.WhitelistDropdown.Value
    if selectedName then
        for i, name in ipairs(SilentAimSettings.WhitelistedNames) do
            if name == selectedName then
                table.remove(SilentAimSettings.WhitelistedNames, i)
                break
            end
        end
        Options.WhitelistDropdown:SetValues(SilentAimSettings.WhitelistedNames)
        updateWhitelistData()
    end
end)
whitelistDataOption:OnChanged(function(jsonString)
    if not jsonString or jsonString == "" then jsonString = "[]" end
    local success, decoded = pcall(HttpService.JSONDecode, HttpService, jsonString)
    if success and type(decoded) == 'table' then
        SilentAimSettings.WhitelistedNames = decoded
        Options.WhitelistDropdown:SetValues(SilentAimSettings.WhitelistedNames)
    end
end)

local WhitelistPathGroup = Tabs.Management:AddLeftGroupbox("白名单路径管理")
WhitelistPathGroup:AddInput("WhitelistPathInput", { Text = "路径", PlaceholderText = "输入从Workspace开始的路径" })
WhitelistPathGroup:AddButton("添加路径", function()
    local path = Options.WhitelistPathInput.Value
    if path and path ~= "" then
        table.insert(SilentAimSettings.WhitelistPath, path)
        Options.WhitelistPathDropdown:SetValues(SilentAimSettings.WhitelistPath)
        Options.WhitelistPathInput:SetValue("")
    end
end)
WhitelistPathGroup:AddDropdown("WhitelistPathDropdown", { Text = "路径列表", Values = SilentAimSettings.WhitelistPath or {} })
WhitelistPathGroup:AddButton("删除路径", function()
    local selectedPath = Options.WhitelistPathDropdown.Value
    if selectedPath then
        for i, p in ipairs(SilentAimSettings.WhitelistPath) do
            if p == selectedPath then
                table.remove(SilentAimSettings.WhitelistPath, i)
                break
            end
        end
        Options.WhitelistPathDropdown:SetValues(SilentAimSettings.WhitelistPath)
    end
end)

local BlacklistGroup = Tabs.Management:AddRightGroupbox("黑名单管理")
local blacklistDataOption = BlacklistGroup:AddInput("BlacklistData", { Text = "Blacklist Internal Data", Default = "[]" })
blacklistDataOption.Visible = false
local function updateBlacklistData()
    local jsonString = HttpService:JSONEncode(SilentAimSettings.BlacklistedNames)
    blacklistDataOption:SetValue(jsonString)
end
BlacklistGroup:AddInput("BlacklistNameInput", { Text = "名称", PlaceholderText = "输入要拉黑的精确名称" })
BlacklistGroup:AddButton("添加到黑名单", function()
    local name = Options.BlacklistNameInput.Value
    if name and name ~= "" and not isBlacklisted(name) then
        table.insert(SilentAimSettings.BlacklistedNames, name)
        Options.BlacklistDropdown:SetValues(SilentAimSettings.BlacklistedNames)
        Options.BlacklistNameInput:SetValue("")
        updateBlacklistData()
    end
end)
BlacklistGroup:AddDropdown("BlacklistDropdown", { Text = "黑名单列表", Values = SilentAimSettings.BlacklistedNames or {} })
BlacklistGroup:AddButton("从黑名单中删除", function()
    local selectedName = Options.BlacklistDropdown.Value
    if selectedName then
        for i, name in ipairs(SilentAimSettings.BlacklistedNames) do
            if name == selectedName then
                table.remove(SilentAimSettings.BlacklistedNames, i)
                break
            end
        end
        Options.BlacklistDropdown:SetValues(SilentAimSettings.BlacklistedNames)
        updateBlacklistData()
    end
end)
blacklistDataOption:OnChanged(function(jsonString)
    if not jsonString or jsonString == "" then jsonString = "[]" end
    local success, decoded = pcall(HttpService.JSONDecode, HttpService, jsonString)
    if success and type(decoded) == 'table' then
        SilentAimSettings.BlacklistedNames = decoded
        Options.BlacklistDropdown:SetValues(SilentAimSettings.BlacklistedNames)
    end
end)

local CharacterModGroup = Tabs.Misc:AddLeftGroupbox("角色修改")
local originalCharacterData = {}
local transparencyLoopConnection = nil
local function restoreCharacterAppearance()
    for part, data in pairs(originalCharacterData) do
        if part and part.Parent then
            part.Material = data.material
            part.Color = data.color
            part.Transparency = data.transparency
        end
    end
    originalCharacterData = {}
end
local function transparencyLoop()
    if not LocalPlayer.Character then
        if next(originalCharacterData) then
            originalCharacterData = {}
        end
        return
    end
    local isRainbowEnabled = Toggles.TransparentCharacterRainbow.Value
    for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") then
            if not originalCharacterData[part] then
                originalCharacterData[part] = {
                    material = part.Material,
                    color = part.Color,
                    transparency = part.Transparency
                }
            end
            part.Material = Enum.Material.ForceField
            if isRainbowEnabled then
                part.Color = rainbowColor
            else
                part.Color = originalCharacterData[part].color
            end
        end
    end
end
CharacterModGroup:AddToggle("TransparentCharacterEnabled", { Text = "人物透明", Default = false }):OnChanged(function(value)
    if value then
        transparencyLoopConnection = RunService.Heartbeat:Connect(transparencyLoop)
    else
        if transparencyLoopConnection then
            transparencyLoopConnection:Disconnect()
            transparencyLoopConnection = nil
        end
        restoreCharacterAppearance()
    end
end)
CharacterModGroup:AddToggle("TransparentCharacterRainbow", { Text = "人物变色", Default = false }):OnChanged(function(value)
    if not value and Toggles.TransparentCharacterEnabled.Value then
        restoreCharacterAppearance()
        task.wait()
        transparencyLoop()
    end
end)

local EntertainmentGroup = Tabs.Misc:AddLeftGroupbox("娱乐")
local spinThread = nil
local spinEnabled = false
local spinSpeed = math.rad(10)
local function spinCharacter()
    while spinEnabled and task.wait() do
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, spinSpeed, 0)
        else
            break
        end
    end
    spinThread = nil
end
EntertainmentGroup:AddToggle("SpinToggle", { Text = "启用旋转", Default = false }):OnChanged(function(value)
    spinEnabled = value
    if spinEnabled and not spinThread then
        spinThread = coroutine.create(spinCharacter)
        coroutine.resume(spinThread)
    end
end)
EntertainmentGroup:AddSlider("SpinSpeedSlider", { Text = "旋转速度", Default = 10, Min = 1, Max = 100, Rounding = 0 }):OnChanged(function(value)
    spinSpeed = math.rad(value)
end)

FOVCircleGui.Enabled = Toggles.FOVVisibleToggle.Value
FOVStroke.Color = Options.FOVColorPicker.Value
FOVCircleFrame.Size = UDim2.fromOffset(Options.FOVRadiusSlider.Value * 2, Options.FOVRadiusSlider.Value * 2)
IndependentPanelFrame.Draggable = not SilentAimSettings.IndependentPanelPinned

task.spawn(function()
    while task.wait(2) do
        if SilentAimSettings.TargetMode == "NPC" or SilentAimSettings.TargetMode == "所有" then
            updateNPCs()
        end
    end
end)

local lastHealthValues = {}
local damageIndicators = {}
local DAMAGE_INDICATOR_FADE_TIME = 1

local pos = SilentAimSettings.IndependentPanelPosition:split(",")
IndependentPanelFrame.Position = UDim2.fromOffset(tonumber(pos[1]), tonumber(pos[2]))

local lastTargetCharacter = nil
local lockedRandomPart = nil

resume(create(function()
    RenderStepped:Connect(function()
        if SilentAimSettings.IndicatorRotationEnabled then currentRotationAngle = (currentRotationAngle + (SilentAimSettings.IndicatorRotationSpeed / 50)) % (math.pi * 2) end
        if SilentAimSettings.IndicatorRainbowEnabled or SilentAimSettings.HighlightRainbowEnabled or (Toggles.TransparentCharacterRainbow and Toggles.TransparentCharacterRainbow.Value) then currentIndicatorHue = (currentIndicatorHue + (SilentAimSettings.IndicatorRainbowSpeed / 200)) % 1 end
        
        local currentTime = tick()
        for i = #recentShots, 1, -1 do
            if currentTime - recentShots[i].time > 1 then
                table.remove(recentShots, i)
            end
        end

        local isEnabled = Toggles.EnabledToggle.Value
        currentTargetPart = nil
        local currentTargetCharacter = nil

        if isEnabled then
            if lockedTargetObject then
                 if lockedTargetObject.Parent and not isBlacklisted(lockedTargetObject.Name) then
                    if lockedTargetObject:IsA("Player") then
                        currentTargetCharacter = lockedTargetObject.Character
                    elseif lockedTargetObject:IsA("Model") then
                        currentTargetCharacter = lockedTargetObject
                    end
                else
                    lockedTargetObject = nil
                    Options.TargetSelectorDropdown:SetValue("无")
                end
            else
                local targetMode = SilentAimSettings.TargetMode
                local playerTarget, npcTarget
                if targetMode == "玩家" or targetMode == "所有" then playerTarget = getClosestPlayer() end
                if targetMode == "NPC" or targetMode == "所有" then npcTarget = getNPCTarget() end

                if playerTarget and npcTarget then
                    local priority = SilentAimSettings.PriorityMode
                    if priority == "最低血量" then
                        local pHumanoid = playerTarget:FindFirstChildOfClass("Humanoid")
                        local nHumanoid = npcTarget:FindFirstChildOfClass("Humanoid")
                        currentTargetCharacter = (pHumanoid and nHumanoid and pHumanoid.Health <= nHumanoid.Health) and playerTarget or npcTarget
                    else
                        local pDist = (LocalPlayer.Character.HumanoidRootPart.Position - playerTarget.HumanoidRootPart.Position).Magnitude
                        local nDist = (LocalPlayer.Character.HumanoidRootPart.Position - npcTarget.HumanoidRootPart.Position).Magnitude
                        currentTargetCharacter = pDist < nDist and playerTarget or npcTarget
                    end
                else
                    currentTargetCharacter = playerTarget or npcTarget
                end
            end
        end

        if currentTargetCharacter ~= lastTargetCharacter then
            lockedRandomPart = nil
        end
        lastTargetCharacter = currentTargetCharacter

        if currentTargetCharacter then
            local humanoid = currentTargetCharacter:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                if lockedTargetObject and lockedTargetObject:IsA("Model") and lockedTargetObject == currentTargetCharacter then
                    lockedTargetObject = nil
                    Options.TargetSelectorDropdown:SetValue("无")
                end
                currentTargetCharacter = nil
                currentTargetPart = nil
            else
                local baseTargetPart = nil
                if SilentAimSettings.LeakAndHitMode then
                    for _, part in ipairs(currentTargetCharacter:GetDescendants()) do
                        if part:IsA("BasePart") and part.Parent == currentTargetCharacter then
                            if isPartVisible(part) then
                                baseTargetPart = part
                                break
                            end
                        end
                    end
                else
                    local targetPartName = SilentAimSettings.TargetPart
                    if targetPartName == "Random" then
                        if not lockedRandomPart or not lockedRandomPart.Parent or lockedRandomPart.Parent ~= currentTargetCharacter then
                            lockedRandomPart = currentTargetCharacter[ValidTargetParts[math.random(1, #ValidTargetParts)]]
                        end
                        baseTargetPart = lockedRandomPart
                    else
                        baseTargetPart = currentTargetCharacter:FindFirstChild(targetPartName) or currentTargetCharacter:FindFirstChild("HumanoidRootPart")
                    end
                end

                if baseTargetPart then
                    if SilentAimSettings.HeadshotChanceEnabled and CalculateChance(SilentAimSettings.HeadshotChance) then
                        local headPart = currentTargetCharacter:FindFirstChild("Head")
                        if headPart then
                            currentTargetPart = headPart
                        else
                            currentTargetPart = baseTargetPart
                        end
                    else
                        currentTargetPart = baseTargetPart
                    end
                else
                    currentTargetPart = nil
                end
            end
        end

        if isEnabled and currentTargetPart then
            local humanoid = currentTargetPart.Parent:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local currentHealth = humanoid.Health
                local lastHealth = lastHealthValues[humanoid]
                if lastHealth and currentHealth < lastHealth then
                    local damage = math.floor(lastHealth - currentHealth)
                    if damage > 0 then
                        if not pendingDamage[humanoid] then
                            pendingDamage[humanoid] = { damage = 0, lastUpdate = tick(), position = currentTargetPart.Position }
                        end
                        pendingDamage[humanoid].damage = pendingDamage[humanoid].damage + damage
                        pendingDamage[humanoid].lastUpdate = tick()
                        pendingDamage[humanoid].position = currentTargetPart.Position

                        local selectedSoundName = Options.HitSound.Value
                        if selectedSoundName ~= '关闭' then
                            local soundId = HitSounds[selectedSoundName]
                            if soundId then
                                playHitSound(soundId)
                            end
                        end
                    end
                end
                lastHealthValues[humanoid] = currentHealth
            end
        end
        
        local DAMAGE_ACCUMULATION_WINDOW = 0.15
        for humanoid, data in pairs(pendingDamage) do
            if currentTime - data.lastUpdate > DAMAGE_ACCUMULATION_WINDOW then
                if SilentAimSettings.ShowDamageNotifier and data.damage > 0 then
                    local screenPos, onScreen = getPositionOnScreen(data.position)
                    if onScreen then
                        local indicator = {};
                        indicator.Created = tick();
                        indicator.Position = screenPos;
                        indicator.TextObject = Drawing.new("Text")
                        indicator.TextObject.Font = Drawing.Fonts.Monospace;
                        indicator.TextObject.Text = string.format("-%d", data.damage)
                        indicator.TextObject.Color = Color3.fromRGB(255, 50, 50);
                        indicator.TextObject.Size = 20
                        indicator.TextObject.Center = true;
                        indicator.TextObject.Outline = true
                        table.insert(damageIndicators, indicator)
                    end
                end
                pendingDamage[humanoid] = nil
            end
        end

        for i = #damageIndicators, 1, -1 do
            local indicator = damageIndicators[i]; local age = tick() - indicator.Created
            if age > DAMAGE_INDICATOR_FADE_TIME then
                indicator.TextObject:Remove(); table.remove(damageIndicators, i)
            else
                local progress = age / DAMAGE_INDICATOR_FADE_TIME
                indicator.TextObject.Position = indicator.Position - Vector2.new(0, progress * 40)
                indicator.TextObject.Transparency = progress; indicator.TextObject.Visible = true
            end
        end

        hideAllVisuals()
        
        if currentHighlight and (not currentTargetCharacter or not SilentAimSettings.HighlightEnabled) then
            currentHighlight:Destroy()
            currentHighlight = nil
        end

        if isEnabled and currentTargetCharacter and SilentAimSettings.HighlightEnabled then
             if not currentHighlight then
                currentHighlight = Instance.new("Highlight")
                currentHighlight.Parent = currentTargetCharacter
            end
            currentHighlight.Adornee = currentTargetCharacter
            currentHighlight.Enabled = true
            currentHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            if SilentAimSettings.HighlightRainbowEnabled then
                local rainbowColor = Color3.fromHSV(currentIndicatorHue, 1, 1)
                currentHighlight.FillColor = rainbowColor
                currentHighlight.OutlineColor = rainbowColor
                currentHighlight.FillTransparency = 0.5
                currentHighlight.OutlineTransparency = 0
            else
                currentHighlight.FillColor = SilentAimSettings.HighlightColor
                currentHighlight.OutlineColor = SilentAimSettings.HighlightColor
                currentHighlight.FillTransparency = 0.5
                currentHighlight.OutlineTransparency = 0
            end
        end

        if isEnabled and currentTargetPart then
            local RootToViewportPoint, IsOnScreen = getPositionOnScreen(currentTargetPart.Position)

            if IsOnScreen and Toggles.ShowTargetToggle.Value then
                local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                local indicatorStyle = Options.IndicatorStyleDropdown.Value
                local finalIndicatorColor; local isTargetVisible = isPartVisible(currentTargetPart)
                if isTargetVisible then finalIndicatorColor = Color3.fromRGB(0, 255, 0); indicatorRadius = indicatorRadius * 0.6
                elseif SilentAimSettings.IndicatorRainbowEnabled then finalIndicatorColor = Color3.fromHSV(currentIndicatorHue, 1, 1)
                else finalIndicatorColor = Options.TargetIndicatorColorPicker.Value end
                
                local breathingScale = 1
                if SilentAimSettings.IndicatorBreathingEnabled then
                    breathingScale = SilentAimSettings.IndicatorBreathingMin + 
                                     (SilentAimSettings.IndicatorBreathingMax - SilentAimSettings.IndicatorBreathingMin) * 
                                     (math.sin(tick() * SilentAimSettings.IndicatorBreathingSpeed * math.pi * 2) * 0.5 + 0.5)
                end
                
                if indicatorStyle == "Circle" then
                    target_indicator_circle.Visible = true; target_indicator_circle.Color = finalIndicatorColor; target_indicator_circle.Radius = indicatorRadius * breathingScale; target_indicator_circle.Position = RootToViewportPoint
                elseif indicatorStyle == "Triangle" then
                    local points = getPolygonPoints(RootToViewportPoint, indicatorRadius * breathingScale, 3)
                    for i = 1, 3 do local line = target_indicator_lines[i]; line.Visible = true; line.Color = finalIndicatorColor; line.From = points[i]; line.To = points[i % 3 + 1] end
                elseif indicatorStyle == "Pentagram" then
                    local points = getPolygonPoints(RootToViewportPoint, indicatorRadius * breathingScale, 5)
                    local pentagram_order = {1, 3, 5, 2, 4}
                    for i = 1, 5 do local line = target_indicator_lines[i]; line.Visible = true; line.Color = finalIndicatorColor; line.From = points[pentagram_order[i]]; line.To = points[pentagram_order[i % 5 + 1]] end
                elseif indicatorStyle == "十字准星" then
                    local length = SilentAimSettings.CrosshairLength * breathingScale
                    local gap = SilentAimSettings.CrosshairGap * breathingScale
                    local center = RootToViewportPoint
                    local rotation = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
                    local cos, sin = math.cos(rotation), math.sin(rotation)

                    local function rotate(v)
                        return Vector2.new(v.X * cos - v.Y * sin, v.X * sin + v.Y * cos)
                    end

                    local points = {
                        {From = rotate(Vector2.new(0, -length)) + center, To = rotate(Vector2.new(0, -gap)) + center},
                        {From = rotate(Vector2.new(0, length)) + center, To = rotate(Vector2.new(0, gap)) + center},
                        {From = rotate(Vector2.new(-length, 0)) + center, To = rotate(Vector2.new(-gap, 0)) + center},
                        {From = rotate(Vector2.new(length, 0)) + center, To = rotate(Vector2.new(gap, 0)) + center}
                    }

                    for i = 1, 4 do
                        target_indicator_lines[i].Visible = true
                        target_indicator_lines[i].Color = finalIndicatorColor
                        target_indicator_lines[i].From = points[i].From
                        target_indicator_lines[i].To = points[i].To
                    end
                elseif indicatorStyle == "三线准星" and SilentAimSettings.ThreeLineCrosshairEnabled then
                    local length = SilentAimSettings.ThreeLineCrosshairLength * breathingScale
                    local gap = SilentAimSettings.ThreeLineCrosshairGap * breathingScale
                    local center = RootToViewportPoint
                    local rotation = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
                    
                    for i = 1, 3 do
                        local angle = rotation + (i - 1) * (math.pi * 2 / 3)
                        local dir = Vector2.new(math.cos(angle), math.sin(angle))
                        local start = center + dir * gap
                        local endPos = center + dir * length
                        
                        target_indicator_lines[i].Visible = true
                        target_indicator_lines[i].Color = finalIndicatorColor
                        target_indicator_lines[i].From = start
                        target_indicator_lines[i].To = endPos
                    end
                end
            end

            local showAnyInfo = Toggles.ShowTargetNameToggle.Value or Toggles.ShowTargetHealthToggle.Value or Toggles.ShowTargetDistanceToggle.Value or Toggles.ShowTargetCategoryToggle.Value
            if showAnyInfo then
                local player = Players:GetPlayerFromCharacter(currentTargetCharacter)
                local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = currentTargetCharacter:FindFirstChildOfClass("Humanoid")
                if humanoid and localRoot then
                    local targetName = player and player.DisplayName or currentTargetCharacter.Name
                    local health = math.floor(humanoid.Health)
                    local maxHealth = humanoid.MaxHealth
                    local dist = math.floor((localRoot.Position - currentTargetPart.Position).Magnitude)
                    local category = getTargetCategory(currentTargetCharacter)
                    local infoStyle = SilentAimSettings.TargetInfoStyle
                    
                    if infoStyle == "独立面板" then
                        IndependentPanelFrame.Visible = true
                        independent_panel_texts.Name.Visible = Toggles.ShowTargetNameToggle.Value
                        independent_panel_texts.Health.Visible = Toggles.ShowTargetHealthToggle.Value
                        independent_panel_texts.Distance.Visible = Toggles.ShowTargetDistanceToggle.Value
                        independent_panel_texts.Category.Visible = Toggles.ShowTargetCategoryToggle.Value
                        if Toggles.ShowTargetNameToggle.Value then independent_panel_texts.Name.Text = "目标: " .. targetName end
                        if Toggles.ShowTargetHealthToggle.Value then independent_panel_texts.Health.Text = string.format("血量: %d", health) end
                        if Toggles.ShowTargetDistanceToggle.Value then independent_panel_texts.Distance.Text = string.format("距离: %dm", dist) end
                        if Toggles.ShowTargetCategoryToggle.Value then independent_panel_texts.Category.Text = "类别: " .. category end
                    elseif infoStyle == "面板" and IsOnScreen then
                        local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                        local linesDrawn = 0; local lineHeight = 15; local infoPos = RootToViewportPoint + Vector2.new(indicatorRadius + 5, -22)
                        if Toggles.ShowTargetNameToggle.Value then local textObj = panel_info_texts.Name; textObj.Text = targetName; textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetHealthToggle.Value then local textObj = panel_info_texts.Health; textObj.Text = string.format("血量: %d", health); textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetDistanceToggle.Value then local textObj = panel_info_texts.Distance; textObj.Text = string.format("距离: %dm", dist); textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetCategoryToggle.Value then local textObj = panel_info_texts.Category; textObj.Text = "类别: " .. category; textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if linesDrawn > 0 then panel_info_bg.Position = infoPos; panel_info_bg.Size = Vector2.new(120, 10 + (linesDrawn * lineHeight)); panel_info_bg.Visible = true end
                    elseif infoStyle == "头顶" and IsOnScreen then
                        local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                        local linesDrawn = 0; local lineHeight = 15; local base_y = RootToViewportPoint.Y - indicatorRadius - 10
                        if Toggles.ShowTargetNameToggle.Value then local textObj = overhead_info_texts.Name; textObj.Text = string.format("[%s]", targetName); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetHealthToggle.Value then local textObj = overhead_info_texts.Health; textObj.Text = string.format("[%d]", health); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetDistanceToggle.Value then local textObj = overhead_info_texts.Distance; textObj.Text = string.format("[%dm]", dist); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        if Toggles.ShowTargetCategoryToggle.Value then local textObj = overhead_info_texts.Category; textObj.Text = string.format("[%s]", category); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                    end
                end
            end
        elseif isEnabled then
            local infoStyle = SilentAimSettings.TargetInfoStyle
            if infoStyle == "独立面板" then
                IndependentPanelFrame.Visible = true
                independent_panel_texts.Name.Visible = true
                independent_panel_texts.Health.Visible = true
                independent_panel_texts.Distance.Visible = false
                independent_panel_texts.Category.Visible = false
                independent_panel_texts.Name.Text = "状态: 自动索敌中..."
                independent_panel_texts.Health.Text = "目标: 无"
            end
        end

        if Toggles.ShowTracerToggle.Value and isEnabled and currentTargetPart then
            local targetHead = currentTargetCharacter and currentTargetCharacter:FindFirstChild("Head")
            local tracerTargetPosition = (targetHead and targetHead.Position) or currentTargetPart.Position
            local y_offset = SilentAimSettings.Tracer_Y_Offset
            local finalTracerPosition = tracerTargetPosition - Vector3.new(0, y_offset, 0)
            local targetScreenPos, IsOnScreen = getPositionOnScreen(finalTracerPosition)
            tracer_line.Visible = IsOnScreen
            if IsOnScreen then tracer_line.From = Camera.ViewportSize / 2; tracer_line.To = targetScreenPos; tracer_line.Color = Options.TracerColorPicker.Value end
        else
            tracer_line.Visible = false
        end
        
        if Toggles.FOVVisibleToggle.Value then
            if Toggles.FixedFOVToggle.Value then FOVCircleFrame.Position = UDim2.fromScale(0.5, 0.5) else local mousePos = GetMouseLocation(UserInputService); FOVCircleFrame.Position = UDim2.fromOffset(mousePos.X, mousePos.Y) end
        end
    end)
end))

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    if SilentAimSettings.Enabled and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) and currentTargetPart then
        local currentMethod = SilentAimSettings.SilentAimMethod
        local shotOrigin = nil

        if (Method == "FindPartOnRayWithIgnoreList" and currentMethod == Method) or
           (Method == "FindPartOnRayWithWhitelist" and currentMethod == Method) or
           ((Method == "FindPartOnRay" or Method == "findPartOnRay") and currentMethod:lower() == Method:lower()) then
            
            if ValidateArguments(Arguments, ExpectedArguments[Method] or ExpectedArguments["FindPartOnRay"]) then
                shotOrigin = Arguments[2].Origin
                table.insert(recentShots, {origin = shotOrigin, time = tick()})
                if SilentAimSettings.Wallbang then
                    return currentTargetPart, currentTargetPart.Position, currentTargetPart.CFrame.LookVector, currentTargetPart.Material
                end
                Arguments[2] = Ray.new(Arguments[2].Origin, getDirection(Arguments[2].Origin, currentTargetPart.Position))
                return oldNamecall(unpack(Arguments))
            end
        elseif Method == "Raycast" and currentMethod == Method then
            if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                shotOrigin = Arguments[2]
                table.insert(recentShots, {origin = shotOrigin, time = tick()})
                if SilentAimSettings.Wallbang then
                    local direction = getDirection(shotOrigin, currentTargetPart.Position)
                    local wallbangParams = RaycastParams.new()
                    wallbangParams.FilterType = Enum.RaycastFilterType.Include
                    wallbangParams.FilterDescendantsInstances = {currentTargetPart.Parent}
                    local newArgs = {self, shotOrigin, direction, wallbangParams}
                    return oldNamecall(unpack(newArgs))
                end
                Arguments[3] = getDirection(Arguments[2], currentTargetPart.Position)
                return oldNamecall(unpack(Arguments))
            end
        elseif (Method == "ScreenPointToRay" or Method == "ViewportPointToRay") and currentMethod == Method and self == Camera then
            shotOrigin = Camera.CFrame.Position
            local direction = (currentTargetPart.Position - shotOrigin).Unit
            table.insert(recentShots, {origin = shotOrigin, time = tick()})
            return Ray.new(shotOrigin, direction)
        end
    end
    return oldNamecall(...)
end))

local oldIndex
local oldRayNew
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    if self == Mouse and not checkcaller() and SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Mouse.Hit/Target" then
        if currentTargetPart then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
                table.insert(recentShots, {origin = LocalPlayer.Character.Head.Position, time = tick()})
            end
            if Index == "Target" or Index == "target" then
                return currentTargetPart
            elseif Index == "Hit" or Index == "hit" then
                return (SilentAimSettings.MouseHitPrediction and (currentTargetPart.CFrame + (currentTargetPart.Velocity * currentTargetPart.Velocity.magnitude * SilentAimSettings.MouseHitPredictionAmount))) or currentTargetPart.CFrame
            elseif Index == "X" or Index == "x" then
                return self.X
            elseif Index == "Y" or Index == "y" then
                return self.Y
            elseif Index == "UnitRay" then
                return Ray.new(self.Origin, (self.Hit.p - self.Origin.p).Unit)
            end
        end
    end
    return oldIndex(self, Index)
end))

oldRayNew = hookfunction(Ray.new, newcclosure(function(origin, direction)
    if SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Ray" and currentTargetPart and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) then
        table.insert(recentShots, {origin = origin, time = tick()})
        local newDirectionVector = getDirection(origin, currentTargetPart.Position)
        return oldRayNew(origin, newDirectionVector)
    end
    return oldRayNew(origin, direction)
end))

Library:OnUnload(function()
    FOVCircleGui:Destroy()
    if IndependentPanelGui then
        IndependentPanelGui:Destroy()
    end
    if currentHighlight then
        currentHighlight:Destroy()
    end
    if transparencyLoopConnection then
        transparencyLoopConnection:Disconnect()
        transparencyLoopConnection = nil
        restoreCharacterAppearance()
    end
    hideAllVisuals()
    oldNamecall:UnHook()
    oldIndex:UnHook()
    oldRayNew:UnHook()
end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder("UniversalSilentAim/Configs")
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

SaveManager:LoadAutoloadConfig()
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})

local MyButton = LeftGroupBox:AddButton({
    Text = '兵工厂',---服务器名称
    Func = function()
    local originalUI = Library
        
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/454244513/WindUIFix/refs/heads/main/main.lua"))()
local Window = WindUI:CreateWindow({
    Title = "YG SCRIPT",
    Author = "付费 by YG team",
    Folder = "CloudHub",
    Size = UDim2.fromOffset(200, 395),
    Transparent = true,
    Theme = "Dark",
    User = {
        Enabled = true,
        Callback = function() end,
        Anonymous = false
    },
    SideBarWidth = 200,
    ScrollBarEnabled = true,
    Background = "https://raw.githubusercontent.com/dohyynd/YG-THINE/refs/heads/main/IMG_20260216_112951_671.jpg",
    BackgroundImageTransparency = 0.65,
})

Window:EditOpenButton({
    Title = "Paid User",
    Icon = "crown",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2.35,
    Color = ColorSequence.new(
        Color3.fromHex("3C1361"),
        Color3.fromHex("6A0DAD")
    ),
    Draggable = true,
})

local HttpService = cloneref(game:GetService("HttpService"))

local isfunctionhooked = clonefunction(isfunctionhooked)
if isfunctionhooked(game.HttpGet) or isfunctionhooked(getnamecallmethod) or isfunctionhooked(request) then 
    return 
end

local function verifyKey(k)
    local ok, res = pcall(function()
        return request({
            Url = "https://ouo.lat/api/verify.php",
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({key = k, time = os.time()})
        })
    end)
    
    if not ok then return false end
    
    if res.Body ~= "True" then
        return false
    end
    
    local ok2, res2 = pcall(function()
        return game:HttpGet("https://www.wtb.lat/keysystem/check-key?key="..k.."&user="..game.Players.LocalPlayer.Name)
    end)
    
    return ok2 and res2 == "success"
end

local key = ""
pcall(function() key = readfile("DyzhKey.json") end)
if key ~= "" then
    if verifyKey(key) then
        print('验证完成')
    else
        return
    end
end

local hitboxEnabled = false
local noCollisionEnabled = false
local hitbox_original_properties = {}
local hitboxSize = 21
local hitboxTransparency = 6
local teamCheck = "FFA"

local defaultBodyParts = {
    "UpperTorso",
    "Head",
    "HumanoidRootPart"
}

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ScreenGui = Instance.new("ScreenGui", LocalPlayer.PlayerGui)
local WarningText = Instance.new("TextLabel", ScreenGui)
WarningText.Size = UDim2.new(0, 200, 0, 50)
WarningText.TextSize = 16
WarningText.Position = UDim2.new(0.5, -150, 0, 0)
WarningText.Text = "警告：可能出现碰撞问题"
WarningText.TextColor3 = Color3.new(1, 0, 0)
WarningText.BackgroundTransparency = 1
WarningText.Visible = false

local function savedPart(player, part)
    if not hitbox_original_properties[player] then
        hitbox_original_properties[player] = {}
    end
    if not hitbox_original_properties[player][part.Name] then
        hitbox_original_properties[player][part.Name] = {
            CanCollide = part.CanCollide,
            Transparency = part.Transparency,
            Size = part.Size
        }
    end
end

local function restoredPart(player)
    if hitbox_original_properties[player] then
        for partName, properties in pairs(hitbox_original_properties[player]) do
            local part = player.Character and player.Character:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanCollide = properties.CanCollide
                part.Transparency = properties.Transparency
                part.Size = properties.Size
            end
        end
    end
end

local function findClosestPart(player, partName)
    if not player.Character then return nil end
    for _, part in ipairs(player.Character:GetChildren()) do
        if part:IsA("BasePart") and part.Name:lower():match(partName:lower()) then
            return part
        end
    end
    return nil
end

local function extendHitbox(player)
    for _, partName in ipairs(defaultBodyParts) do
        local part = player.Character and (player.Character:FindFirstChild(partName) or findClosestPart(player, partName))
        if part and part:IsA("BasePart") then
            savedPart(player, part)
            part.CanCollide = not noCollisionEnabled
            part.Transparency = hitboxTransparency / 10
            part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
        end
    end
end

local function isEnemy(player)
    if teamCheck == "FFA" or teamCheck == "Everyone" then
        return true
    end
    return player.Team ~= LocalPlayer.Team
end

local function shouldExtendHitbox(player)
    return isEnemy(player)
end

local function updateHitboxes()
    for _, v in ipairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            if shouldExtendHitbox(v) then
                extendHitbox(v)
            else
                restoredPart(v)
            end
        end
    end
end

local function onCharacterAdded(character)
    task.wait(0.1)
    if hitboxEnabled then
        updateHitboxes()
    end
end

local function onPlayerAdded(player)
    player.CharacterAdded:Connect(onCharacterAdded)
    player.CharacterRemoving:Connect(function()
        restoredPart(player)
        hitbox_original_properties[player] = nil
    end)
end

local function checkForDeadPlayers()
    for player, _ in pairs(hitbox_original_properties) do
        if not player.Parent or not player.Character or not player.Character:IsDescendantOf(game) then
            restoredPart(player)
            hitbox_original_properties[player] = nil
        end
    end
end

Players.PlayerAdded:Connect(onPlayerAdded)
for _, player in ipairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end

local Tab1 = Window:Tab({  
    Title = "碰撞箱扩大",  
    Icon = "box",  
    Locked = false,
})

Tab1:Button({
    Title = "点击此处启动Hitbox功能",
    Callback = function()
        coroutine.wrap(function()
            while true do
                if hitboxEnabled then
                    updateHitboxes()
                    checkForDeadPlayers()
                end
                task.wait(0.1)
            end
        end)()
    end
})

Tab1:Toggle({
    Title = "开启Hitbox",
    Value = false,
    Callback = function(state)
        hitboxEnabled = state
        if not state then
            for _, player in ipairs(Players:GetPlayers()) do
                restoredPart(player)
            end
            hitbox_original_properties = {}
        else
            updateHitboxes()
        end
    end
})

Tab1:Slider({
    Title = "Hitbox大小",
    Value = {
        Min = 1,
        Max = 25,
        Default = 21
    },
    Callback = function(value)
        hitboxSize = value
        if hitboxEnabled then
            updateHitboxes()
        end
    end
})

Tab1:Slider({
    Title = "Hitbox透明度",
    Value = {
        Min = 1,
        Max = 10,
        Default = 6
    },
    Callback = function(value)
        hitboxTransparency = value
        if hitboxEnabled then
            updateHitboxes()
        end
    end
})

Tab1:Dropdown({
    Title = "队伍检测",
    Multi = false,
    AllowNone = false,
    Value = "FFA",
    Values = {"FFA", "队伍模式", "所有人"},
    Callback = function(value)
        teamCheck = value
        if hitboxEnabled then
            updateHitboxes()
        end
    end
})

Tab1:Toggle({
    Title = "无碰撞模式",
    Value = false,
    Callback = function(state)
        noCollisionEnabled = state
        WarningText.Visible = state
        coroutine.wrap(function()
            while noCollisionEnabled do
                if hitboxEnabled then
                    updateHitboxes()
                end
                task.wait(0.01)
            end
            if hitboxEnabled then
                updateHitboxes()
            end
        end)()
    end
})

Tab1:Toggle({
    Title = "半自动农场",
    Value = false,
    Callback = function(bool)
        getgenv().AutoFarm = bool
        local runServiceConnection
        local mouseDown = false
        local player = game.Players.LocalPlayer
        local camera = game.Workspace.CurrentCamera
        game:GetService("ReplicatedStorage").wkspc.CurrentCurse.Value = bool and "Infinite Ammo" or ""

        local function getClosestEnemyPlayer()
            local closestDistance = math.huge
            local closestPlayer = nil
            for _, enemyPlayer in pairs(game.Players:GetPlayers()) do
                if enemyPlayer ~= player and enemyPlayer.TeamColor ~= player.TeamColor and enemyPlayer.Character then
                    local hrp = enemyPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local humanoid = enemyPlayer.Character:FindFirstChild("Humanoid")
                    if hrp and humanoid and humanoid.Health > 0 then
                        local dist = (player.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                        if dist < closestDistance and hrp.Position.Y >= 0 then
                            closestDistance = dist
                            closestPlayer = enemyPlayer
                        end
                    end
                end
            end
            return closestPlayer
        end

        local function startAutoFarm()
            game:GetService("ReplicatedStorage").wkspc.TimeScale.Value = 12
            runServiceConnection = game:GetService("RunService").Stepped:Connect(function()
                if getgenv().AutoFarm then
                    local target = getClosestEnemyPlayer()
                    if target then
                        local pos = target.Character.HumanoidRootPart.Position + Vector3.new(0, 0, -4)
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
                            camera.CFrame = CFrame.new(camera.CFrame.Position, target.Character.Head.Position)
                            if not mouseDown then
                                mouse1press()
                                mouseDown = true
                            end
                        end
                    else
                        if mouseDown then
                            mouse1release()
                            mouseDown = false
                        end
                    end
                else
                    if runServiceConnection then
                        runServiceConnection:Disconnect()
                        runServiceConnection = nil
                    end
                    if mouseDown then
                        mouse1release()
                        mouseDown = false
                    end
                end
            end)
        end

        local function onCharacterAdded(character)
            wait(0.5)
            startAutoFarm()
        end

        player.CharacterAdded:Connect(onCharacterAdded)
        if bool then
            wait(0.5)
            startAutoFarm()
        else
            game:GetService("ReplicatedStorage").wkspc.CurrentCurse.Value = ""
            getgenv().AutoFarm = false
            game:GetService("ReplicatedStorage").wkspc.TimeScale.Value = 1
            if runServiceConnection then
                runServiceConnection:Disconnect()
                runServiceConnection = nil
            end
            if mouseDown then
                mouse1release()
                mouseDown = false
            end
        end
    end
})

local Tab2 = Window:Tab({  
    Title = "枪械设置",  
    Icon = "crosshair",  
    Locked = false,
})

local originalValues = {
    FireRate = {},
    ReloadTime = {},
    EReloadTime = {},
    Auto = {},
    Spread = {},
    Recoil = {}
}

Tab2:Toggle({
    Title = "无限弹药 v1",
    Value = false,
    Callback = function(state)
        game:GetService("ReplicatedStorage").wkspc.CurrentCurse.Value = state and "Infinite Ammo" or ""
    end
})

Tab2:Toggle({
    Title = "快速换弹",
    Value = false,
    Callback = function(state)
        for _, v in pairs(game.ReplicatedStorage.Weapons:GetChildren()) do
            if v:FindFirstChild("ReloadTime") then
                if state then
                    if not originalValues.ReloadTime[v] then
                        originalValues.ReloadTime[v] = v.ReloadTime.Value
                    end
                    v.ReloadTime.Value = 0.01
                else
                    v.ReloadTime.Value = originalValues.ReloadTime[v] or 0.8
                end
            end
            if v:FindFirstChild("EReloadTime") then
                if state then
                    if not originalValues.EReloadTime[v] then
                        originalValues.EReloadTime[v] = v.EReloadTime.Value
                    end
                    v.EReloadTime.Value = 0.01
                else
                    v.EReloadTime.Value = originalValues.EReloadTime[v] or 0.8
                end
            end
        end
    end
})

Tab2:Toggle({
    Title = "快速射击",
    Value = false,
    Callback = function(state)
        for _, v in pairs(game.ReplicatedStorage.Weapons:GetDescendants()) do
            if v.Name == "FireRate" or v.Name == "BFireRate" then
                if state then
                    if not originalValues.FireRate[v] then
                        originalValues.FireRate[v] = v.Value
                    end
                    v.Value = 0.02
                else
                    v.Value = originalValues.FireRate[v] or 0.8
                end
            end
        end
    end
})

Tab2:Toggle({
    Title = "自动连发",
    Value = false,
    Callback = function(state)
        for _, v in pairs(game.ReplicatedStorage.Weapons:GetDescendants()) do
            if v.Name == "Auto" or v.Name == "AutoFire" or v.Name == "Automatic" or v.Name == "AutoShoot" or v.Name == "AutoGun" then
                if state then
                    if not originalValues.Auto[v] then
                        originalValues.Auto[v] = v.Value
                    end
                    v.Value = true
                else
                    v.Value = originalValues.Auto[v] or false
                end
            end
        end
    end
})

Tab2:Toggle({
    Title = "无扩散",
    Value = false,
    Callback = function(state)
        for _, v in pairs(game.ReplicatedStorage.Weapons:GetDescendants()) do
            if v.Name == "MaxSpread" or v.Name == "Spread" or v.Name == "SpreadControl" then
                if state then
                    if not originalValues.Spread[v] then
                        originalValues.Spread[v] = v.Value
                    end
                    v.Value = 0
                else
                    v.Value = originalValues.Spread[v] or 1
                end
            end
        end
    end
})

Tab2:Toggle({
    Title = "无后坐力",
    Value = false,
    Callback = function(state)
        for _, v in pairs(game.ReplicatedStorage.Weapons:GetDescendants()) do
            if v.Name == "RecoilControl" or v.Name == "Recoil" then
                if state then
                    if not originalValues.Recoil[v] then
                        originalValues.Recoil[v] = v.Value
                    end
                    v.Value = 0
                else
                    v.Value = originalValues.Recoil[v] or 1
                end
            end
        end
    end
})

local Tab3 = Window:Tab({  
    Title = "玩家",  
    Icon = "person-standing",  
    Locked = false,
})

Tab3:Button({
    Title = "移速(懒得写)",
    Desc = nil,
    Locked = false,
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/dohyynd/Y_-SCRIPT/refs/heads/main/READM%E3%80%82E.lua"))()
    end
})

local isJumpPowerEnabled = false
local jumpMethods = {"Velocity", "Vector", "CFrame"}
local selectedJumpMethod = jumpMethods[1]

Tab3:Toggle({
    Title = "自定义跳跃高度",
    Value = false,
    Callback = function(state)
        isJumpPowerEnabled = state
    end
})

Tab3:Dropdown({
    Title = "跳跃方法",
    Multi = false,
    AllowNone = false,
    Value = selectedJumpMethod,
    Values = jumpMethods,
    Callback = function(selected)
        selectedJumpMethod = selected
    end
})

Tab3:Slider({
    Title = "跳跃高度",
    Value = {
        Min = 30,
        Max = 500,
        Default = 30,
    },
    Callback = function(value)
        local player = game:GetService("Players").LocalPlayer
        local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.UseJumpPower = true
            humanoid.Jumping:Connect(function(isActive)
                if isJumpPowerEnabled and isActive then
                    local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        if selectedJumpMethod == "Velocity" then
                            rootPart.Velocity = Vector3.new(rootPart.Velocity.X, value, rootPart.Velocity.Z)
                        elseif selectedJumpMethod == "Vector" then
                            rootPart.Velocity = Vector3.new(0, value, 0)
                        elseif selectedJumpMethod == "CFrame" then
                            player.Character:SetPrimaryPartCFrame(player.Character:GetPrimaryPartCFrame() + Vector3.new(0, value, 0))
                        end
                    end
                end
            end)
        end
    end
})

local Tab4 = Window:Tab({  
    Title = "美化",  
    Icon = "hand-platter",  
    Locked = false,
})



local gunMaterial = "Plastic"
local gunColor = Color3.fromRGB(50, 50, 50)
local gunCharmsEnabled = false

Tab4:Dropdown({
    Title = "枪械材质",
    Multi = false,
    AllowNone = false,
    Value = gunMaterial,
    Values = {"Plastic", "ForceField", "Wood", "Grass"},
    Callback = function(value)
        gunMaterial = value
    end
})

Tab4:Colorpicker({
    Title = "枪械颜色",
    Default = Color3.fromRGB(50, 50, 50),
    Callback = function(color)
        gunColor = color
    end
})

Tab4:Toggle({
    Title = "开启枪械美化",
    Value = false,
    Callback = function(state)
        gunCharmsEnabled = state
        if gunCharmsEnabled then
            spawn(function()
                while gunCharmsEnabled do
                    task.wait(0.01)
                    local cameraArms = workspace.Camera:FindFirstChild("Arms")
                    if cameraArms then
                        for _, part in pairs(cameraArms:GetDescendants()) do
                            if part:IsA("MeshPart") then
                                part.Material = Enum.Material[gunMaterial]
                                part.Color = gunColor
                            end
                        end
                    end
                end
            end)
        end
    end
})

local Tab5 = Window:Tab({  
    Title = "聊天标签/娱乐",  
    Icon = "message-circle",  
    Locked = false,
})

Tab5:Toggle({
    Title = "IsChad",
    Value = false,
    Callback = function(state)
        local player = game.Players.LocalPlayer
        if player:FindFirstChild("IsChad") then
            player.IsChad:Destroy()
        end
        if state then
            local val = Instance.new("IntValue", player)
            val.Name = "IsChad"
        end
    end
})

Tab5:Toggle({
    Title = "VIP",
    Value = false,
    Callback = function(state)
        local player = game.Players.LocalPlayer
        if player:FindFirstChild("VIP") then
            player.VIP:Destroy()
        end
        if state then
            local val = Instance.new("IntValue", player)
            val.Name = "VIP"
        end
    end
})

Tab5:Toggle({
    Title = "OldVIP",
    Value = false,
    Callback = function(state)
        local player = game.Players.LocalPlayer
        if player:FindFirstChild("OldVIP") then
            player.OldVIP:Destroy()
        end
        if state then
            local val = Instance.new("IntValue", player)
            val.Name = "OldVIP"
        end
    end
})

Tab5:Toggle({
    Title = "Romin",
    Value = false,
    Callback = function(state)
        local player = game.Players.LocalPlayer
        if player:FindFirstChild("Romin") then
            player.Romin:Destroy()
        end
        if state then
            local val = Instance.new("IntValue", player)
            val.Name = "Romin"
        end
    end
})

Tab5:Toggle({
    Title = "管理员",
    Value = false,
    Callback = function(state)
        local player = game.Players.LocalPlayer
        if player:FindFirstChild("IsAdmin") then
            player.IsAdmin:Destroy()
        end
        if state then
            local val = Instance.new("IntValue", player)
            val.Name = "IsAdmin"
        end
    end
})

local Tab6 = Window:Tab({
    Title = "设置",
    Icon = "settings",
    Locked = false,
})

local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

Tab6:Dropdown({
    Title = "更改ui颜色",
    Multi = false,
    AllowNone = false,
    Value = nil,
    Values = themeValues,
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})

-- ========== 窗口关闭处理 ==========
Window:OnClose(function()
    if rainbowBorderAnimation then
        rainbowBorderAnimation:Disconnect()
        rainbowBorderAnimation = nil
    end
end)

Window:OnDestroy(function()
    if rainbowBorderAnimation then
        rainbowBorderAnimation:Disconnect()
        rainbowBorderAnimation = nil
    end
    for _, animation in pairs(fontColorAnimations or {}) do
        animation:Disconnect()
    end
    fontColorAnimations = {}
end)

WindUI:Notify({ 
    Title = "YG付费版", 
    Content = "已全部加载",
    Duration = 5,
    Icon = "check-circle"
})
        
        
    
        task.wait(0.5)----等待时间
        
      
        if originalUI then
            originalUI:Unload()  ----加载完删除加载器ui
        end
    end,
    
    Tooltip = '加载该服务器',
    DoubleClick = true,----双击加载，关闭将true改为false
    Disabled = false,
    Visible = true
})





local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;
local GetPing = (function() return math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue()) end)
local CanDoPing = pcall(function() return GetPing(); end)

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
	FrameCounter += 1;

	if (tick() - FrameTimer) >= 1 then
		FPS = FrameCounter;
		FrameTimer = tick();
		FrameCounter = 0;
	end;

	if CanDoPing then
		Library:SetWatermark(('YG SCRIPT付费 | %d fps | %d ms'):format(
			math.floor(FPS),
			GetPing()
		));
	else
		Library:SetWatermark(('YG SCRIPT付费 | %d fps'):format(
			math.floor(FPS)
		));
	end
end);

Library:OnUnload(function()
	WatermarkConnection:Disconnect()

	print('Unloaded!')
	Library.Unloaded = true
end)

-- UI Settings
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddToggle("KeybindMenuOpen", { Default = Library.KeybindFrame.Visible, Text = "Open Keybind Menu", Callback = function(value) Library.KeybindFrame.Visible = value end})
MenuGroup:AddToggle("ShowCustomCursor", {Text = "Custom Cursor", Default = true, Callback = function(Value) Library.ShowCustomCursor = Value end})
MenuGroup:AddDivider()
MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })
MenuGroup:AddButton("Unload", function() Library:Unload() end)

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- ThemeManager (Allows you to have a menu theme system)

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- Adds our MenuKeybind to the ignore list
-- (do you want each config to have a different menu key? probably not.)
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')
SaveManager:SetSubFolder('specific-place') -- if the game has multiple places inside of it (for example: DOORS) 
					   -- you can use this to save configs for those places separately
					   -- The path in this script would be: MyScriptHub/specific-game/settings/specific-place
					   -- [ This is optional ]

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs['UI Settings'])

-- Builds our theme menu (with plenty of built in themes) on the left side
-- NOTE: you can also call ThemeManager:ApplyToGroupbox to add it to a specific groupbox
ThemeManager:ApplyToTab(Tabs['UI Settings'])

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
